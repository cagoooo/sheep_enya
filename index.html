
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>剛好學：課堂互動so easy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        /* --- 全新初始畫面美化樣式 --- */
        body.initial-view-background {
            background-color: #f0f4f8; /* Fallback */
            background-image:
                radial-gradient(circle at 1px 1px, #d1d5db 1px, transparent 0),
                radial-gradient(circle at 20px 20px, #d1d5db 1px, transparent 0);
            background-size: 40px 40px;
        }

        .role-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff;
            padding: 1.25rem 1rem;
            border-radius: 1rem;
            border: 1px solid #e5e7eb;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05);
            transition: all 0.3s ease-in-out;
            text-align: center;
        }
        @media (min-width: 640px) {
            .role-card {
                padding: 1.5rem 1.25rem;
            }
        }
        @media (min-width: 768px) {
            .role-card {
                padding: 2rem 1.5rem;
            }
        }
        .role-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -2px rgb(0 0 0 / 0.05);
            border-color: #93c5fd; /* Light blue border on hover */
        }
        .role-card-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            transition: all 0.3s ease-in-out;
        }
        @media (min-width: 640px) {
            .role-card-icon {
                width: 70px;
                height: 70px;
                font-size: 2.25rem;
            }
        }
        @media (min-width: 768px) {
            .role-card-icon {
                width: 80px;
                height: 80px;
                font-size: 2.5rem;
            }
        }
        .role-card .btn {
            font-size: 1rem;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        @media (min-width: 640px) {
            .role-card .btn {
                font-size: 1.1rem;
                padding-top: 0.625rem;
                padding-bottom: 0.625rem;
            }
        }
        /* --- 初始畫面樣式結束 --- */

        /* 自訂樣式 */
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f0f4f8; /* 柔和的背景色 */
        }
        /* 隱藏元素的通用 class */
        .hidden {
            display: none;
        }
        /* 按鈕樣式 (直接在 HTML 中使用 Tailwind class，不使用 @apply) */
        .btn {
            display: inline-block;
            width: 100%;
            padding: 1rem 1.5rem;
            font-size: 1.25rem;
            line-height: 1.75rem;
            font-weight: 700;
            color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: transform 0.2s ease-in-out;
        }
        .btn:hover {
            transform: scale(1.05);
        }
        .btn-primary { background-color: #2563eb; }
        .btn-primary:hover { background-color: #1d4ed8; }
        .btn-green { background-color: #16a34a; }
        .btn-green:hover { background-color: #15803d; }
        .btn-orange { background-color: #ea580c; }
        .btn-orange:hover { background-color: #c2410c; }
        .btn-purple { background-color: #9333ea; }
        .btn-purple:hover { background-color: #7e22ce; }
        .btn-red { background-color: #dc2626; }
        .btn-red:hover { background-color: #b91c1c; }
        .btn-teal { background-color: #0d9488; } /* New Teal color */
        .btn-teal:hover { background-color: #0f766e; }
        .btn-gray { background-color: #9ca3af; cursor: not-allowed; }

        /* 搶答按鈕樣式 */
        .quick-answer-btn {
            position: absolute;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            font-size: 24px;
            font-weight: bold;
            border: none;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse 2s infinite;
        }
        .quick-answer-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.4);
        }
        .quick-answer-btn:active {
            transform: scale(0.95);
        }
        .quick-answer-btn.locked {
            background: #9ca3af;
            cursor: not-allowed;
            animation: none;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* 繪圖板 Canvas 樣式 */
        #drawing-canvas {
            border: 2px solid #cbd5e1;
            border-radius: 0.5rem;
            cursor: crosshair;
            touch-action: none; /* 防止在 canvas 上繪圖時觸發頁面滾動 */
            display: block; /* Ensures it takes up its own line and respects margins */
            margin: 0 auto; /* Center the canvas */
            background-color: white; /* 繪圖畫布背景色 */
            flex-grow: 1; /* Allow canvas to take available vertical space */
            width: 100%; /* Ensure canvas takes full width within its container */
        }
        /* 學生作答結果卡片 */
        .student-card {
            background-color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            margin-bottom: 0.75rem;
            word-break: break-all;
        }

        /* 新增：用於學生作答列表的卡片樣式 */
        .student-response-item {
            background-color: #fff;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* 將內容向左對齊 */
            justify-content: flex-start; /* 將內容向上對齊 */
            text-align: left; /* 將文本向左對齊 */
            transition: border 0.3s ease-in-out, box-shadow 0.3s ease-in-out; /* Add transition for smooth border change */
        }
        .student-response-item .name-box {
            background-color: #d1e7dd; /* Light green for name */
            color: #0f5132; /* Dark green text */
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            width: 100%; /* Take full width within its grid column */
            max-width: 150px; /* Max width for name box */
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            text-align: center; /* 讓姓名在框內置中 */
        }
        .student-response-item .answer-box {
            background-color: white; /* Changed to white */
            color: #0e7490; /* Dark blue text */
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            width: 100%; /* Take full width within its grid column */
            word-break: break-word;
            flex-grow: 1; /* Allow answer box to take available space */
            min-height: 48px; /* Ensure a consistent height regardless of content */
            display: flex; /* To vertically center content */
            align-items: center;
            justify-content: center;
        }
        .student-response-item .answer-box img {
            max-width: 100%; /* Make images responsive within the answer box */
            height: auto;
            max-height: 120px; /* Limit image height to prevent large images */
            object-fit: contain; /* Ensure image fits without cropping */
            display: block; /* Remove extra space below image */
            margin: 0 auto; /* Center image if it's smaller than max-width */
        }
        .student-response-item .answer-box audio {
            width: 100%;
            max-width: 200px; /* Limit audio player width */
        }
        /* New: Styles for custom multiple choice answers in teacher monitor */
        .student-response-item .mc-question-answer {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
            color: #334155;
        }
        .student-response-item .mc-question-answer .icon {
            font-size: 1.1rem;
        }
        .student-response-item .mc-question-answer .correct-icon {
            color: #16a34a; /* Green */
        }
        .student-response-item .mc-question-answer .incorrect-icon {
            color: #dc2626; /* Red */
        }
        .student-response-item .mc-question-answer .question-text {
            font-weight: 500;
        }
        .student-response-item .mc-question-answer .student-choice {
            font-weight: bold;
            color: #2563eb; /* Blue */
        }

        /* 互評投票相關樣式 */
        .peer-review-work-item {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            border: 2px solid transparent;
        }
        
        .peer-review-work-item:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }
        
        .peer-review-work-item .work-author {
            background-color: #e0f2fe;
            color: #0369a1;
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            font-weight: bold;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
        }
        
        .peer-review-work-item .work-content {
            flex-grow: 1;
            margin-bottom: 0.75rem;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .peer-review-work-item .work-content img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .peer-review-work-item .work-content p {
            padding: 0.5rem;
            background-color: #f8fafc;
            border-radius: 0.5rem;
            color: #374151;
            line-height: 1.5;
        }
        
        .peer-review-work-item .vote-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .peer-review-work-item .vote-btn {
            background: none;
            border: 2px solid transparent;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 3rem;
            height: 3rem;
            position: relative;
        }
        
        .peer-review-work-item .vote-btn:hover {
            background-color: #fef7f7;
            transform: scale(1.1);
            border-color: #fca5a5;
        }
        
        .peer-review-work-item .vote-btn.voted {
            color: #dc2626;
            background-color: #fef2f2;
            border-color: #dc2626;
            animation: pulse 2s infinite;
        }
        
        .peer-review-work-item .vote-btn:not(.voted) {
            color: #9ca3af;
            border-color: #e5e7eb;
        }
        
        .peer-review-work-item .vote-btn:not(.voted):hover {
            color: #dc2626;
            background-color: #fef7f7;
        }
        
        /* Pulse animation for voted buttons */
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        /* Tooltip for vote buttons */
        .peer-review-work-item .vote-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: -2rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: #374151;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
            z-index: 10;
        }
        
        .peer-review-work-item .vote-btn:hover::after {
            opacity: 1;
            visibility: visible;
        }
        
        .peer-review-work-item .vote-count {
            font-weight: bold;
            color: #dc2626;
            font-size: 1.1rem;
        }
        
        .peer-review-work-item .vote-count.zero {
            color: #9ca3af;
        }

        /* 教師端投票統計樣式 */
        .vote-stats-item {
            background-color: #f8fafc;
            border-radius: 0.75rem;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            border: 1px solid #e2e8f0;
            position: relative;
        }
        
        .vote-stats-item .stats-author {
            background-color: #dbeafe;
            color: #1e40af;
            padding: 0.375rem 0.75rem;
            border-radius: 0.75rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }
        
        .vote-stats-item .stats-content {
            flex-grow: 1;
            margin-bottom: 0.5rem;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .vote-stats-item .stats-content img {
            max-width: 100%;
            height: auto;
            border-radius: 0.375rem;
            max-height: 120px;
            object-fit: contain;
        }
        
        .vote-stats-item .stats-content p {
            padding: 0.375rem;
            background-color: white;
            border-radius: 0.375rem;
            color: #374151;
            font-size: 0.875rem;
            line-height: 1.4;
        }
        
        .vote-stats-item .stats-votes {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.5rem;
            background-color: #fef2f2;
            border-radius: 0.5rem;
            border: 1px solid #fecaca;
        }
        
        .vote-stats-item .stats-votes .vote-icon {
            color: #dc2626;
            font-size: 1.2rem;
        }
        
        .vote-stats-item .stats-votes .vote-count {
            font-weight: bold;
            color: #dc2626;
            font-size: 1.1rem;
        }
        
        .vote-stats-item .stats-votes .vote-count.zero {
            color: #9ca3af;
        }


        /* 放大繪圖 Modal 樣式 */
        .magnified-image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        .magnified-image-modal-content {
            position: relative;
            background-color: white;
            padding: 1rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto; /* Allow scrolling for large content */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
        }

        /* 排序題和配對題的模態框樣式 */
        #sequencing-settings-modal-content,
        #matching-settings-modal-content {
            max-width: 95%;
            max-height: 95vh;
            width: 1200px;
            justify-content: flex-start;
            align-items: stretch;
        }
        .magnified-image-modal-content img {
            max-width: 100%;
            max-height: 80vh; /* Limit image height within modal */
            object-fit: contain;
        }
        .magnified-image-modal-close {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            font-size: 2rem;
            color: #333;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            transition: background-color 0.2s;
        }
        .magnified-image-modal-close:hover {
            background-color: #eee;
        }

        /* Dropdown styles for drawing tools */
        .drawing-tool-select {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            border: 1px solid #d1d5db;
            background-color: white;
            font-size: 1rem;
            height: 44px; /* Match button height for alignment */
            cursor: pointer;
            min-width: 100px; /* Ensure dropdown has minimum width */
            appearance: none; /* Remove default dropdown arrow */
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.25em 1.25em;
        }

        /* Styles for color swatch in dropdown */
        .color-option-text {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .color-swatch {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #ccc;
            flex-shrink: 0; /* Prevent shrinking when text is long */
        }
        /* Hidden select for visual color swatch */
        #current-color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #2563eb; /* Highlight selected color */
            margin-right: 8px;
            display: inline-block;
            vertical-align: middle;
            flex-shrink: 0;
        }

        /* Made by link styling */
        .made-by-text {
            background-color: #e0f7fa; /* Light blue background */
            color: #007bff; /* Blue text */
            padding: 8px 15px;
            border-radius: 12px; /* Rounded corners */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-decoration: none; /* Remove underline */
            transition: background-color 0.3s ease;
        }
        .made-by-text:hover {
            background-color: #cceeff; /* Lighter blue on hover */
            color: #0056b3;
        }

        /* Modal for student list */
        #student-list-modal-content {
            padding: 1rem;
            max-width: 700px; /* Adjusted max-width for 5 columns */
            width: 100%;
        }
        /* Applying grid to modal-student-names */
        #modal-student-names {
            display: grid;
            /* Changed to fixed 5 columns on larger screens, responsive down to 100px min width */
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 0.5rem; /* Gap between grid items */
            padding: 0.5rem; /* Padding for the grid container */
            max-height: 64vh; /* Adjusted to fit more height */
            overflow-y: auto;
            background-color: #f8fafc; /* Light background */
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
        }
        @media (min-width: 768px) { /* md breakpoint */
            #modal-student-names {
                grid-template-columns: repeat(5, 1fr); /* Fixed 5 columns for md and larger */
            }
        }
        #modal-student-names p {
            background-color: #e0f2f7; /* Light blue background for each name */
            padding: 0.5rem;
            border-radius: 0.375rem;
            text-align: center;
            font-size: 0.9rem;
            color: #0e7490;
            font-weight: 500;
            overflow: hidden; /* Hide overflow text */
            text-overflow: ellipsis; /* Add ellipsis for overflow */
            white-space: nowrap; /* Prevent text wrapping */
            border-bottom: none; /* Remove individual border-bottom, handled by grid gap */
            margin: 0; /* Remove default paragraph margin */
            transition: all 0.2s ease-in-out; /* Add transition for smooth highlight */
        }
        /* No specific styling for the last-child within the grid items, as gap handles spacing */

        /* NEW: Styles for Unsubmitted Students Modal */
        #modal-unsubmitted-student-names {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 0.5rem;
            padding: 0.5rem;
            max-height: 64vh;
            overflow-y: auto;
            background-color: #fef2f2; /* Light red background */
            border-radius: 0.5rem;
            border: 1px solid #fca5a5; /* Red border */
        }
        #modal-unsubmitted-student-names p {
            background-color: #fee2e2; /* Lighter red background for each name */
            padding: 0.5rem;
            border-radius: 0.375rem;
            text-align: center;
            font-size: 0.9rem;
            color: #b91c1c; /* Darker red text */
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin: 0;
        }
        @media (min-width: 768px) { /* md breakpoint */
            #modal-unsubmitted-student-names {
                grid-template-columns: repeat(5, 1fr);
            }
        }


        /* Styles for Chart Modal */
        #statistics-modal-content { /* Changed ID to match HTML */
            padding: 1rem;
            max-width: 600px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #chart-svg {
            display: block;
            margin: 0 auto;
            background-color: #fff; /* Ensure chart background is white */
            border-radius: 0.5rem;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #students-by-answer-list-container {
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 0.75rem;
            background-color: #f8fafc;
        }
        #students-by-answer-list-container h5 {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #334155;
        }
        /* New style for the paragraph containing names */
        #students-by-answer-names {
            word-wrap: break-word; /* Allow long names to wrap */
            color: #475569;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        /* New CSS for selected student border */
        .selected-student-border {
            border: 4px solid #ef4444; /* Tailwind red-500 */
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.6); /* Optional: add a glow effect */
        }

        /* NEW CSS for selected student border in the modal */
        .modal-selected-student-border {
            border: 2px solid #ef4444; /* Red border */
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.4); /* Optional: add a glow effect */
            background-color: #fef2f2; /* Light red background */
        }


        /* AI Text Summary Modal Styles */
        #ai-summary-modal-content {
            padding: 1.5rem;
            max-width: 500px;
            width: 90%;
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            position: relative; /* Needed for close button positioning */
        }
        #ai-summary-modal-content h4 {
            font-size: 1.75rem;
            font-weight: bold;
            color: #334155;
            text-align: center;
            margin-bottom: 0.5rem;
        }
        #ai-summary-result-list {
            list-style-type: none; /* Removed decimal numbering */
            padding-left: 0; /* Removed default padding for list */
            font-size: 1rem;
        }
        /* Default style for list items (successful results) */
        #ai-summary-result-list li {
            margin-bottom: 0.4rem;
            padding: 0.2rem 0;
            border-bottom: 1px dashed #e2e8f0;
            color: black; /* Changed to black */
            font-weight: bold; /* Added bold */
        }
        #ai-summary-result-list li:last-child {
            border-bottom: none;
        }
        /* Style for error messages within the list */
        #ai-summary-result-list li.error-message {
            color: white; /* White color for error messages */
            background-color: #dc2626; /* A red background for visual emphasis (optional, but good for error) */
            padding: 0.5rem;
            border-radius: 0.25rem;
            text-align: center;
        }
        #ai-loading-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100px; /* Ensure some height for spinner */
            color: #2563eb;
            font-size: 1.1rem;
        }

        /* AI Settings Modal Styles */
        #ai-settings-modal-content {
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            position: relative;
        }
        #ai-settings-modal-content h4 {
            font-size: 1.75rem;
            font-weight: bold;
            color: #334155;
            text-align: center;
            margin-bottom: 0.5rem;
        }
        #ai-settings-modal-content label {
            font-weight: 500;
            color: #475569;
            margin-bottom: 0.25rem;
            display: block;
        }
        #ai-settings-modal-content select,
        #ai-settings-modal-content input[type="password"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            font-size: 1rem;
            background-color: white;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.25em 1.25em;
        }
        #ai-settings-modal-content input[type="password"] {
            background-image: none; /* Remove dropdown arrow for password field */
        }
        .settings-button-group {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            margin-top: 1rem;
        }
        .settings-button-group .btn {
            width: auto;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
        }

        /* New: URL Dispatch Modal Styles */
        #url-dispatch-settings-modal-content {
            padding: 1.5rem;
            max-width: 500px;
            width: 90%;
        }
        #url-dispatch-settings-modal-content h4 {
            font-size: 1.75rem;
            font-weight: bold;
            color: #334155;
            text-align: center;
            margin-bottom: 1.5rem;
        }
        #url-dispatch-settings-modal-content label {
            font-weight: 500;
            color: #475569;
            margin-bottom: 0.25rem;
            display: block;
        }
        #url-dispatch-settings-modal-content input[type="text"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            font-size: 1rem;
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-top: 1rem;
            gap: 0.5rem;
        }
        .checkbox-container input[type="checkbox"] {
            height: 1.25rem;
            width: 1.25rem;
            border-radius: 0.25rem;
            border-color: #d1d5db;
            color: #2563eb;
        }

        /* New: Student-side URL Dispatch Styles */
        #interaction-url-dispatch {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            padding: 1rem;
        }
        .url-card {
            background-color: #ffffff;
            border-radius: 1rem;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            text-decoration: none;
            color: inherit;
        }
        .url-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
        }
        .url-card-icon {
            font-size: 4rem;
            color: #2563eb;
        }
        .url-card-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1e3a8a;
        }
        .url-card-link {
            font-size: 1rem;
            color: #6b7280;
            word-break: break-all;
        }
        .youtube-embed-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding-bottom: 56.25%; /* 16:9 aspect ratio */
            height: 0;
            overflow: hidden;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            background-color: #000; /* 添加黑色背景，如果影片載入失敗會看到 */
        }
        .youtube-embed-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0;
        }

        /* NEW: Pause Overlay for Student */
        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9); /* Semi-transparent white */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999; /* Below modals */
            border-radius: 0.5rem; /* Match container border-radius */
            text-align: center;
            padding: 1rem;
        }
        .pause-overlay p {
            font-size: 2rem;
            font-weight: bold;
            color: #dc2626; /* Red text */
            margin-bottom: 1rem;
        }
        .pause-overlay i {
            font-size: 4rem;
            color: #ef4444; /* Lighter red icon */
        }

        /* NEW: HTML Dispatch Styles */
        /* This ID is now reused for the combined dispatch, but the content will be in the iframe */
        #interaction-html-dispatch {
            position: fixed; /* Use fixed positioning to cover entire screen */
            top: 0;
            left: 0;
            width: 100vw; /* Full viewport width */
            height: 100vh; /* Full viewport height */
            margin: 0;
            padding: 0;
            border: none;
            overflow: hidden; /* Prevent scrolling at container level */
            background-color: white;
            z-index: 1000; /* Ensure it's above other content */
        }
        #html-content-iframe {
            width: 100vw; /* Full viewport width */
            height: 100vh; /* Full viewport height */
            margin: 0;
            padding: 0;
            border: none;
            background-color: white;
            display: block; /* Ensure no inline spacing */
        }

        /* HTML Dispatch Status Indicator */
        .html-dispatch-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: rgba(239, 68, 68, 0.9); /* Red background with transparency */
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            z-index: 1001; /* Above the HTML content */
            animation: blink-glow 1.5s ease-in-out infinite alternate;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
        }

        @keyframes blink-glow {
            0% {
                opacity: 0.7;
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
            }
            100% {
                opacity: 1;
                transform: scale(1.05);
                box-shadow: 0 4px 16px rgba(239, 68, 68, 0.6);
            }
        }

        /* NEW: Styles for enlarged default multiple-choice buttons with RWD */
        #interaction-multiple-choice.enlarged-buttons #default-mc-options .answer-btn {
            width: 10rem; /* Mobile */
            height: 10rem;
            font-size: 6rem;
        }
        @media (min-width: 640px) {
            #interaction-multiple-choice.enlarged-buttons #default-mc-options .answer-btn {
                width: 12rem; /* Tablet */
                height: 12rem;
                font-size: 7rem;
            }
        }
        @media (min-width: 768px) {
            #interaction-multiple-choice.enlarged-buttons #default-mc-options .answer-btn {
                width: 14rem; /* Desktop */
                height: 14rem;
                font-size: 8rem;
            }
        }
        
        /* MODIFIED: MC Settings Modal for AI Question Generation */
        #multiple-choice-settings-modal {
            align-items: center; /* Center modal vertically */
        }

        #multiple-choice-settings-modal-content {
            max-width: 800px; /* Wider modal for two columns */
            max-height: 95vh; /* Increase max height */
            height: auto; /* Allow dynamic height */
            justify-content: flex-start; /* Align content to top */
            align-items: stretch; /* Stretch to full width */
            padding: 1.5rem; /* Increase padding */
            margin-top: 0; /* Remove top margin */
        }

        /* Sequencing Question Styles - RWD Optimized */
        .sequencing-item {
            background-color: white;
            border-radius: 0.75rem;
            padding: 0.875rem 1rem;
            margin-bottom: 0.625rem;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            cursor: grab;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1rem;
            font-weight: 500;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        @media (min-width: 640px) {
            .sequencing-item {
                padding: 1rem 1.25rem;
                margin-bottom: 0.75rem;
                gap: 1rem;
                font-size: 1.125rem;
            }
        }
        @media (min-width: 768px) {
            .sequencing-item {
                padding: 1.125rem 1.5rem;
                margin-bottom: 0.875rem;
                font-size: 1.25rem;
            }
        }
        .sequencing-item::before {
            content: '⋮⋮';
            color: #9ca3af;
            font-size: 1.25rem;
            line-height: 1;
            margin-right: -0.25rem;
            transition: color 0.2s ease;
        }
        .sequencing-item:hover {
            box-shadow: 0 6px 12px rgba(59, 130, 246, 0.15);
            transform: translateY(-3px);
            border-color: #93c5fd;
        }
        .sequencing-item:hover::before {
            color: #3b82f6;
        }
        .sequencing-item:active {
            cursor: grabbing;
        }
        .sequencing-item.dragging {
            opacity: 0.75;
            cursor: grabbing;
            transform: scale(1.05) rotate(2deg);
            box-shadow: 0 12px 24px rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
            z-index: 1000;
            animation: pulse-drag 0.6s ease-in-out infinite;
        }
        @keyframes pulse-drag {
            0%, 100% { transform: scale(1.05) rotate(2deg); }
            50% { transform: scale(1.08) rotate(2deg); }
        }
        .sequencing-item.drag-over {
            border-color: #3b82f6;
            background-color: #eff6ff;
            transform: translateY(0);
        }
        .sequencing-item-number {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            width: 2.25rem;
            height: 2.25rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }
        @media (min-width: 640px) {
            .sequencing-item-number {
                width: 2.5rem;
                height: 2.5rem;
            }
        }
        @media (min-width: 768px) {
            .sequencing-item-number {
                width: 2.75rem;
                height: 2.75rem;
                font-size: 1.125rem;
            }
        }
        .sequencing-item:hover .sequencing-item-number {
            transform: rotate(360deg);
        }
        .sequencing-item-text {
            flex: 1;
            line-height: 1.5;
        }
        .sequencing-container {
            max-width: 600px;
            margin: 0 auto;
            padding: 0 0.5rem;
        }
        @media (min-width: 640px) {
            .sequencing-container {
                padding: 0;
            }
        }

        /* Matching Question Styles - RWD Optimized */
        .matching-container {
            max-width: 900px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            position: relative;
            padding: 0 0.5rem;
        }
        @media (min-width: 640px) {
            .matching-container {
                gap: 1.5rem;
                padding: 0;
            }
        }
        @media (min-width: 768px) {
            .matching-container {
                gap: 2.5rem;
            }
        }
        .matching-column {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            z-index: 2;
        }
        @media (min-width: 640px) {
            .matching-column {
                gap: 1rem;
            }
        }
        .matching-item {
            background-color: white;
            border-radius: 0.75rem;
            padding: 0.875rem 1rem;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 3px solid #e5e7eb;
            font-size: 0.9375rem;
            font-weight: 500;
            min-height: 3.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
        }
        @media (min-width: 640px) {
            .matching-item {
                padding: 1rem 1.25rem;
                min-height: 4rem;
                font-size: 1.0625rem;
            }
        }
        @media (min-width: 768px) {
            .matching-item {
                padding: 1.125rem 1.5rem;
                min-height: 4.5rem;
                font-size: 1.125rem;
            }
        }
        .matching-item:hover {
            box-shadow: 0 6px 12px rgba(236, 72, 153, 0.12);
            transform: translateY(-2px) scale(1.02);
            border-color: #f9a8d4;
        }
        .matching-item.selected {
            border-color: #ec4899;
            background: linear-gradient(135deg, #fdf2f8 0%, #fce7f3 100%);
            box-shadow: 0 0 0 4px rgba(236, 72, 153, 0.15), 0 6px 16px rgba(236, 72, 153, 0.2);
            animation: pulse-select 1.5s ease-in-out infinite;
            transform: scale(1.05);
        }
        @keyframes pulse-select {
            0%, 100% { 
                box-shadow: 0 0 0 4px rgba(236, 72, 153, 0.15), 0 6px 16px rgba(236, 72, 153, 0.2);
            }
            50% { 
                box-shadow: 0 0 0 6px rgba(236, 72, 153, 0.25), 0 8px 20px rgba(236, 72, 153, 0.3);
            }
        }
        .matching-item.selected::after {
            content: '✓';
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
            color: white;
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: bold;
            box-shadow: 0 2px 6px rgba(236, 72, 153, 0.4);
            animation: pop-in 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        @keyframes pop-in {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }
        .matching-item.matched {
            border-color: #10b981;
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            cursor: default;
            box-shadow: 0 4px 10px rgba(16, 185, 129, 0.15);
        }
        .matching-item.matched:hover {
            transform: none;
        }
        .matching-item.matched::before {
            content: '✓';
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: bold;
            box-shadow: 0 2px 6px rgba(16, 185, 129, 0.4);
        }
        .matching-item.answer-revealed {
            border-color: #10b981;
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            cursor: default;
            box-shadow: 0 4px 10px rgba(16, 185, 129, 0.15);
        }
        .matching-item.answer-revealed:hover {
            transform: none;
        }
        #matching-svg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .matching-line {
            stroke: url(#lineGradient);
            stroke-width: 4;
            fill: none;
            stroke-linecap: round;
            opacity: 0;
            animation: draw-line 0.5s ease-out forwards;
            filter: drop-shadow(0 2px 4px rgba(236, 72, 153, 0.3));
        }
        @media (min-width: 768px) {
            .matching-line {
                stroke-width: 5;
            }
        }
        @keyframes draw-line {
            from {
                stroke-dasharray: 1000;
                stroke-dashoffset: 1000;
                opacity: 0;
            }
            to {
                stroke-dasharray: 1000;
                stroke-dashoffset: 0;
                opacity: 1;
            }
        }
        .matching-line.correct {
            stroke: url(#lineGradientCorrect);
            filter: drop-shadow(0 2px 4px rgba(16, 185, 129, 0.3));
        }
        .matching-line.incorrect {
            stroke: url(#lineGradientIncorrect);
            filter: drop-shadow(0 2px 4px rgba(239, 68, 68, 0.3));
        }

        /* Confetti Container for Quick Answer Success */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }
    </style>
    
    <!-- Canvas Confetti Library for Celebration Effects -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.4/dist/confetti.browser.min.js"></script>
</head>
<body class="flex items-center justify-center min-h-screen">

    <div id="app-container" class="w-full max-w-4xl mx-auto p-4 md:p-6">

        <div id="entry-view" class="w-full h-screen flex flex-col items-center justify-center p-4">
            <!-- 建置說明按鈕 -->
            <div class="absolute top-2 right-2 sm:top-4 sm:right-4 z-10">
                <a href="https://filedn.com/laMtL9jmKf7JrDEQG0A6OPy/html/%E5%89%9B%E5%A5%BD%E5%AD%B8%E6%9C%80%E6%96%B0%E7%89%88-%E5%BB%BA%E7%BD%AE%E6%89%8B%E5%86%8A/%E5%89%9B%E5%A5%BD%E5%AD%B8%E6%95%99%E5%B8%AB%E4%BD%BF%E7%94%A8%E5%BB%BA%E7%BD%AE%E6%89%8B%E5%86%8ANew.html" target="_blank" rel="noopener noreferrer" 
                   class="inline-flex items-center px-3 py-2 sm:px-4 bg-indigo-600 hover:bg-indigo-700 text-white text-xs sm:text-sm font-medium rounded-lg shadow-md transition-all duration-200 hover:shadow-lg">
                    <i class="fas fa-play-circle mr-0 sm:mr-2"></i>
                    <span class="hidden sm:inline ml-2">建置操作手冊</span>
                </a>
            </div>
            
            <div class="w-full max-w-3xl bg-white/80 backdrop-blur-sm p-5 sm:p-8 md:p-12 rounded-2xl shadow-xl text-center border border-gray-200">
        
                <div class="flex flex-col md:flex-row items-center justify-center mb-4 sm:mb-6">
                    <i class="fas fa-rocket text-4xl sm:text-5xl text-indigo-500 mb-3 md:mb-0 md:mr-6"></i>
                    <div>
                        <h1 class="text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold text-gray-800 leading-tight">剛好學：課堂互動so easy</h1>
                        <p class="text-base sm:text-lg text-gray-600 mt-1 sm:mt-2">一個專為現代課堂設計的即時互動工具</p>
                    </div>
                </div>
                
                <hr class="my-6 sm:my-8 border-gray-200">
        
                <p class="text-lg sm:text-xl font-medium text-gray-700 mb-4 sm:mb-6">請選擇您的角色以開始</p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-5 sm:gap-6 md:gap-8">
                    <div class="role-card group">
                        <div class="role-card-icon bg-blue-100 text-blue-500 group-hover:bg-blue-500 group-hover:text-white">
                            <i class="fas fa-chalkboard-teacher"></i>
                        </div>
                        <h2 class="text-xl sm:text-2xl font-bold text-gray-800 mt-3 sm:mt-4">我是教師</h2>
                        <p class="text-sm sm:text-base text-gray-500 my-2 min-h-[3rem] sm:h-12">建立教室，發起互動，即時查看學生反饋。</p>
                        <button id="teacher-entry-btn" class="btn btn-primary !w-full text-sm sm:text-base">建立或進入教室</button>
                    </div>
                    <div class="role-card group">
                         <div class="role-card-icon bg-green-100 text-green-500 group-hover:bg-green-500 group-hover:text-white">
                            <i class="fas fa-user-graduate"></i>
                         </div>
                         <h2 class="text-xl sm:text-2xl font-bold text-gray-800 mt-3 sm:mt-4">我是學生</h2>
                         <p class="text-sm sm:text-base text-gray-500 my-2 min-h-[3rem] sm:h-12">輸入教室代碼，參與課堂問答與互動。</p>
                        <button id="student-entry-btn" class="btn btn-green !w-full text-sm sm:text-base">加入課堂</button>
                    </div>
                </div>
            </div>
        
            <div class="text-center mt-6 text-gray-600">
                <p class="text-xs">App ID: <span id="app-id-display"></span> &nbsp;&bull;&nbsp; User ID: <span id="user-id-display"></span></p>
                <div class="mt-2">
                    <a href="https://kentxchang.blogspot.tw" target="_blank" rel="noopener noreferrer" class="made-by-text !bg-white/50 !text-indigo-600 hover:!bg-white">
                       Made by 阿剛老師V2.5
                    </a>
                </div>
            </div>
        </div>

        <div id="teacher-classroom-code-view" class="hidden text-center">
            <h2 class="text-3xl font-bold text-gray-800 mb-6">教師登入：請輸入教室代碼</h2>
            <div class="max-w-sm mx-auto">
                <input type="text" id="teacher-classroom-code-input" placeholder="請輸入自訂教室代碼" class="w-full px-4 py-3 border border-gray-300 rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="teacher-classroom-code-submit-btn" class="btn btn-primary mt-4">進入教師面板 ➡️</button>
                <button id="teacher-classroom-code-back-btn" class="btn btn-gray mt-2">返回 ↩️</button>
            </div>
        </div>

        <div id="teacher-menu-view" class="hidden text-center relative px-2 sm:px-4 pt-32 sm:pt-0">
            <h2 class="text-xl sm:text-2xl md:text-3xl font-bold text-gray-800 mb-4 sm:mb-8">教師面板：請選擇互動模式</h2>
            
            <!-- 頂部控制區：手機版堆疊，桌面版左右分佈 -->
            <div class="absolute top-2 left-2 right-2 z-10 sm:static sm:mb-4 flex flex-col sm:flex-row justify-between items-center gap-2 sm:gap-4">
                <!-- 左側區域：下課按鈕 + 教室代碼 -->
                <div class="flex flex-col sm:flex-row items-center gap-2 sm:gap-3 w-full sm:w-auto">
                    <button id="end-class-session-menu-btn" class="btn btn-red w-full sm:!w-auto text-xs sm:text-base h-9 sm:h-11 px-2 sm:px-4 py-1 sm:py-2 flex items-center justify-center" title="下課並清空資料">
                        <i class="fas fa-door-open mr-1 sm:mr-2"></i> <span class="text-xs sm:text-base">下課 🔚</span>
                    </button>
                    <div id="teacher-menu-classroom-code-display" class="text-center sm:text-left text-base sm:text-xl md:text-2xl lg:text-3xl font-bold text-gray-800 bg-yellow-100 px-3 sm:px-4 py-1 sm:py-2 rounded-lg border-2 border-yellow-400 shadow-sm w-full sm:w-auto">
                        教室代碼: <span id="teacher-menu-code-value" class="text-blue-600">---</span>
                    </div>
                </div>
                
                <!-- 右側區域：學生統計 -->
                <div class="flex items-center gap-1 sm:gap-2 p-1 sm:p-2 rounded-md bg-white shadow-sm w-full sm:w-auto justify-center">
                    <div id="student-status-area" class="text-gray-600 text-xs sm:text-base md:text-lg cursor-pointer flex items-center justify-center hover:bg-gray-200 transition-colors px-1">
                        <span class="hidden sm:inline">目前有 </span><span id="active-student-count" class="font-bold text-blue-700 mx-1">0</span> <span class="hidden sm:inline">位</span>學生<span class="hidden sm:inline">在線</span>
                    </div>
                    <button id="refresh-student-count-btn" class="text-gray-500 hover:text-blue-700 transition-colors text-sm sm:text-base" title="更新統計">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                </div>
            </div>

            <div class="grid grid-cols-2 sm:grid-cols-3 gap-2 sm:gap-3 md:gap-4 mx-auto max-w-2xl">
                <button data-mode="true_false" class="btn btn-primary aspect-square w-full flex flex-col items-center justify-center p-1">
                    <span class="text-sm sm:text-base md:text-lg opacity-60 mb-1">A.</span>
                    <span class="text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold leading-tight">是非題</span>
                </button>
                <button id="choice-sequencing-matching-menu-btn" class="btn btn-green aspect-square w-full flex flex-col items-center justify-center p-1">
                    <span class="text-sm sm:text-base md:text-lg opacity-60 mb-1">B.</span>
                    <span class="text-xl sm:text-2xl md:text-3xl lg:text-4xl font-bold leading-tight">選擇/排序<br class="hidden sm:inline">/配對</span>
                </button>
                <button data-mode="text_input" class="btn btn-orange aspect-square w-full flex flex-col items-center justify-center p-1">
                    <span class="text-sm sm:text-base md:text-lg opacity-60 mb-1">C.</span>
                    <span class="text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold leading-tight">文字題</span>
                </button>
                <button data-mode="drawing" class="btn btn-purple aspect-square w-full flex flex-col items-center justify-center p-1">
                    <span class="text-sm sm:text-base md:text-lg opacity-60 mb-1">D.</span>
                    <span class="text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold leading-tight">繪圖題</span>
                </button>
                <button data-mode="url_dispatch" class="btn btn-teal aspect-square w-full flex flex-col items-center justify-center p-1">
                    <span class="text-sm sm:text-base md:text-lg opacity-60 mb-1">E.</span>
                    <span class="text-lg sm:text-xl md:text-2xl lg:text-3xl font-bold leading-tight">派送網址<br class="hidden sm:inline">/HTML</span>
                </button>
                <button data-mode="recording" class="btn bg-indigo-600 hover:bg-indigo-700 aspect-square w-full flex flex-col items-center justify-center p-1">
                    <span class="text-sm sm:text-base md:text-lg opacity-60 mb-1">F.</span>
                    <span class="text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold leading-tight">錄音題</span>
                </button>
                <button id="reading-comprehension-settings-btn" class="btn bg-red-500 hover:bg-red-600 aspect-square w-full flex flex-col items-center justify-center p-1">
                    <span class="text-sm sm:text-base md:text-lg opacity-60 mb-1">G.</span>
                    <span class="text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold leading-tight">閱讀測驗</span>
                </button>
                <button data-mode="quick_answer" class="btn bg-orange-500 hover:bg-orange-600 aspect-square w-full flex flex-col items-center justify-center p-1">
                    <span class="text-sm sm:text-base md:text-lg opacity-60 mb-1">H.</span>
                    <span class="text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold leading-tight">搶答</span>
                </button>
                <button id="quick-poll-settings-btn" class="btn bg-lime-500 hover:bg-lime-600 aspect-square w-full flex flex-col items-center justify-center p-1">
                    <span class="text-sm sm:text-base md:text-lg opacity-60 mb-1">I.</span>
                    <span class="text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold leading-tight">快速投票</span>
                </button>
            </div>
            <div class="mt-6 sm:mt-8 flex flex-col items-center px-2">
                <div class="flex flex-col sm:flex-row gap-2 sm:gap-4 mb-4 w-full sm:w-auto">
                    <label for="teacher-image-upload-input" class="btn btn-purple !w-full sm:!w-auto text-xs sm:text-base h-9 sm:h-11 px-2 sm:px-4 py-1 sm:py-2 flex items-center justify-center cursor-pointer">
                        <i class="fas fa-upload mr-1 sm:mr-2"></i> <span class="hidden xs:inline">上傳繪圖背景圖片 (教師用) 🖼️</span><span class="xs:hidden">上傳背景 🖼️</span>
                    </label>
                    <input type="file" id="teacher-image-upload-input" accept="image/*" class="hidden">
                    <button id="clear-teacher-background-btn" class="btn btn-red !w-full sm:!w-auto text-xs sm:text-base h-9 sm:h-11 px-2 sm:px-4 py-1 sm:py-2 flex items-center justify-center">
                        <i class="fas fa-trash mr-1 sm:mr-2"></i> <span class="hidden xs:inline">清除背景圖 🗑️</span><span class="xs:hidden">清除 🗑️</span>
                    </button>
                </div>
                <p id="teacher-image-status" class="text-gray-600 text-xs sm:text-sm mt-2 text-center">目前沒有背景圖片。可選擇檔案或直接貼上(Ctrl+V)。</p>
                <div id="teacher-image-preview-container" class="mt-4 hidden border border-gray-300 rounded-lg p-2 max-w-xs w-full">
                    <img id="teacher-image-preview" src="" alt="背景圖片預覽" class="w-full h-auto rounded-md object-contain">
                </div>
            </div>

            <div class="mt-6 flex justify-center gap-4 sm:gap-8 pb-4">
                <button id="ai-settings-btn" class="text-gray-500 hover:text-blue-700 transition-colors text-2xl sm:text-3xl" title="AI 設定">
                    <i class="fas fa-robot"></i>
                </button>
                <button id="url-dispatch-settings-btn" class="text-gray-500 hover:text-teal-700 transition-colors text-2xl sm:text-3xl" title="設定派送網址/HTML">
                    <i class="fas fa-link"></i>
                </button>
            </div>
        </div>
        
        <div id="teacher-monitor-view" class="hidden px-2 sm:px-4">
            <div class="flex flex-col gap-3 mb-6">
                <!-- 第一行：下課按鈕 + 教室代碼 -->
                <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-2 sm:gap-4">
                    <button id="end-class-session-monitor-btn" class="btn bg-red-700 hover:bg-red-800 w-full sm:!w-auto text-base sm:text-lg md:text-xl font-semibold h-12 sm:h-13 md:h-14 px-4 sm:px-5 md:px-6 py-2 flex items-center justify-center shadow-lg border-2 border-red-900" title="下課並清空資料">
                        <i class="fas fa-exclamation-triangle mr-2 text-lg sm:text-xl"></i> <span id="end-class-monitor-button-text">⚠️ 下課結束課程</span>
                    </button>
                    <h2 class="text-base sm:text-2xl md:text-3xl font-bold text-gray-800 text-center sm:text-left"></h2>
                </div>
                
                <!-- 第二行：功能按鈕區（Bento Box 響應式網格） -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                    <button id="toggle-pause-btn" class="btn bg-gray-500 hover:bg-gray-600 text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3">
                        <i class="fas fa-pause mr-1 sm:mr-2"></i> <span id="toggle-pause-btn-text">暫停回覆 ⏸️</span>
                    </button>
                    <button id="reset-answers-btn" class="btn btn-green text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3">
                        <i class="fas fa-redo mr-1 sm:mr-2"></i> <span>重新開始 🔄</span>
                    </button>
                    <button id="draw-lottery-btn" class="btn btn-orange text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3">抽籤 🎲</button>
                    <button id="show-unsubmitted-students-btn" class="btn btn-orange text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3 hidden">未作答學生 📝</button>
                    <button id="ai-text-summary-btn" class="btn btn-purple text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3 hidden">AI 文字分析 🤖</button>
                    <button id="download-media-btn" class="btn btn-purple text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3 hidden">下載所有媒體 💾</button>
                    <button id="show-statistics-btn" class="btn btn-primary text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3 hidden">顯示統計 📊</button>
                    <button id="start-peer-review-btn" class="btn btn-teal text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3 hidden">開始互評 ❤️</button>
                    <button id="view-questions-btn" class="btn bg-indigo-600 hover:bg-indigo-700 text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3 hidden">查看題目 📝</button>
                    <button id="view-reading-questions-btn" class="btn bg-red-600 hover:bg-red-700 text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3 hidden">顯示題目 📖</button>
                    <button id="show-matching-answer-btn" class="btn bg-pink-600 hover:bg-pink-700 text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3 hidden">顯示答案 💡</button>
                    <button id="show-sequencing-answer-btn" class="btn bg-cyan-600 hover:bg-cyan-700 text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3 hidden">顯示答案 💡</button>
                    <button id="download-responses-btn" class="btn btn-green text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3 hidden">下載回應 📥</button>
                    <button id="end-interaction-btn" class="btn btn-primary text-sm sm:text-base md:text-lg h-10 sm:h-11 md:h-12 px-3 sm:px-2 md:px-3 font-bold shadow-md md:col-span-2 lg:col-span-3">✅ 結束互動，回到選單</button>
                </div>
            </div>
            <!-- 🚀 NEW: Teacher-side answer display area -->
            <div id="teacher-answer-display" class="hidden bg-blue-50 p-4 rounded-lg mb-4 border-2 border-blue-300">
                <h3 class="text-xl font-bold text-blue-800 mb-3 flex items-center">
                    <i class="fas fa-check-circle mr-2"></i>
                    <span id="teacher-answer-title">正確答案</span>
                </h3>
                <div id="teacher-answer-content" class="text-gray-800"></div>
            </div>
            
            <div id="student-responses-container" class="bg-gray-100 p-4 rounded-lg h-96 overflow-y-auto grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                <p class="text-gray-500 text-center col-span-full">正在等待學生作答...</p>
            </div>
            
            <div id="peer-review-stats-container" class="hidden mt-6">
                <div class="bg-white p-4 rounded-lg border">
                    <h3 class="text-xl font-bold text-gray-800 mb-4 text-center">📊 即時投票統計</h3>
                    <div id="peer-review-stats-grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                        <p class="text-gray-500 text-center col-span-full">尚未開始互評...</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="student-name-view" class="text-center hidden">
            <h2 class="text-3xl font-bold text-gray-800 mb-6">請輸入教室代碼與您的姓名</h2>
            <div class="max-w-sm mx-auto space-y-4">
                <input type="text" id="student-classroom-code-input" placeholder="請輸入教室代碼" class="w-full px-4 py-3 border border-gray-300 rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <input type="text" id="student-name-input" placeholder="例如：王小明" class="w-full px-4 py-3 border border-gray-300 rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="submit-name-btn" class="btn btn-primary mt-4">進入教室 🚪</button>
            </div>
        </div>
        
        <div id="student-waiting-view" class="text-center hidden">
             <h2 id="student-welcome-msg" class="text-3xl font-bold text-gray-800 mb-6"></h2>
             <div class="flex items-center justify-center space-x-3 text-xl text-gray-600">
                <i class="fas fa-spinner fa-spin"></i>
                <p>請等待老師開始互動...</p>
            </div>
        </div>
        
        <div id="student-interaction-view" class="hidden relative">
            <div id="student-pause-overlay" class="pause-overlay hidden">
                <p>老師已暫停回覆</p>
                <i class="fas fa-hand-paper"></i>
            </div>

            <div id="interaction-true-false" class="hidden">
                <h3 class="text-2xl font-bold text-center mb-6">是非題</h3>
                <div class="flex justify-center gap-4">
                    <button data-answer="O" class="answer-btn text-6xl w-32 h-32 rounded-full bg-green-500 text-white flex items-center justify-center shadow-lg transform hover:scale-110 transition">O</button>
                    <button data-answer="X" class="answer-btn text-6xl w-32 h-32 rounded-full bg-red-500 text-white flex items-center justify-center shadow-lg transform hover:scale-110 transition">X</button>
                </div>
            </div>
            <div id="interaction-multiple-choice" class="hidden flex flex-col items-center px-4">
                <h3 class="text-2xl font-bold text-center mb-4 sm:mb-6">選擇題</h3>
                <div id="default-mc-options" class="grid grid-cols-2 gap-3 sm:gap-4 md:gap-5 w-full max-w-md sm:max-w-lg md:max-w-xl">
                     <button data-answer="1" class="answer-btn btn bg-blue-500 hover:bg-blue-600 h-20 sm:h-24 md:h-28 text-5xl sm:text-6xl md:text-7xl">1</button>
                     <button data-answer="2" class="answer-btn btn bg-yellow-500 hover:bg-yellow-600 h-20 sm:h-24 md:h-28 text-5xl sm:text-6xl md:text-7xl">2</button>
                     <button data-answer="3" class="answer-btn btn bg-green-500 hover:bg-green-600 h-20 sm:h-24 md:h-28 text-5xl sm:text-6xl md:text-7xl">3</button>
                     <button data-answer="4" class="answer-btn btn bg-red-500 hover:bg-red-600 h-20 sm:h-24 md:h-28 text-5xl sm:text-6xl md:text-7xl">4</button>
                </div>
                <div id="custom-mc-questions-container" class="hidden w-full max-w-2xl space-y-6 text-left">
                    </div>
                <button id="submit-custom-mc-btn" class="btn btn-primary mt-6 hidden max-w-sm mx-auto">送出全部答案 ✉️</button>
            </div>
            <div id="interaction-text-input" class="hidden text-center">
                 <h3 class="text-2xl font-bold text-center mb-6">文字題</h3>
                 <textarea id="text-input-area" rows="6" class="w-full p-3 border rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="請在此輸入您的回答..."></textarea>
                 <button id="submit-text-btn" class="btn btn-primary mt-4 max-w-sm mx-auto">送出回答 ✉️</button>
            </div>
            <div id="interaction-drawing" class="hidden text-center flex flex-col h-full min-h-screen">
                <h3 class="text-2xl font-bold text-center mb-4">繪圖題</h3>
                <div class="flex flex-wrap justify-center md:justify-start items-center gap-4 mb-4 p-2 bg-gray-50 rounded-lg shadow-sm flex-shrink-0">
                    <button id="pen-tool-btn" class="p-2 rounded-lg border-2 border-blue-500 transition-all duration-150 ease-in-out h-11 flex items-center" title="畫筆">
                        <i class="fas fa-paint-brush mr-1"></i> 畫筆 ✏️
                    </button>
                    <div class="flex items-center gap-2">
                        <label class="text-gray-700 font-medium flex items-center" for="color-select">
                            <span id="current-color-swatch" class="color-swatch mr-2 bg-black"></span> 顏色:
                        </label>
                        <select id="color-select" class="drawing-tool-select">
                            <option value="black" style="background-color: black; color: white;">黑色</option>
                            <option value="red" style="background-color: red; color: white;">紅色</option>
                            <option value="blue" style="background-color: blue; color: white;">藍色</option>
                            <option value="green" style="background-color: green; color: white;">綠色</option>
                            <option value="yellow" style="background-color: yellow; color: black;">黃色</option>
                        </select>
                    </div>
                    <div class="flex items-center gap-2">
                        <label class="text-gray-700 font-medium" for="size-select">粗細:</label>
                        <select id="size-select" class="drawing-tool-select">
                            <option value="2">細</option>
                            <option value="5">中</option>
                            <option value="10">粗</option>
                        </select>
                    </div>
                    <div class="flex items-center gap-2">
                        <button id="eraser-btn" class="p-2 rounded-lg border-2 border-transparent hover:bg-gray-200 transition-all duration-150 ease-in-out h-11" title="橡皮擦"><i class="fas fa-eraser mr-1"></i> 橡皮擦 🧼</button>
                        <button id="clear-canvas-btn" class="p-2 rounded-lg border-2 border-transparent hover:bg-gray-200 transition-all duration-150 ease-in-out h-11" title="清除畫布"><i class="fas fa-trash mr-1"></i> 清除 🧹</button>
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="student-image-upload-input" class="btn btn-purple !w-auto text-base h-11 px-4 py-2 flex items-center justify-center cursor-pointer">
                            <i class="fas fa-upload mr-2"></i> 上傳圖片 🖼️
                        </label>
                        <input type="file" id="student-image-upload-input" accept="image/*" class="hidden">
                        <button id="clear-student-image-btn" class="btn btn-red !w-auto text-base h-11 px-4 py-2 flex items-center justify-center">
                            <i class="fas fa-trash mr-2"></i> 清除圖片 🗑️
                        </button>
                    </div>
                    <div class="flex items-center gap-2 mt-2 md:mt-0 ml-auto">
                        <button id="submit-drawing-btn" class="btn btn-primary !w-auto text-base h-11 px-4 py-2 flex items-center justify-center">送出 🚀</button> </div>
                </div>
                <canvas id="drawing-canvas"></canvas>
            </div>
            <div id="interaction-url-dispatch" class="hidden">
                </div>
            <div id="interaction-recording" class="hidden text-center flex flex-col items-center justify-center h-full min-h-screen p-4">
                <h3 class="text-2xl font-bold text-center mb-6">錄音題</h3>
                <div class="flex items-center justify-center space-x-3 text-xl text-gray-600 mb-6">
                    <i id="recording-status-icon" class="fas fa-microphone-alt text-gray-400"></i>
                    <p id="recording-status-text">準備錄音...</p>
                </div>
                <div class="flex flex-wrap justify-center gap-4 mb-6">
                    <button id="start-recording-btn" class="btn btn-green !w-40 !h-16 flex items-center justify-center text-lg">
                        <i class="fas fa-play mr-2"></i> 開始錄音 ▶️
                    </button>
                    <button id="stop-recording-btn" class="btn btn-red !w-40 !h-16 flex items-center justify-center text-lg" disabled>
                        <i class="fas fa-stop mr-2"></i> 停止錄音 ⏹️
                    </button>
                    <button id="play-recording-btn" class="btn btn-primary !w-40 !h-16 flex items-center justify-center text-lg" disabled>
                        <i class="fas fa-volume-up mr-2"></i> 試聽 🔊
                    </button>
                    <button id="reset-recording-btn" class="btn btn-orange !w-40 !h-10 flex items-center justify-center text-lg" disabled>
                        <i class="fas fa-redo mr-2"></i> 重錄 🔄
                    </button>
                </div>
                <audio id="audio-preview" controls class="w-full max-w-md mb-6 hidden"></audio>
                <button id="submit-recording-btn" class="btn btn-primary mt-4 max-w-sm mx-auto" disabled>
                    <i class="fas fa-paper-plane mr-2"></i> 送出錄音 ✉️
                </button>
            </div>
            <div id="interaction-reading-comprehension" class="hidden text-center p-4">
                <h3 class="text-2xl font-bold text-center mb-4">閱讀測驗</h3>

                <!-- 前十名排行榜 -->
                <div id="reading-leaderboard" class="max-w-6xl mx-auto mb-4 hidden">
                    <div class="bg-gradient-to-r from-yellow-50 via-white to-yellow-50 border-2 border-yellow-300 rounded-lg p-3 sm:p-4 shadow-md">
                        <h4 class="text-base sm:text-lg font-bold text-yellow-700 mb-3 flex items-center justify-center">
                            <i class="fas fa-trophy mr-2"></i>前十名排行榜 🏆
                        </h4>
                        <div id="reading-leaderboard-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 lg:grid-cols-5 gap-2 sm:gap-3">
                            <!-- 排行榜將動態生成在這裡 -->
                        </div>
                    </div>
                </div>

                <!-- 閱讀文本顯示 -->
                <div class="max-w-4xl mx-auto mb-6">
                    <div id="reading-text-display" class="bg-gray-50 p-6 rounded-lg border text-left text-base leading-relaxed whitespace-pre-wrap"></div>
                </div>

                <!-- 題目顯示 -->
                <div id="reading-questions-container" class="max-w-4xl mx-auto space-y-6">
                    <!-- 題目將動態生成在這裡 -->
                </div>

                <button id="submit-reading-btn" class="btn btn-primary mt-6 max-w-sm mx-auto">送出答案 ✉️</button>
            </div>
            <div id="interaction-quick-answer" class="hidden text-center flex flex-col items-center justify-center h-full min-h-screen p-4 relative">
                <h3 class="text-2xl md:text-3xl font-bold text-center mb-4 md:mb-6">搶答題</h3>
                <p id="quick-answer-status-text" class="text-base md:text-lg text-gray-600 mb-4 md:mb-6">等待搶答開始...</p>
                <div id="quick-answer-button-container" class="absolute inset-0 pointer-events-none">
                    <!-- 搶答按鈕將會動態生成在這裡 -->
                </div>
                <div id="quick-answer-result" class="hidden relative z-10">
                    <div id="confetti-container" class="confetti-container"></div>
                    <h2 class="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-bold text-green-600 mb-3 md:mb-4 animate-bounce">🎉 搶答成功！</h2>
                    <p class="text-lg sm:text-xl md:text-2xl text-gray-700 font-medium px-4">你是第一個點到按鈕的學生！</p>
                </div>
                <div id="quick-answer-locked" class="hidden">
                    <h2 class="text-3xl sm:text-4xl md:text-5xl font-bold text-red-600 mb-3 md:mb-4">⏰ 搶答結束</h2>
                    <p class="text-lg sm:text-xl md:text-2xl text-gray-700 px-4">其他同學已經搶答成功了！</p>
                </div>
            </div>
            <div id="interaction-sequencing" class="hidden text-center">
                <h3 class="text-2xl font-bold text-center mb-2">排序題</h3>
                <p id="sequencing-question-text" class="text-lg text-gray-700 mb-6"></p>
                <div class="sequencing-container">
                    <div id="sequencing-items-container" class="mb-6">
                        <!-- 排序項目將動態生成在這裡 -->
                    </div>
                    <button id="submit-sequencing-btn" class="btn btn-primary max-w-sm mx-auto">送出答案 ✉️</button>
                </div>
            </div>
            <div id="interaction-matching" class="hidden text-center">
                <h3 class="text-2xl font-bold text-center mb-2">配對題</h3>
                <p id="matching-question-text" class="text-lg text-gray-700 mb-6"></p>
                <div class="matching-container">
                    <svg id="matching-svg-canvas"></svg>
                    <div class="matching-column" id="matching-column-a" style="z-index: 2;">
                        <!-- A項目列表 -->
                    </div>
                    <div class="matching-column" id="matching-column-b" style="z-index: 2;">
                        <!-- B項目列表 -->
                    </div>
                </div>
                <button id="submit-matching-btn" class="btn btn-primary max-w-sm mx-auto mt-6">送出答案 ✉️</button>
            </div>

            <div id="interaction-quick-poll" class="hidden text-center flex flex-col items-center justify-center h-full min-h-screen p-4">
                <h3 class="text-2xl font-bold text-center mb-4">快速投票</h3>
                <p id="quick-poll-question-display" class="text-xl text-gray-800 mb-8 font-medium px-4"></p>

                <!-- 投票選項容器 -->
                <div id="quick-poll-options-container" class="w-full max-w-2xl">
                    <!-- 選項按鈕將會動態生成在這裡 -->
                </div>

                <!-- 已投票狀態 -->
                <div id="quick-poll-voted-status" class="hidden mt-8">
                    <div class="bg-green-100 border-2 border-green-500 rounded-lg p-6">
                        <i class="fas fa-check-circle text-green-600 text-5xl mb-3"></i>
                        <h4 class="text-2xl font-bold text-green-700 mb-2">投票成功！</h4>
                        <p class="text-gray-700">感謝您的參與</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="student-peer-review-view" class="hidden">
            <div class="flex flex-col h-full min-h-screen">
                <div class="flex-shrink-0 mb-6">
                    <h2 class="text-3xl font-bold text-gray-800 text-center mb-4">作品觀摩與投票</h2>
                    <p class="text-lg text-gray-600 text-center mb-6">點擊愛心投票，再點擊可取消！最多可投 <span class="font-bold text-red-600">3</span> 個不同作品</p>
                    <div class="text-center mb-4">
                        <span class="inline-block bg-blue-100 text-blue-800 px-4 py-2 rounded-full text-sm font-medium">
                            已投票：<span id="current-vote-count">0</span> / 3
                        </span>
                    </div>
                </div>
                
                <div id="peer-review-works-container" class="flex-1 bg-gray-100 p-4 rounded-lg overflow-y-auto">
                    <div id="peer-review-works-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <p class="text-gray-500 text-center col-span-full">載入作品中...</p>
                    </div>
                </div>
                
                <div class="flex-shrink-0 mt-4 text-center">
                    <button id="exit-peer-review-btn" class="btn btn-gray !w-auto text-base h-11 px-6 py-2">
                        <i class="fas fa-arrow-left mr-2"></i> 返回等待
                    </button>
                </div>
            </div>
        </div>

    </div>

    <div id="message-box" class="fixed top-4 left-1/2 -translate-x-1/2 px-6 py-3 rounded-lg shadow-lg hidden z-50 transition-all duration-300 transform" role="alert">
        <p id="message-content"></p>
        <button id="close-message-btn" class="absolute top-1 right-2 text-white text-xl leading-none">×</button>
    </div>

    <div id="magnified-image-modal" class="magnified-image-modal hidden">
        <div class="magnified-image-modal-content">
            <button id="magnified-image-modal-close-btn" class="magnified-image-modal-close">×</button>
            <img id="magnified-image" src="" alt="放大繪圖">
        </div>
    </div>

    <div id="student-list-modal" class="magnified-image-modal hidden">
        <div id="student-list-modal-content" class="magnified-image-modal-content">
            <button id="student-list-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-2xl font-bold mb-4 text-gray-800">目前在線學生</h4>
            <button id="modal-draw-lottery-btn" class="btn btn-orange !w-auto text-sm mb-4">抽籤 🎲</button> <div id="modal-student-names">
                <p class="text-gray-500 text-sm">沒有學生在線</p>
            </div>
        </div>
    </div>

    <div id="statistics-modal" class="magnified-image-modal hidden">
        <div id="statistics-modal-content" class="magnified-image-modal-content">
            <button id="chart-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4 id="chart-title" class="text-2xl font-bold mb-4 text-gray-800">作答統計</h4>
            <svg id="chart-svg" width="550" height="400"></svg>
            <div id="students-by-answer-list-container" class="hidden">
                <h5 id="students-by-answer-list-title"></h5>
                <p id="students-by-answer-names" class="text-gray-700"></p> 
            </div>
            <div class="flex justify-center gap-4 mt-6">
                <button id="download-statistics-btn" class="btn btn-green !w-auto text-base h-11 px-6">
                    <i class="fas fa-download mr-2"></i>下載統計 (CSV)
                </button>
            </div>
        </div>
    </div>

    <div id="ai-summary-modal" class="magnified-image-modal hidden">
        <div id="ai-summary-modal-content">
            <button id="ai-summary-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4>AI 文字分析 - 熱門詞彙</h4>
            <div id="ai-loading-spinner" class="hidden">
                <p>文字分析中....</p>
            </div>
            <ul id="ai-summary-result-list">
                </ul>
        </div>
    </div>

    <div id="ai-settings-modal" class="magnified-image-modal hidden">
        <div id="ai-settings-modal-content" class="magnified-image-modal-content max-w-lg mx-auto p-4 sm:p-6">
            <button id="ai-settings-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-xl sm:text-2xl md:text-3xl font-bold text-gray-800 mb-4 sm:mb-6">AI 設定</h4>
            <div class="space-y-4 sm:space-y-6">
                <div>
                    <label for="ai-source-select" class="block text-sm sm:text-base md:text-lg font-medium text-gray-700 mb-2">AI 模型來源:</label>
                    <select id="ai-source-select" class="w-full px-3 py-3 sm:px-4 sm:py-4 text-base sm:text-lg md:text-xl font-semibold text-gray-800 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white cursor-pointer" style="appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='%23374151'%3E%3Cpath fill-rule='evenodd' d='M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z' clip-rule='evenodd'/%3E%3C/svg%3E&quot;); background-repeat: no-repeat; background-position: right 0.75rem center; background-size: 1.5em 1.5em;">
                        <option value="gemini-default" class="text-base sm:text-lg md:text-xl">使用目前 Gemini (不可使用)</option>
                        <option value="gemini-custom" selected class="text-base sm:text-lg md:text-xl">自訂 Gemini API Key</option>
                    </select>
                </div>
                <div id="gemini-api-key-group" class="hidden">
                    <label for="gemini-api-key-input" class="block text-sm sm:text-base md:text-lg font-medium text-gray-700 mb-2">Gemini API Key:</label>
                    <input type="password" id="gemini-api-key-input" placeholder="請貼上您的 Gemini API Key" class="w-full px-3 py-2 sm:px-4 sm:py-3 border border-gray-300 rounded-lg text-sm sm:text-base md:text-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
            <div class="settings-button-group mt-6 sm:mt-8">
                <button id="save-ai-settings-btn" class="btn btn-primary w-full sm:w-auto text-base sm:text-lg px-6 py-3">儲存設定 💾</button>
            </div>
        </div>
    </div>

    <div id="url-dispatch-settings-modal" class="magnified-image-modal hidden">
        <div id="url-dispatch-settings-modal-content" class="magnified-image-modal-content">
            <button id="url-dispatch-settings-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4>設定派送網址/HTML</h4>
            <div class="w-full space-y-4">
                <div class="flex items-center justify-center gap-6 mb-4">
                    <label class="inline-flex items-center">
                        <input type="radio" name="dispatchType" value="url" class="form-radio text-blue-600 h-5 w-5" checked>
                        <span class="ml-2 text-gray-700 font-medium">派送網址</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="dispatchType" value="html" class="form-radio text-blue-600 h-5 w-5">
                        <span class="ml-2 text-gray-700 font-medium">派送 HTML</span>
                    </label>
                </div>

                <div id="url-dispatch-section">
                    <div>
                        <label for="dispatch-url-input">網址:</label>
                        <input type="text" id="dispatch-url-input" placeholder="請貼上要派送的網址" class="w-full">
                    </div>
                    <div class="checkbox-container">
                        <input type="checkbox" id="is-youtube-checkbox">
                        <label for="is-youtube-checkbox">此連結為 YouTube 影片</label>
                    </div>
                </div>

                <div id="html-dispatch-section" class="hidden">
                    <div class="flex flex-col items-center">
                        <div class="flex gap-4 mb-4">
                            <label for="dispatch-html-upload-input" class="btn bg-yellow-600 !w-auto text-base h-11 px-4 py-2 flex items-center justify-center cursor-pointer">
                                <i class="fas fa-file-upload mr-2"></i> 上傳 HTML 檔案 ⬆️
                            </label>
                            <input type="file" id="dispatch-html-upload-input" accept=".html" class="hidden">
                            <button id="clear-dispatch-html-btn" class="btn btn-red !w-auto text-base h-11 px-4 py-2 flex items-center justify-center">
                                <i class="fas fa-trash mr-2"></i> 清除 HTML 🗑️
                            </button>
                        </div>
                        <p id="dispatch-html-status" class="text-gray-600 text-sm mt-2">目前沒有 HTML 檔案。</p>
                    </div>
                </div>
            </div>
            <div class="settings-button-group mt-6 w-full">
                <button id="clear-dispatch-settings-btn" class="btn btn-red">清除設定 🧹</button>
                <button id="save-dispatch-settings-btn" class="btn btn-primary">儲存設定 💾</button>
            </div>
        </div>
    </div>

    <div id="unsubmitted-students-modal" class="magnified-image-modal hidden">
        <div id="unsubmitted-students-modal-content" class="magnified-image-modal-content">
            <button id="unsubmitted-students-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-2xl font-bold mb-4 text-gray-800">未作答學生名單</h4>
            <div id="modal-unsubmitted-student-names">
                <p class="text-gray-500 text-sm">所有學生皆已作答或無學生在線</p>
            </div>
        </div>
    </div>

    <!-- 查看題目模態框 -->
    <div id="view-questions-modal" class="magnified-image-modal hidden">
        <div id="view-questions-modal-content" class="magnified-image-modal-content">
            <button id="view-questions-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-2xl font-bold mb-4 text-gray-800">查看題目與正確答案</h4>
            <div id="questions-display-container" class="w-full space-y-4 max-h-96 overflow-y-auto">
                <!-- 題目內容將動態填入 -->
            </div>
            <div class="flex justify-end gap-4 mt-6">
                <button id="save-correct-answers-btn" class="btn btn-green !w-auto px-6">儲存修改</button>
                <button id="cancel-questions-view-btn" class="btn bg-gray-500 hover:bg-gray-600 !w-auto px-6">取消</button>
            </div>
        </div>
    </div>

    <!-- 查看閱讀測驗題目模態框 -->
    <div id="view-reading-questions-modal" class="magnified-image-modal hidden">
        <div id="view-reading-questions-modal-content" class="magnified-image-modal-content" style="max-width: 900px;">
            <button id="view-reading-questions-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-2xl font-bold mb-4 text-gray-800">📖 閱讀測驗題目</h4>

            <!-- 閱讀文本顯示 -->
            <div class="mb-6">
                <h5 class="text-lg font-bold text-gray-700 mb-2">閱讀文本：</h5>
                <div id="view-reading-text-display" class="bg-gray-50 p-4 rounded-lg border text-base leading-relaxed whitespace-pre-wrap max-h-64 overflow-y-auto"></div>
            </div>

            <!-- 題目顯示 -->
            <div>
                <h5 class="text-lg font-bold text-gray-700 mb-2">題目：</h5>
                <div id="view-reading-questions-display" class="space-y-4 max-h-96 overflow-y-auto">
                    <!-- 題目內容將動態填入 -->
                </div>
            </div>

            <div class="flex justify-end gap-4 mt-6">
                <button id="close-reading-questions-view-btn" class="btn btn-primary !w-auto px-6">關閉</button>
            </div>
        </div>
    </div>

    <div id="multiple-choice-settings-modal" class="magnified-image-modal hidden">
        <div id="multiple-choice-settings-modal-content" class="magnified-image-modal-content">
            <button id="multiple-choice-settings-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-2xl font-bold mb-4 text-gray-800">選擇題設定</h4>
            <div class="w-full space-y-4">
                <div class="flex items-center justify-center gap-6 mb-4">
                    <label class="inline-flex items-center">
                        <input type="radio" name="mcQuestionType" value="none" class="form-radio text-blue-600 h-5 w-5" checked>
                        <span class="ml-2 text-gray-700 font-medium">無題目出題 (預設 1-4 選項)</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="mcQuestionType" value="custom" class="form-radio text-blue-600 h-5 w-5">
                        <span class="ml-2 text-gray-700 font-medium">自訂題目出題</span>
                    </label>
                </div>

                <div id="custom-mc-questions-section" class="hidden w-full">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">

                        <div class="flex flex-col space-y-2">
                            <label for="custom-mc-questions-textarea" class="block text-gray-700 text-sm font-bold">
                                請輸入題目 (或由 AI 生成)
                            </label>
                            <p class="text-gray-600 text-xs">格式: 題目,正確答案(1-4或A-D),選項1,選項2,選項3,選項4 (每行一題)</p>
                            <textarea id="custom-mc-questions-textarea" rows="6" class="w-full p-3 border rounded-lg text-base focus:outline-none focus:ring-2 focus:ring-blue-500 flex-grow" placeholder="例如：
台灣的首都在哪裡?,1,台北,台中,台南,高雄
2+2=?,B,3,4,5,6"></textarea>
                            <p id="custom-mc-questions-status" class="text-red-500 text-sm mt-2 hidden">格式錯誤或題目為空，請檢查輸入。</p>
                        </div>

                        <div class="flex flex-col space-y-4 bg-gray-50 p-4 rounded-lg border">
                            <h5 class="text-lg font-bold text-gray-800 text-center">🤖 AI 智能出題</h5>
                            <div>
                                <label for="ai-mc-topic-textarea" class="block text-gray-700 text-sm font-bold mb-2">出題主題、範圍或要求:</label>
                                <textarea id="ai-mc-topic-textarea" rows="3" class="w-full p-2 border rounded-md text-base focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="例如：
- 關於台灣歷史的選擇題
- 關於光合作用的國中程度是非題
- 請出有關聖誕節的英文單字選擇題"></textarea>
                            </div>
                            <div>
                                <label for="ai-mc-count-input" class="block text-gray-700 text-sm font-bold mb-2">出題數量 (1-10):</label>
                                <input type="number" id="ai-mc-count-input" min="1" max="10" value="5" class="w-full p-2 border rounded-md text-base focus:outline-none focus:ring-2 focus:ring-purple-500">
                            </div>
                            <div class="text-center">
                                <button id="ai-generate-mc-btn" class="btn btn-purple !w-auto text-base h-11 px-4 py-2 flex items-center justify-center mx-auto">
                                    <i id="ai-mc-btn-icon" class="fas fa-magic mr-2"></i>
                                    <span id="ai-mc-btn-text">AI 開始出題</span>
                                </button>
                            </div>
                            <div id="ai-mc-loading-spinner" class="hidden flex items-center justify-center text-purple-600 pt-2">
                                <i class="fas fa-spinner fa-spin mr-2"></i>
                                <span>AI 思考中，請稍候...</span>
                            </div>
                        </div>

                    </div>
                </div>

                <!-- 題庫管理區塊 -->
                <div id="question-bank-management-section" class="hidden w-full mt-6 bg-blue-50 p-4 rounded-lg border">
                    <h5 class="text-lg font-bold text-gray-800 text-center mb-4">📚 題庫管理</h5>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <!-- 題庫載入區 -->
                        <div class="flex flex-col space-y-2">
                            <label class="block text-gray-700 text-sm font-bold">從檔案載入題庫</label>
                            <input type="file" id="question-bank-file-input" accept=".txt" class="w-full p-2 border rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <button id="load-question-bank-btn" class="btn bg-blue-600 hover:bg-blue-700 text-white text-sm h-8 px-3 py-1">載入題庫</button>
                        </div>

                        <!-- 題庫儲存區 -->
                        <div class="flex flex-col space-y-2">
                            <label class="block text-gray-700 text-sm font-bold">儲存目前題目為題庫</label>
                            <input type="text" id="question-bank-name-input" placeholder="輸入題庫名稱" class="w-full p-2 border rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <button id="save-question-bank-btn" class="btn bg-green-600 hover:bg-green-700 text-white text-sm h-8 px-3 py-1">儲存題庫</button>
                        </div>
                    </div>

                    <!-- 題庫列表 -->
                    <div class="mt-4">
                        <label class="block text-gray-700 text-sm font-bold mb-2">已儲存的題庫</label>
                        <div id="question-bank-list" class="space-y-2 max-h-32 overflow-y-auto border rounded-md p-2 bg-white">
                            <div class="text-gray-500 text-sm italic text-center">目前沒有儲存的題庫</div>
                        </div>
                    </div>
                </div>

            </div>
            <div class="settings-button-group mt-6 w-full">
                <button id="start-mc-interaction-btn" class="btn btn-primary">確認並開始互動 🚀</button>
                <button id="cancel-mc-settings-btn" class="btn btn-gray">取消 ↩️</button>
            </div>
        </div>
    </div>

    <!-- B. 選擇/排序/配對題選單模態框 -->
    <div id="choice-sequencing-matching-menu-modal" class="magnified-image-modal hidden">
        <div class="magnified-image-modal-content" style="max-width: 400px;">
            <button id="choice-sequencing-matching-menu-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-2xl font-bold mb-6 text-gray-800 text-center">B. 請選擇題型</h4>
            <div class="space-y-4">
                <button id="open-multiple-choice-settings-btn" class="btn btn-green w-full text-xl py-4">✓ 選擇題</button>
                <button id="open-sequencing-settings-btn" class="btn bg-cyan-500 hover:bg-cyan-600 w-full text-xl py-4">📋 排序題</button>
                <button id="open-matching-settings-btn" class="btn bg-pink-500 hover:bg-pink-600 w-full text-xl py-4">🔗 配對題</button>
            </div>
        </div>
    </div>

    <!-- 排序/配對題選單模態框 -->
    <div id="sequencing-matching-menu-modal" class="magnified-image-modal hidden">
        <div class="magnified-image-modal-content" style="max-width: 400px;">
            <button id="sequencing-matching-menu-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-2xl font-bold mb-6 text-gray-800 text-center">請選擇題型</h4>
            <div class="space-y-4">
                <button id="sequencing-settings-btn" class="btn bg-cyan-500 hover:bg-cyan-600 w-full text-xl py-4">📋 排序題</button>
                <button id="matching-settings-btn" class="btn bg-pink-500 hover:bg-pink-600 w-full text-xl py-4">🔗 配對題</button>
            </div>
        </div>
    </div>

    <!-- 排序題設定模態框 -->
    <div id="sequencing-settings-modal" class="magnified-image-modal hidden">
        <div id="sequencing-settings-modal-content" class="magnified-image-modal-content">
            <button id="sequencing-settings-modal-close-btn" class="magnified-image-modal-close">×</button>
            <div class="w-full">
                <!-- 題型切換按鈕 -->
                <div class="flex justify-center mb-4 gap-2">
                    <button id="switch-to-matching-btn" class="btn bg-pink-500 hover:bg-pink-600 text-white px-6 py-2 text-sm">
                        🔗 切換到配對題
                    </button>
                </div>
                <h4 class="text-2xl font-bold mb-4 text-gray-800">排序題設定</h4>

                <!-- 上方：左右兩欄布局 -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-4">
                <!-- 左欄：題目輸入 -->
                <div class="bg-gray-50 p-4 rounded-lg border">
                    <label for="sequencing-items-textarea" class="block text-gray-700 text-sm font-bold mb-2">📝 排序項目（每行一個，按正確順序輸入）</label>
                    <textarea id="sequencing-items-textarea" rows="6" class="w-full p-3 border rounded-lg text-base focus:outline-none focus:ring-2 focus:ring-cyan-500" placeholder="例如：
打開檔案
編輯內容
儲存檔案
關閉檔案"></textarea>
                    <p class="text-gray-600 text-xs mt-1">💡 提示：請依照正確順序輸入項目，系統會自動打亂給學生作答</p>
                </div>

                <!-- 右欄：AI智能出題 -->
                <div class="bg-purple-50 p-4 rounded-lg border">
                    <h5 class="text-lg font-bold text-gray-800 mb-3">🤖 AI 智能出題</h5>
                    <div class="space-y-3">
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">出題主題或要求：</label>
                            <textarea id="ai-seq-topic-textarea" rows="2" class="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="例如：請生成光合作用的步驟排序"></textarea>
                        </div>
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">項目數量 (3-10):</label>
                            <input type="number" id="ai-seq-count-input" min="3" max="10" value="5" class="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500">
                        </div>
                        <div class="text-center">
                            <button id="ai-generate-seq-btn" class="btn btn-purple w-full text-base h-11 px-4 py-2 flex items-center justify-center">
                                <i id="ai-seq-btn-icon" class="fas fa-magic mr-2"></i>
                                <span id="ai-seq-btn-text">AI 開始出題</span>
                            </button>
                        </div>
                        <div id="ai-seq-loading-spinner" class="hidden flex items-center justify-center text-purple-600 pt-2">
                            <i class="fas fa-spinner fa-spin mr-2"></i>
                            <span>AI 思考中，請稍候...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 下方：題庫管理區塊（全寬） -->
            <div class="w-full bg-blue-50 p-4 rounded-lg border">
                <h5 class="text-lg font-bold text-gray-800 mb-3">📚 題庫管理</h5>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="flex flex-col space-y-2">
                        <label class="block text-gray-700 text-sm font-bold">從檔案載入題庫</label>
                        <input type="file" id="seq-bank-file-input" accept=".txt" class="w-full p-2 border rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="load-seq-bank-btn" class="btn bg-blue-600 hover:bg-blue-700 text-white text-sm h-8 px-3 py-1">載入題庫</button>
                    </div>
                    <div class="flex flex-col space-y-2">
                        <label class="block text-gray-700 text-sm font-bold">儲存目前題目為題庫</label>
                        <input type="text" id="seq-bank-name-input" placeholder="輸入題庫名稱" class="w-full p-2 border rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="save-seq-bank-btn" class="btn bg-green-600 hover:bg-green-700 text-white text-sm h-8 px-3 py-1">儲存題庫</button>
                    </div>
                </div>
                <div class="mt-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2">已儲存的題庫</label>
                    <div id="seq-bank-list" class="space-y-2 max-h-20 overflow-y-auto border rounded-md p-2 bg-white">
                        <div class="text-gray-500 text-sm italic text-center">目前沒有儲存的題庫</div>
                    </div>
                </div>
            </div>

                <div class="settings-button-group mt-4">
                    <button id="start-sequencing-interaction-btn" class="btn bg-cyan-500 hover:bg-cyan-600">確認並開始互動 🚀</button>
                    <button id="cancel-sequencing-settings-btn" class="btn btn-gray">取消 ↩️</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 配對題設定模態框 -->
    <div id="matching-settings-modal" class="magnified-image-modal hidden">
        <div id="matching-settings-modal-content" class="magnified-image-modal-content">
            <button id="matching-settings-modal-close-btn" class="magnified-image-modal-close">×</button>
            <div class="w-full">
                <!-- 題型切換按鈕 -->
                <div class="flex justify-center mb-4 gap-2">
                    <button id="switch-to-sequencing-btn" class="btn bg-cyan-500 hover:bg-cyan-600 text-white px-6 py-2 text-sm">
                        📋 切換到排序題
                    </button>
                </div>
                <h4 class="text-2xl font-bold mb-4 text-gray-800">配對題設定</h4>

                <!-- 上方：左右兩欄布局 -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-4">
                <!-- 左欄：題目輸入 -->
                <div class="bg-gray-50 p-4 rounded-lg border">
                    <label for="matching-pairs-textarea" class="block text-gray-700 text-sm font-bold mb-2">📝 配對項目（每行一對，用逗號或Tab分隔）</label>
                    <textarea id="matching-pairs-textarea" rows="6" class="w-full p-3 border rounded-lg text-base focus:outline-none focus:ring-2 focus:ring-pink-500" placeholder="例如：
台北,台灣首都
東京,日本首都
首爾,韓國首都
北京,中國首都"></textarea>
                    <p class="text-gray-600 text-xs mt-1">💡 提示：每行一對配對項目，用逗號（,）或Tab鍵分隔左右兩側</p>
                </div>

                <!-- 右欄：AI智能出題 -->
                <div class="bg-purple-50 p-4 rounded-lg border">
                    <h5 class="text-lg font-bold text-gray-800 mb-3">🤖 AI 智能出題</h5>
                    <div class="space-y-3">
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">出題主題或要求：</label>
                            <textarea id="ai-match-topic-textarea" rows="2" class="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="例如：國家與首都的配對"></textarea>
                        </div>
                        <div>
                            <label class="block text-gray-700 text-sm font-bold mb-2">配對數量 (3-10):</label>
                            <input type="number" id="ai-match-count-input" min="3" max="10" value="5" class="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-purple-500">
                        </div>
                        <div class="text-center">
                            <button id="ai-generate-match-btn" class="btn btn-purple w-full text-base h-11 px-4 py-2 flex items-center justify-center">
                                <i id="ai-match-btn-icon" class="fas fa-magic mr-2"></i>
                                <span id="ai-match-btn-text">AI 開始出題</span>
                            </button>
                        </div>
                        <div id="ai-match-loading-spinner" class="hidden flex items-center justify-center text-purple-600 pt-2">
                            <i class="fas fa-spinner fa-spin mr-2"></i>
                            <span>AI 思考中，請稍候...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 下方：題庫管理區塊（全寬） -->
            <div class="w-full bg-blue-50 p-4 rounded-lg border">
                <h5 class="text-lg font-bold text-gray-800 mb-3">📚 題庫管理</h5>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="flex flex-col space-y-2">
                        <label class="block text-gray-700 text-sm font-bold">從檔案載入題庫</label>
                        <input type="file" id="match-bank-file-input" accept=".txt" class="w-full p-2 border rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="load-match-bank-btn" class="btn bg-blue-600 hover:bg-blue-700 text-white text-sm h-8 px-3 py-1">載入題庫</button>
                    </div>
                    <div class="flex flex-col space-y-2">
                        <label class="block text-gray-700 text-sm font-bold">儲存目前題目為題庫</label>
                        <input type="text" id="match-bank-name-input" placeholder="輸入題庫名稱" class="w-full p-2 border rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="save-match-bank-btn" class="btn bg-green-600 hover:bg-green-700 text-white text-sm h-8 px-3 py-1">儲存題庫</button>
                    </div>
                </div>
                <div class="mt-4">
                    <label class="block text-gray-700 text-sm font-bold mb-2">已儲存的題庫</label>
                    <div id="match-bank-list" class="space-y-2 max-h-20 overflow-y-auto border rounded-md p-2 bg-white">
                        <div class="text-gray-500 text-sm italic text-center">目前沒有儲存的題庫</div>
                    </div>
                </div>
            </div>

                <div class="settings-button-group mt-4">
                    <button id="start-matching-interaction-btn" class="btn bg-pink-500 hover:bg-pink-600">確認並開始互動 🚀</button>
                    <button id="cancel-matching-settings-btn" class="btn btn-gray">取消 ↩️</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 教師密碼驗證模態框 -->
    <div id="teacher-password-modal" class="magnified-image-modal hidden">
        <div id="teacher-password-modal-content" class="magnified-image-modal-content">
            <button id="teacher-password-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-2xl font-bold mb-4 text-gray-800">教師登入驗證</h4>
            <div class="w-full space-y-4">
                <input type="password" id="teacher-password-input" placeholder="請輸入密碼" class="w-full px-4 py-3 border border-gray-300 rounded-lg text-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <div class="flex justify-center gap-4">
                    <button id="teacher-password-submit-btn" class="btn btn-primary px-8">確認</button>
                    <button id="teacher-password-cancel-btn" class="btn btn-gray px-8">取消</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 閱讀測驗設定模態框 -->
    <div id="reading-comprehension-settings-modal" class="magnified-image-modal hidden">
        <div id="reading-comprehension-settings-modal-content" class="magnified-image-modal-content" style="max-width: 900px;">
            <button id="reading-comprehension-settings-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-2xl font-bold mb-4 text-gray-800">閱讀測驗設定</h4>
            <div class="w-full space-y-4">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">

                    <!-- 左側：文本與題目輸入 -->
                    <div class="flex flex-col space-y-4">
                        <!-- 文本輸入框 -->
                        <div>
                            <label for="reading-text-textarea" class="block text-gray-700 text-sm font-bold mb-2">
                                閱讀文本：
                            </label>
                            <textarea id="reading-text-textarea" rows="8" class="w-full p-3 border rounded-lg text-base focus:outline-none focus:ring-2 focus:ring-red-500" placeholder="請輸入閱讀文本內容..."></textarea>
                        </div>

                        <!-- 題目輸入框 -->
                        <div>
                            <label for="reading-questions-textarea" class="block text-gray-700 text-sm font-bold mb-2">
                                題目設定：
                            </label>
                            <p class="text-gray-600 text-xs mb-2">格式: 題目,正確答案(1-4或A-D),選項1,選項2,選項3,選項4<span class="text-gray-500">,[層次(1-4)選填]</span><br>
                            <span class="text-gray-500">支援逗號(,)或Tab分隔，每行一題</span></p>
                            <textarea id="reading-questions-textarea" rows="8" class="w-full p-3 border rounded-lg text-base focus:outline-none focus:ring-2 focus:ring-red-500" placeholder="例如：
主角的名字是什麼?,2,小明,小華,小美,小強,1
本文的主旨是?,A,友誼的重要,競爭的意義,學習的價值,家庭的溫暖
故事發生的地點在哪裡?,3,學校,公園,圖書館,家裡"></textarea>
                            <p id="reading-questions-status" class="text-red-500 text-sm mt-2 hidden">格式錯誤或題目為空，請檢查輸入。</p>
                        </div>
                    </div>

                    <!-- 右側：AI生成與題庫管理 -->
                    <div class="flex flex-col space-y-4">
                        <!-- AI 生成區塊 -->
                        <div class="bg-purple-50 p-4 rounded-lg border flex-1">
                            <h5 class="text-lg font-bold text-gray-800 text-center mb-4">🤖 PIRLS AI 出題</h5>
                            <div class="space-y-3">
                                <div>
                                    <label for="ai-reading-topic-textarea" class="block text-gray-700 text-sm font-bold mb-2">出題要求：</label>
                                    <textarea id="ai-reading-topic-textarea" rows="3" class="w-full p-2 border rounded-md text-base focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="例如：
- 根據左方文本生成 PIRLS 閱讀理解題
- 或直接描述主題，AI 會生成文本+題目"></textarea>
                                </div>
                                <div class="text-sm text-gray-600 bg-white p-2 rounded border">
                                    <p class="font-bold mb-1">PIRLS 四層次配置：</p>
                                    <ul class="list-disc list-inside text-xs space-y-1">
                                        <li>層次1 (直接提取)：3題</li>
                                        <li>層次2 (直接推論)：3題</li>
                                        <li>層次3 (詮釋整合)：2題</li>
                                        <li>層次4 (比較評估)：2題</li>
                                    </ul>
                                </div>
                                <button id="ai-generate-reading-btn" class="btn btn-purple !w-full text-base h-11 px-4 py-2 flex items-center justify-center">
                                    <i id="ai-reading-btn-icon" class="fas fa-magic mr-2"></i>
                                    <span id="ai-reading-btn-text">AI 開始出題</span>
                                </button>
                                <div id="ai-reading-loading-spinner" class="hidden flex items-center justify-center text-purple-600 pt-2">
                                    <i class="fas fa-spinner fa-spin mr-2"></i>
                                    <span>AI 思考中，請稍候...</span>
                                </div>
                            </div>
                        </div>

                        <!-- 題庫管理區塊 -->
                        <div class="bg-blue-50 p-4 rounded-lg border">
                            <h5 class="text-lg font-bold text-gray-800 text-center mb-4">📚 題庫管理</h5>
                            <div class="space-y-3">
                                <!-- 載入題庫 -->
                                <div>
                                    <label class="block text-gray-700 text-sm font-bold mb-2">從檔案載入題庫</label>
                                    <div class="space-y-2">
                                        <div>
                                            <label class="block text-gray-600 text-xs mb-1">上傳文本 (.txt)</label>
                                            <input type="file" id="reading-text-file-input" accept=".txt" class="w-full p-1 border rounded-md text-xs focus:outline-none focus:ring-2 focus:ring-blue-500">
                                        </div>
                                        <div>
                                            <label class="block text-gray-600 text-xs mb-1">上傳題目 (.txt)</label>
                                            <input type="file" id="reading-questions-file-input" accept=".txt" class="w-full p-1 border rounded-md text-xs focus:outline-none focus:ring-2 focus:ring-blue-500">
                                        </div>
                                        <button id="load-reading-files-btn" class="btn bg-blue-600 hover:bg-blue-700 text-white text-sm h-8 px-3 py-1 w-full">載入檔案</button>
                                    </div>
                                </div>

                                <!-- 儲存題庫 -->
                                <div>
                                    <label class="block text-gray-700 text-sm font-bold mb-2">儲存目前題目為題庫</label>
                                    <input type="text" id="reading-question-bank-name-input" placeholder="輸入題庫名稱" class="w-full p-2 border rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 mb-2">
                                    <button id="save-reading-question-bank-btn" class="btn bg-green-600 hover:bg-green-700 text-white text-sm h-8 px-3 py-1 w-full">儲存題庫</button>
                                </div>

                                <!-- 題庫列表 -->
                                <div>
                                    <label class="block text-gray-700 text-sm font-bold mb-2">已儲存的題庫</label>
                                    <div id="reading-question-bank-list" class="space-y-2 max-h-32 overflow-y-auto border rounded-md p-2 bg-white">
                                        <div class="text-gray-500 text-sm italic text-center">目前沒有儲存的題庫</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
            <div class="settings-button-group mt-6 w-full">
                <button id="start-reading-interaction-btn" class="btn btn-primary">確認並開始互動 🚀</button>
                <button id="cancel-reading-settings-btn" class="btn btn-gray">取消 ↩️</button>
            </div>
        </div>
    </div>

    <!-- 快速投票設定模態框 -->
    <div id="quick-poll-settings-modal" class="magnified-image-modal hidden">
        <div id="quick-poll-settings-modal-content" class="magnified-image-modal-content" style="max-width: 600px;">
            <button id="quick-poll-settings-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-2xl font-bold mb-4 text-gray-800">快速投票設定</h4>
            <div class="w-full space-y-4">
                <!-- 投票類型選擇 -->
                <div>
                    <label class="block text-gray-700 text-sm font-bold mb-2">投票類型：</label>
                    <div class="space-y-2">
                        <label class="inline-flex items-center w-full p-3 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="radio" name="pollType" value="emoji" class="form-radio text-lime-600 h-5 w-5" checked>
                            <span class="ml-3 text-gray-700">心情符號（😊 😐 😕）</span>
                        </label>
                        <label class="inline-flex items-center w-full p-3 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="radio" name="pollType" value="simple" class="form-radio text-lime-600 h-5 w-5">
                            <span class="ml-3 text-gray-700">簡單選項（同意 / 不同意 / 不確定）</span>
                        </label>
                        <label class="inline-flex items-center w-full p-3 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="radio" name="pollType" value="rating5" class="form-radio text-lime-600 h-5 w-5">
                            <span class="ml-3 text-gray-700">數字等級（1-5 分）</span>
                        </label>
                        <label class="inline-flex items-center w-full p-3 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="radio" name="pollType" value="rating10" class="form-radio text-lime-600 h-5 w-5">
                            <span class="ml-3 text-gray-700">數字等級（1-10 分）</span>
                        </label>
                        <label class="inline-flex items-center w-full p-3 border rounded-lg cursor-pointer hover:bg-gray-50">
                            <input type="radio" name="pollType" value="custom" class="form-radio text-lime-600 h-5 w-5">
                            <span class="ml-3 text-gray-700">自訂選項</span>
                        </label>
                    </div>
                </div>

                <!-- 自訂選項輸入區 -->
                <div id="custom-poll-options-section" class="hidden">
                    <label for="custom-poll-options-input" class="block text-gray-700 text-sm font-bold mb-2">自訂選項（每行一個）：</label>
                    <textarea id="custom-poll-options-input" rows="4" class="w-full px-4 py-2 border border-gray-300 rounded-lg text-base focus:outline-none focus:ring-2 focus:ring-lime-500" placeholder="例如：
選項 A
選項 B
選項 C"></textarea>
                </div>

                <!-- 匿名設定 -->
                <div class="flex items-center">
                    <input type="checkbox" id="quick-poll-anonymous-checkbox" checked class="form-checkbox h-5 w-5 text-lime-600 rounded">
                    <label for="quick-poll-anonymous-checkbox" class="ml-2 text-gray-700 font-medium">匿名投票（不記錄學生姓名）</label>
                </div>
            </div>

            <div class="settings-button-group mt-6 w-full">
                <button id="start-quick-poll-btn" class="btn bg-lime-500 hover:bg-lime-600">開始投票 🚀</button>
                <button id="cancel-quick-poll-settings-btn" class="btn btn-gray">取消 ↩️</button>
            </div>
        </div>
    </div>

    <!-- 快速投票統計模態框 -->
    <div id="quick-poll-stats-modal" class="magnified-image-modal hidden">
        <div id="quick-poll-stats-modal-content" class="magnified-image-modal-content" style="max-width: 900px; max-height: 90vh;">
            <button id="quick-poll-stats-modal-close-btn" class="magnified-image-modal-close">×</button>
            <h4 class="text-2xl font-bold mb-4 text-gray-800 text-center">投票統計結果</h4>
            <p id="quick-poll-stats-question" class="text-lg text-gray-700 mb-4 text-center font-medium"></p>

            <!-- 上方區塊：左右兩欄布局 -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-4">
                <!-- 左欄：圖表類型切換和統計資訊 -->
                <div>
                    <!-- 圖表類型切換 -->
                    <div class="flex justify-center gap-4 mb-4">
                        <button id="chart-type-bar-btn" class="btn bg-blue-500 hover:bg-blue-600 !w-auto text-sm h-10 px-4">長條圖</button>
                        <button id="chart-type-pie-btn" class="btn btn-gray !w-auto text-sm h-10 px-4">圓餅圖</button>
                    </div>

                    <!-- 投票統計資訊 -->
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <div class="grid grid-cols-2 gap-4 text-center">
                            <div>
                                <p class="text-gray-600 text-sm">總投票數</p>
                                <p id="poll-total-votes" class="text-3xl font-bold text-lime-600">0</p>
                            </div>
                            <div>
                                <p class="text-gray-600 text-sm">在線學生數</p>
                                <p id="poll-online-students" class="text-3xl font-bold text-blue-600">0</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 右欄：詳細數據表格 -->
                <div class="overflow-x-auto">
                    <table class="w-full border-collapse">
                        <thead>
                            <tr class="bg-gray-100">
                                <th class="border px-4 py-2 text-left">選項</th>
                                <th class="border px-4 py-2 text-right">票數</th>
                                <th class="border px-4 py-2 text-right">百分比</th>
                            </tr>
                        </thead>
                        <tbody id="quick-poll-stats-table-body">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- D3.js 圖表容器 -->
            <div class="bg-white border rounded-lg p-4 overflow-x-auto" style="min-height: 500px;">
                <svg id="quick-poll-chart-svg" width="800" height="450"></svg>
            </div>

            <div class="flex justify-center gap-4 mt-6">
                <button id="download-poll-results-btn" class="btn btn-green !w-auto text-base h-11 px-6">
                    <i class="fas fa-download mr-2"></i>下載結果 (CSV)
                </button>
                <button id="end-quick-poll-btn" class="btn btn-red !w-auto text-base h-11 px-6">
                    <i class="fas fa-stop mr-2"></i>結束投票
                </button>
            </div>
        </div>
    </div>

    <!-- Firebase 設定檔 -->
    <script>
        // Firebase configuration for the classroom interaction app
        // 若要使用自己的 Firebase 資料庫，請修改以下配置
        const __firebase_config = JSON.stringify({
            apiKey: "AIzaSyCK62baVq9uADJUrY1tyfuCQvcMyksjaok",
            authDomain: "classtools-f72de.firebaseapp.com",
            projectId: "classtools-f72de",
            storageBucket: "classtools-f72de.firebasestorage.app",
            messagingSenderId: "662722605071",
            appId: "1:662722605071:web:24d2bd0fa2d21bcd74f37a"
        });
    </script>

    <script type="module">
        // Import Firebase SDK functions.
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js"; // Added signOut
        import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc, getDoc, getDocs, updateDoc, writeBatch, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Global Variables ---
        // Max dimension (px) for user uploaded images to prevent excessively large files.
        const MAX_IMAGE_DIMENSION = 1024; 
        // JPEG compression quality (0.0 to 1.0).
        const JPEG_QUALITY = 0.8; 

        // Firebase configuration.
        const firebaseConfig = JSON.parse(__firebase_config);

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app); 
        const db = getFirestore(app);

        // Use __app_id for the base Firestore path.
        const baseAppId = typeof __app_id !== 'undefined' ? __app_id : 'default-classroom-app';
        let userId = null;
        let studentName = null;
        let currentRole = null; // 'teacher' or 'student'
        let classroomCode = null; // NEW: Stores the teacher-defined or student-entered classroom code.
        let currentInteractionMode = null; // To track the active mode for statistics.
        let allStudentResponses = []; // Global variable to store all student responses for charting and lottery.
        let activeStudentNames = []; // NEW: Global variable to store names of all currently active students.
        let activeStudentsPresenceMap = new Map(); // 🚀 NEW: 存儲所有在線學生的完整 presence 數據（包含分心狀態）
        let lastSelectedStudentCard = null; // To track the previously selected card for the lottery feature.
        let isResponsePaused = false; // NEW: Global state for response pause.
        let lastSelectedModalStudent = null; // NEW: To track the previously selected student in the modal for lottery.

        let interactionModeUnsubscribe = null;
        let questionBanks = []; // Question Bank storage in memory (will be cleared when class ends)
        let sequencingQuestionBanks = []; // Sequencing Question Bank storage
        let matchingQuestionBanks = []; // Matching Question Bank storage
        let studentResponsesUnsubscribe = null;
        let classroomPresenceUnsubscribe = null; // Unsubscribe function for classroom presence listener.
        let lotteryUnsubscribe = null; // NEW: Listener for lottery results
        let quickAnswerUnsubscribe = null; // NEW: Listener for quick answer updates
        
        // Student attention monitoring variables
        let studentDistractionCount = 0; // 累計分心次數
        let isStudentCurrentlyDistracted = false; // 當前是否分心
        let attentionMonitoringActive = false; // 防止重複註冊監聽器

        // Quick Poll variables
        let quickPollActive = false;
        let quickPollData = null; // Stores current poll configuration
        let quickPollVotesUnsubscribe = null; // Listener for vote updates
        let currentChartType = 'bar'; // 'bar' or 'pie'
        let quickPollOptions = []; // Stores current poll options

        // Drawing specific variables.
        const canvas = document.getElementById('drawing-canvas'); // Main canvas for student display.
        const ctx = canvas.getContext('2d'); // 2D context of the main canvas.

        let backgroundCanvas = document.createElement('canvas'); // Canvas for teacher's background image.
        let backgroundCtx = backgroundCanvas.getContext('2d');

        let studentImageCanvas = document.createElement('canvas'); 
        let studentImageCtx = studentImageCanvas.getContext('2d');
        let studentUploadedImageDataURL = null; // Stores the scaled and compressed student uploaded image Data URL.

        let drawingCanvas = document.createElement('canvas'); // Canvas for student's drawing strokes.
        let drawingCtx = drawingCanvas.getContext('2d');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        
        let teacherUploadedBackgroundImageDataURL = null; // Stores the scaled and compressed background image Data URL from Firestore.

        // AI Settings Global Object
        let aiSettings = {
            aiSource: 'gemini-custom', // 'gemini-default' or 'gemini-custom'
            geminiApiKey: '' // Custom API key if 'gemini-custom' is selected
        };
        
        // MODIFIED: Combined Dispatch Settings Global Object
        let dispatchSettings = {
            type: 'url', // 'url' or 'html'
            url: '',
            isYoutube: false, // Only relevant if type is 'url'
            htmlContent: null // Only relevant if type is 'html'
        };

        // New: Recording specific variables
        let mediaRecorder;
        let audioChunks = [];
        let audioBlob = null;
        let audioDataURL = null;
        let audioStream = null; // To store the MediaStream object

        // NEW: Custom Multiple Choice Questions (Teacher side)
        let customMultipleChoiceQuestions = []; // Stores parsed questions from teacher input

        // NEW: Reading Comprehension Data (Teacher side)
        let readingComprehensionData = {
            text: '',
            questions: [] // Array of {question, correctAnswer, options, level}
        };

        // NEW: Store student's current answers (not yet submitted) for reading comprehension
        let currentReadingAnswers = [];

        // NEW: Reading Comprehension Question Banks
        let readingQuestionBanks = [];

        // NEW: Sequencing and Matching Questions (Teacher side)
        let sequencingData = {
            question: '',
            correctOrder: [] // Array of items in correct order
        };
        let matchingData = {
            question: '',
            pairs: [] // Array of {left, right} objects
        };
        let currentMatchingSelection = {
            leftItem: null,
            rightItem: null
        };
        let currentMultipleChoiceQuestions = null; // Stores questions from Firestore for student/teacher monitor
        
        // 🚀 NEW: Student-side tracking for sequencing/matching settings to detect changes
        let lastSequencingSettings = null;
        let lastMatchingSettings = null;

        // NEW: Peer Review System Variables
        let peerReviewActive = false; // Whether peer review is currently active
        let peerReviewUnsubscribe = null; // Unsubscribe function for peer review votes listener
        let studentVotedWorks = new Set(); // Track which works this student has voted for
        let allPeerReviewVotes = {}; // Global object to store all votes data
        const MAX_VOTES_PER_STUDENT = 3; // Maximum votes per student per interaction
        
        // Canvas content preservation
        let savedCanvasState = null; // Save student's drawing when switching to peer review
        

        // ============================================================================
        // 🚀 OPTIMIZATION MODULE - Core Utilities
        // ============================================================================

        /**
         * 工具函式模組 - Utility Functions Module
         * 提供通用的輔助函式，包括節流、防抖、圖片壓縮等
         */
        const Utils = (function() {
            /**
             * 節流函式 - 限制函式執行頻率
             * @param {Function} func - 要節流的函式
             * @param {number} delay - 延遲時間（毫秒）
             * @returns {Function} 節流後的函式
             */
            function throttle(func, delay = 16) {
                let lastCall = 0;
                let timeoutId = null;
                
                return function throttled(...args) {
                    const now = Date.now();
                    const timeSinceLastCall = now - lastCall;
                    
                    if (timeSinceLastCall >= delay) {
                        lastCall = now;
                        func.apply(this, args);
                    } else {
                        if (timeoutId) clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => {
                            lastCall = Date.now();
                            func.apply(this, args);
                        }, delay - timeSinceLastCall);
                    }
                };
            }

            /**
             * 防抖函式 - 延遲執行，在停止觸發後才執行
             * @param {Function} func - 要防抖的函式
             * @param {number} delay - 延遲時間（毫秒）
             * @returns {Function} 防抖後的函式
             */
            function debounce(func, delay = 300) {
                let timeoutId = null;
                
                return function debounced(...args) {
                    if (timeoutId) clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        func.apply(this, args);
                    }, delay);
                };
            }

            /**
             * 壓縮並調整圖片大小
             * @param {string} dataURL - 圖片的 Data URL
             * @param {number} maxWidth - 最大寬度
             * @param {number} maxHeight - 最大高度
             * @param {number} quality - 壓縮品質 (0-1)
             * @returns {Promise<string>} 壓縮後的 Data URL
             */
            function compressImage(dataURL, maxWidth = 1024, maxHeight = 1024, quality = 0.8) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;
                        
                        // 計算縮放比例
                        if (width > maxWidth || height > maxHeight) {
                            const widthRatio = maxWidth / width;
                            const heightRatio = maxHeight / height;
                            const ratio = Math.min(widthRatio, heightRatio);
                            
                            width = Math.floor(width * ratio);
                            height = Math.floor(height * ratio);
                        }
                        
                        // 創建 canvas 進行壓縮
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // 轉換為 JPEG 格式以獲得更好的壓縮
                        const compressed = canvas.toDataURL('image/jpeg', quality);
                        resolve(compressed);
                    };
                    
                    img.onerror = () => reject(new Error('圖片載入失敗'));
                    img.src = dataURL;
                });
            }

            /**
             * 深拷貝物件
             * @param {any} obj - 要拷貝的物件
             * @returns {any} 拷貝後的物件
             */
            function deepClone(obj) {
                if (obj === null || typeof obj !== 'object') return obj;
                if (obj instanceof Date) return new Date(obj.getTime());
                if (obj instanceof Array) return obj.map(item => deepClone(item));
                
                const clonedObj = {};
                for (const key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        clonedObj[key] = deepClone(obj[key]);
                    }
                }
                return clonedObj;
            }

            return {
                throttle,
                debounce,
                compressImage,
                deepClone
            };
        })();

        /**
         * 監聽器管理模組 - Listener Manager Module
         * 統一管理所有 Firebase 監聽器，確保正確清理避免記憶體洩漏
         */
        const ListenerManager = (function() {
            const listeners = new Map();
            
            /**
             * 註冊監聽器
             * @param {string} name - 監聽器名稱
             * @param {Function} unsubscribe - 取消訂閱函式
             */
            function register(name, unsubscribe) {
                // 如果已存在同名監聽器，先清理
                if (listeners.has(name)) {
                    const oldUnsubscribe = listeners.get(name);
                    if (typeof oldUnsubscribe === 'function') {
                        try {
                            oldUnsubscribe();
                        } catch (error) {
                            console.warn(`清理監聽器 ${name} 時發生錯誤:`, error);
                        }
                    }
                }
                listeners.set(name, unsubscribe);
            }
            
            /**
             * 取消指定監聽器
             * @param {string} name - 監聽器名稱
             */
            function unregister(name) {
                if (listeners.has(name)) {
                    const unsubscribe = listeners.get(name);
                    if (typeof unsubscribe === 'function') {
                        try {
                            unsubscribe();
                        } catch (error) {
                            console.warn(`取消監聽器 ${name} 時發生錯誤:`, error);
                        }
                    }
                    listeners.delete(name);
                }
            }
            
            /**
             * 清理所有監聽器
             */
            function clearAll() {
                listeners.forEach((unsubscribe, name) => {
                    if (typeof unsubscribe === 'function') {
                        try {
                            unsubscribe();
                        } catch (error) {
                            console.warn(`清理監聽器 ${name} 時發生錯誤:`, error);
                        }
                    }
                });
                listeners.clear();
            }
            
            /**
             * 獲取當前註冊的監聽器數量
             * @returns {number} 監聽器數量
             */
            function count() {
                return listeners.size;
            }
            
            /**
             * 檢查監聽器是否存在
             * @param {string} name - 監聽器名稱
             * @returns {boolean} 是否存在
             */
            function has(name) {
                return listeners.has(name);
            }
            
            return {
                register,
                unregister,
                clearAll,
                count,
                has
            };
        })();

        /**
         * 模態視窗管理模組 - Modal Manager Module
         * 統一管理所有模態視窗的顯示和隱藏
         */
        const ModalManager = (function() {
            /**
             * 顯示模態視窗
             * @param {string|HTMLElement} modalIdOrElement - 模態視窗 ID 或元素
             */
            function show(modalIdOrElement) {
                const modal = typeof modalIdOrElement === 'string' 
                    ? document.getElementById(modalIdOrElement)
                    : modalIdOrElement;
                    
                if (modal) {
                    modal.classList.remove('hidden');
                    // 添加淡入動畫
                    modal.style.animation = 'fadeIn 0.2s ease-in-out';
                } else {
                    console.warn('找不到模態視窗:', modalIdOrElement);
                }
            }
            
            /**
             * 隱藏模態視窗
             * @param {string|HTMLElement} modalIdOrElement - 模態視窗 ID 或元素
             */
            function hide(modalIdOrElement) {
                const modal = typeof modalIdOrElement === 'string' 
                    ? document.getElementById(modalIdOrElement)
                    : modalIdOrElement;
                    
                if (modal) {
                    modal.classList.add('hidden');
                } else {
                    console.warn('找不到模態視窗:', modalIdOrElement);
                }
            }
            
            /**
             * 切換模態視窗顯示狀態
             * @param {string|HTMLElement} modalIdOrElement - 模態視窗 ID 或元素
             */
            function toggle(modalIdOrElement) {
                const modal = typeof modalIdOrElement === 'string' 
                    ? document.getElementById(modalIdOrElement)
                    : modalIdOrElement;
                    
                if (modal) {
                    if (modal.classList.contains('hidden')) {
                        show(modal);
                    } else {
                        hide(modal);
                    }
                } else {
                    console.warn('找不到模態視窗:', modalIdOrElement);
                }
            }
            
            /**
             * 隱藏所有模態視窗
             */
            function hideAll() {
                document.querySelectorAll('.magnified-image-modal').forEach(modal => {
                    modal.classList.add('hidden');
                });
            }
            
            return {
                show,
                hide,
                toggle,
                hideAll
            };
        })();

        /**
         * 載入指示器模組 - Loading Indicator Module
         * 顯示全局載入動畫
         */
        const LoadingIndicator = (function() {
            let loadingElement = null;
            
            /**
             * 顯示載入指示器
             * @param {string} message - 載入訊息
             */
            function show(message = '載入中...') {
                // 如果已存在，先移除
                if (loadingElement) hide();
                
                loadingElement = document.createElement('div');
                loadingElement.id = 'global-loading-indicator';
                loadingElement.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                    backdrop-filter: blur(3px);
                `;
                
                loadingElement.innerHTML = `
                    <div style="background: white; padding: 2rem 3rem; border-radius: 1rem; box-shadow: 0 10px 25px rgba(0,0,0,0.2); text-align: center;">
                        <i class="fas fa-spinner fa-spin text-4xl text-blue-600 mb-3"></i>
                        <p class="text-lg text-gray-800 font-medium">${message}</p>
                    </div>
                `;
                
                document.body.appendChild(loadingElement);
            }
            
            /**
             * 隱藏載入指示器
             */
            function hide() {
                if (loadingElement && loadingElement.parentElement) {
                    loadingElement.remove();
                    loadingElement = null;
                }
            }
            
            /**
             * 檢查是否正在顯示
             * @returns {boolean} 是否顯示中
             */
            function isShowing() {
                return loadingElement !== null && loadingElement.parentElement !== null;
            }
            
            return {
                show,
                hide,
                isShowing
            };
        })();

        /**
         * 題庫管理通用類 - Question Bank Manager Class
         * 統一管理各種題型的題庫（排序題、配對題、選擇題、閱讀測驗）
         */
        class QuestionBankManager {
            constructor(storageKey, bankArray) {
                this.storageKey = storageKey;
                this.banks = bankArray || [];
            }
            
            /**
             * 儲存題庫
             * @param {Object} bank - 題庫物件 {name, ...otherData}
             * @returns {boolean} 是否成功
             */
            save(bank) {
                if (!bank || !bank.name) {
                    console.warn('題庫必須包含 name 屬性');
                    return false;
                }
                
                const existingIndex = this.banks.findIndex(b => b.name === bank.name);
                if (existingIndex !== -1) {
                    this.banks[existingIndex] = bank;
                } else {
                    this.banks.push(bank);
                }
                
                return true;
            }
            
            /**
             * 載入題庫到指定位置
             * @param {number} index - 題庫索引
             * @returns {Object|null} 題庫物件
             */
            load(index) {
                if (index >= 0 && index < this.banks.length) {
                    return this.banks[index];
                }
                return null;
            }
            
            /**
             * 刪除題庫
             * @param {number} index - 題庫索引
             * @returns {boolean} 是否成功
             */
            delete(index) {
                if (index >= 0 && index < this.banks.length) {
                    this.banks.splice(index, 1);
                    return true;
                }
                return false;
            }
            
            /**
             * 獲取所有題庫
             * @returns {Array} 題庫陣列
             */
            getAll() {
                return this.banks;
            }
            
            /**
             * 清空所有題庫
             */
            clearAll() {
                this.banks.length = 0;
            }
            
            /**
             * 根據名稱搜尋題庫
             * @param {string} name - 題庫名稱
             * @returns {Object|null} 題庫物件
             */
            findByName(name) {
                return this.banks.find(b => b.name === name) || null;
            }
        }

        /**
         * 錯誤處理模組 - Error Handler Module
         * 統一處理 Firebase 和其他錯誤
         */
        const ErrorHandler = (function() {
            /**
             * 處理 Firebase 錯誤
             * @param {Error} error - 錯誤物件
             * @param {string} defaultMessage - 預設錯誤訊息
             */
            function handleFirebaseError(error, defaultMessage = '操作失敗') {
                console.error('[Firebase Error]', error);
                
                let userMessage = defaultMessage;
                
                // 根據錯誤代碼提供更具體的訊息
                if (error.code) {
                    switch (error.code) {
                        case 'permission-denied':
                            userMessage = '權限不足，請重新登入';
                            // 3秒後返回登入頁
                            setTimeout(() => {
                                if (typeof showView === 'function') {
                                    showView('entry');
                                }
                            }, 3000);
                            break;
                        
                        case 'unavailable':
                        case 'failed-precondition':
                            userMessage = '網路連線不穩定，請檢查網路';
                            break;
                        
                        case 'not-found':
                            userMessage = '找不到指定的資料';
                            break;
                        
                        case 'already-exists':
                            userMessage = '資料已存在';
                            break;
                        
                        case 'resource-exhausted':
                            userMessage = '伺服器繁忙，請稍後再試';
                            break;
                        
                        case 'unauthenticated':
                            userMessage = '未登入或登入已過期，請重新登入';
                            setTimeout(() => {
                                if (typeof showView === 'function') {
                                    showView('entry');
                                }
                            }, 3000);
                            break;
                        
                        default:
                            userMessage = `${defaultMessage}（錯誤代碼：${error.code}）`;
                    }
                }
                
                // 顯示錯誤訊息給用戶
                if (typeof showMessage === 'function') {
                    showMessage(userMessage, 'error');
                }
                
                return userMessage;
            }
            
            /**
             * 處理一般錯誤
             * @param {Error} error - 錯誤物件
             * @param {string} context - 錯誤發生的上下文
             */
            function handleGenericError(error, context = '') {
                console.error(`[Error${context ? ' in ' + context : ''}]`, error);
                
                const userMessage = context 
                    ? `${context}時發生錯誤，請稍後再試`
                    : '發生錯誤，請稍後再試';
                
                if (typeof showMessage === 'function') {
                    showMessage(userMessage, 'error');
                }
                
                return userMessage;
            }
            
            /**
             * 安全執行異步函式
             * @param {Function} asyncFn - 異步函式
             * @param {string} context - 上下文描述
             * @param {Function} onError - 錯誤回調（可選）
             * @returns {Promise} 執行結果
             */
            async function safeExecute(asyncFn, context = '', onError = null) {
                try {
                    return await asyncFn();
                } catch (error) {
                    // 判斷是否為 Firebase 錯誤
                    if (error.code) {
                        handleFirebaseError(error, `${context}失敗`);
                    } else {
                        handleGenericError(error, context);
                    }
                    
                    // 執行自訂錯誤回調
                    if (typeof onError === 'function') {
                        onError(error);
                    }
                    
                    return null;
                }
            }
            
            return {
                handleFirebaseError,
                handleGenericError,
                safeExecute
            };
        })();

        /**
         * DOM 查詢快取模組 - DOM Query Cache Module
         * 提供常用 DOM 元素的快速存取
         */
        const DOMCache = (function() {
            const cache = {};
            
            /**
             * 獲取元素（帶快取）
             * @param {string} id - 元素 ID
             * @returns {HTMLElement|null} DOM 元素
             */
            function get(id) {
                if (!cache[id]) {
                    cache[id] = document.getElementById(id);
                }
                return cache[id];
            }
            
            /**
             * 批量獲取元素
             * @param {Array<string>} ids - 元素 ID 陣列
             * @returns {Object} 元素物件 {id: element}
             */
            function getMany(ids) {
                const elements = {};
                ids.forEach(id => {
                    elements[id] = get(id);
                });
                return elements;
            }
            
            /**
             * 清除快取
             * @param {string} id - 元素 ID（可選，不提供則清除全部）
             */
            function clear(id = null) {
                if (id) {
                    delete cache[id];
                } else {
                    for (const key in cache) {
                        delete cache[key];
                    }
                }
            }
            
            /**
             * 預載常用元素
             */
            function preload() {
                const commonIds = [
                    'student-responses-container',
                    'active-student-count',
                    'message-box',
                    'message-content',
                    'text-input-area',
                    'drawing-canvas',
                    'submit-text-btn',
                    'submit-drawing-btn',
                    'student-welcome-msg'
                ];
                
                commonIds.forEach(id => get(id));
            }
            
            return {
                get,
                getMany,
                clear,
                preload
            };
        })();

        // ============================================================================
        // End of Optimization Module
        // ============================================================================

        // --- DOM Elements Caching ---
        const views = {
            entry: document.getElementById('entry-view'),
            teacherClassroomCode: document.getElementById('teacher-classroom-code-view'), // NEW VIEW
            teacherMenu: document.getElementById('teacher-menu-view'),
            teacherMonitor: document.getElementById('teacher-monitor-view'),
            studentName: document.getElementById('student-name-view'),
            studentWaiting: document.getElementById('student-waiting-view'),
            studentInteraction: document.getElementById('student-interaction-view'),
            studentPeerReview: document.getElementById('student-peer-review-view'), // NEW VIEW
        };

        const interactionUIs = {
            true_false: document.getElementById('interaction-true-false'),
            multiple_choice: document.getElementById('interaction-multiple-choice'),
            text_input: document.getElementById('interaction-text-input'),
            drawing: document.getElementById('interaction-drawing'),
            url_dispatch: document.getElementById('interaction-url-dispatch'), // Now handles both URL and HTML
            recording: document.getElementById('interaction-recording'), // New UI
            reading_comprehension: document.getElementById('interaction-reading-comprehension'), // Reading comprehension UI
            quick_answer: document.getElementById('interaction-quick-answer'), // Quick answer UI
            quick_poll: document.getElementById('interaction-quick-poll'), // Quick poll UI
            sequencing: document.getElementById('interaction-sequencing'), // Sequencing UI
            matching: document.getElementById('interaction-matching'), // Matching UI
        };

        // --- Core Logic Functions ---
        /**
         * Displays the specified view section.
         * @param {string} viewName - The name of the view to display (key in `views` object).
         */
        function showView(viewName) {
            const body = document.querySelector('body');
            body.classList.remove('initial-view-background');

            Object.values(views).forEach(view => view.classList.add('hidden'));
            if (views[viewName]) {
                views[viewName].classList.remove('hidden');
                if (viewName === 'entry') {
                    body.classList.add('initial-view-background');
                }
            } else {
                console.error('找不到視圖:', viewName);
            }
        }
        
        /**
         * Displays the UI for a specific interaction mode within the student interface.
         * @param {string} mode - The interaction mode (e.g., 'true_false', 'drawing', 'recording', 'url_dispatch').
         * @param {boolean} [isResumingFromPause=false] - True if this is part of resuming from a paused state.
         */
        function showInteractionUI(mode, isResumingFromPause = false) {
             Object.values(interactionUIs).forEach(ui => ui.classList.add('hidden'));
             // Clear URL dispatch content if switching to another mode
             if (mode !== 'url_dispatch' && interactionUIs.url_dispatch) {
                interactionUIs.url_dispatch.innerHTML = ''; // Clear content for URL/HTML dispatch
                interactionUIs.url_dispatch.style.cssText = ''; // Reset container styles
             }

             if (interactionUIs[mode]) {
                interactionUIs[mode].classList.remove('hidden');
                resetStudentUIState(mode, isResumingFromPause); // Pass the flag

                // Special handling for quick answer mode
                if (mode === 'quick_answer') {
                    console.log('[showInteractionUI] Starting quick answer mode...');
                    startQuickAnswer();
                    console.log('[showInteractionUI] Quick answer started, now setting up listener...');
                    listenToQuickAnswerUpdates();
                    console.log('[showInteractionUI] Quick answer listener registered');
                }
             }
        }

        /**
         * Resets the student UI state, e.g., clears input fields or enables buttons.
         * @param {string} mode - The current interaction mode.
         * @param {boolean} [isResumingFromPause=false] - True if this reset is part of resuming from a paused state.
         */
        function resetStudentUIState(mode, isResumingFromPause = false) {
            const grayClass = 'bg-gray-400';
            const hoverClassMap = {
                '1': 'hover:bg-blue-600', '2': 'hover:bg-yellow-600',
                '3': 'hover:bg-green-600', '4': 'hover:bg-red-600'
            };
            
            // 🚀 FIX: 排除所有可能已提交的按鈕，避免在異步檢查完成前覆蓋已提交狀態
            // 這些控件將在各自的 case 中單獨處理
            const excludedSubmitButtons = [
                'submit-reading-btn',
                'submit-text-btn', 
                'submit-drawing-btn',
                'submit-recording-btn',
                'submit-custom-mc-btn',
                'submit-sequencing-btn',
                'submit-matching-btn'
            ];
            
            // Only re-enable controls if they're not submission-related
            document.querySelectorAll('#student-interaction-view button, #student-interaction-view textarea, #student-interaction-view input[type="file"], #student-interaction-view select, #student-interaction-view input[type="radio"]').forEach(el => {
                // 跳過所有提交按鈕和答案按鈕的重置，這些將在各自的 case 中單獨處理
                if (excludedSubmitButtons.includes(el.id)) return;
                if (el.classList.contains('answer-btn')) return; // 跳過是非題和選擇題的答案按鈕
                
                el.disabled = false;
                // Re-add original classes if they were removed by pause state
                if (el.classList.contains('btn-gray')) {
                    el.classList.remove('btn-gray');
                    el.classList.add('btn-primary'); // Assuming primary is default for many
                }
            });
            
            // Canvas 和其他容器的 pointerEvents 將在各自的 case 中處理
            // 避免在這裡全局啟用

            switch(mode) {
                case 'true_false':
                    // 🚀 NEW: 檢查學生是否已提交是非題答案，永久鎖定已提交的選項
                    (async () => {
                        let hasSubmitted = false;
                        if (currentRole === 'student' && studentName && classroomCode) {
                            try {
                                const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
                                const docSnap = await getDoc(studentRef);
                                if (docSnap.exists()) {
                                    const data = docSnap.data();
                                    if (data.interactionMode === 'true_false' && data.answer) {
                                        hasSubmitted = true;
                                        console.log('[resetStudentUIState] Student has submitted true/false answer, locking buttons');
                                    }
                                }
                            } catch (error) {
                                console.error('[resetStudentUIState] Error checking submission status:', error);
                            }
                        }
                        
                        // 如果已提交，鎖定所有按鈕
                        if (hasSubmitted) {
                            interactionUIs[mode].querySelectorAll('.answer-btn').forEach(btn => {
                                btn.disabled = true;
                                btn.classList.remove('bg-green-500', 'bg-red-500');
                                btn.classList.add(grayClass);
                            });
                        } else {
                            // 🎯 IMPROVED: 未提交，恢復按鈕到初始狀態
                            interactionUIs[mode].querySelectorAll('.answer-btn').forEach(btn => {
                                btn.disabled = false;
                                btn.classList.remove(grayClass);
                                
                                // 恢復原始內容和顏色
                                const answer = btn.dataset.answer;
                                if (answer === 'O') {
                                    btn.classList.add('bg-green-500');
                                    btn.innerHTML = `
                                        <i class="fas fa-check text-white" style="font-size: 4rem;"></i>
                                        <p class="text-white text-2xl font-bold mt-2">正確</p>
                                    `;
                                } else if (answer === 'X') {
                                    btn.classList.add('bg-red-500');
                                    btn.innerHTML = `
                                        <i class="fas fa-times text-white" style="font-size: 4rem;"></i>
                                        <p class="text-white text-2xl font-bold mt-2">錯誤</p>
                                    `;
                                }
                                
                                // 移除已送出標記
                                btn.removeAttribute('data-original-text');
                                btn.removeAttribute('data-submitted');
                            });
                        }
                    })();
                    break;
                case 'multiple_choice':
                    // 🚀 NEW: 檢查學生是否已提交選擇題答案（包含默認1-4和自訂選擇題）
                    (async () => {
                        let hasSubmitted = false;
                        let submittedInteractionMode = null;
                        if (currentRole === 'student' && studentName && classroomCode) {
                            try {
                                const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
                                const docSnap = await getDoc(studentRef);
                                if (docSnap.exists()) {
                                    const data = docSnap.data();
                                    if (data.interactionMode === 'multiple_choice' && data.answer) {
                                        hasSubmitted = true;
                                        submittedInteractionMode = data.interactionMode;
                                        console.log('[resetStudentUIState] Student has submitted multiple choice answer, locking buttons');
                                    }
                                }
                            } catch (error) {
                                console.error('[resetStudentUIState] Error checking submission status:', error);
                            }
                        }
                        
                        const defaultMcOptions = document.getElementById('default-mc-options');
                        
                        // 如果已提交，鎖定所有按鈕
                        if (hasSubmitted) {
                            // 鎖定默認選擇題按鈕
                            defaultMcOptions.querySelectorAll('.answer-btn').forEach(btn => {
                                btn.disabled = true;
                                btn.classList.remove('bg-blue-500', 'bg-yellow-500', 'bg-green-500', 'bg-red-500');
                                btn.classList.add(grayClass);
                                // Remove hover classes
                                btn.classList.remove(hoverClassMap['1'], hoverClassMap['2'], hoverClassMap['3'], hoverClassMap['4']);
                            });
                            
                            // 鎖定自訂選擇題提交按鈕
                            const submitBtn = document.getElementById('submit-custom-mc-btn');
                            submitBtn.disabled = true;
                            submitBtn.classList.remove('btn-primary');
                            submitBtn.classList.add('btn-gray');
                            submitBtn.textContent = '✓ 已送出答案';
                        } else {
                            // 🎯 IMPROVED: 未提交，恢復按鈕到初始狀態
                            defaultMcOptions.querySelectorAll('.answer-btn').forEach(btn => {
                                btn.disabled = false;
                                btn.classList.remove(grayClass);
                                
                                // 恢復原始內容和顏色
                                const answer = btn.dataset.answer;
                                if (answer === '1') {
                                    btn.classList.add('bg-blue-500', hoverClassMap['1']);
                                    btn.innerHTML = '<span class="text-white text-6xl sm:text-7xl md:text-8xl font-bold">1</span>';
                                } else if (answer === '2') {
                                    btn.classList.add('bg-yellow-500', hoverClassMap['2']);
                                    btn.innerHTML = '<span class="text-white text-6xl sm:text-7xl md:text-8xl font-bold">2</span>';
                                } else if (answer === '3') {
                                    btn.classList.add('bg-green-500', hoverClassMap['3']);
                                    btn.innerHTML = '<span class="text-white text-6xl sm:text-7xl md:text-8xl font-bold">3</span>';
                                } else if (answer === '4') {
                                    btn.classList.add('bg-red-500', hoverClassMap['4']);
                                    btn.innerHTML = '<span class="text-white text-6xl sm:text-7xl md:text-8xl font-bold">4</span>';
                                }
                                
                                // 移除已送出標記
                                btn.removeAttribute('data-original-text');
                                btn.removeAttribute('data-submitted');
                            });
                            
                            // Reset custom MC options (but preserve submission state)
                            document.getElementById('custom-mc-questions-container').innerHTML = '';
                            // 只有在不是從暫停狀態恢復時才重置按鈕
                            if (!isResumingFromPause) {
                                const submitBtn = document.getElementById('submit-custom-mc-btn');
                                submitBtn.disabled = false;
                                submitBtn.classList.remove('btn-gray');
                                submitBtn.classList.add('btn-primary');
                                submitBtn.textContent = '送出全部答案 ✉️';
                            }
                        }
                    })();
                    break;
                case 'text_input':
                    // 🚀 NEW: 檢查學生是否已提交文字題答案，永久鎖定已提交的按鈕
                    (async () => {
                        let hasSubmitted = false;
                        if (currentRole === 'student' && studentName && classroomCode) {
                            try {
                                const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
                                const docSnap = await getDoc(studentRef);
                                if (docSnap.exists()) {
                                    const data = docSnap.data();
                                    if (data.interactionMode === 'text_input' && data.answer) {
                                        hasSubmitted = true;
                                        console.log('[resetStudentUIState] Student has submitted text answer, locking button');
                                    }
                                }
                            } catch (error) {
                                console.error('[resetStudentUIState] Error checking submission status:', error);
                            }
                        }
                        
                        const submitTextBtn = document.getElementById('submit-text-btn');
                        
                        // 如果已提交，鎖定按鈕
                        if (hasSubmitted) {
                            submitTextBtn.disabled = true;
                            submitTextBtn.classList.remove('btn-primary');
                            submitTextBtn.classList.add('btn-gray');
                            submitTextBtn.textContent = '✓ 已送出答案';
                            document.getElementById('text-input-area').disabled = true;
                        } else {
                            document.getElementById('text-input-area').value = '';
                            document.getElementById('text-input-area').disabled = false;
                            submitTextBtn.disabled = false;
                            submitTextBtn.classList.remove('btn-gray');
                            submitTextBtn.classList.add('btn-primary');
                            submitTextBtn.textContent = '送出答案 ✉️';
                        }
                    })();
                    break;
                case 'drawing':
                    // 🚀 NEW: 檢查學生是否已提交繪圖答案，永久鎖定已提交的按鈕
                    (async () => {
                        let hasSubmitted = false;
                        if (currentRole === 'student' && studentName && classroomCode) {
                            try {
                                const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
                                const docSnap = await getDoc(studentRef);
                                if (docSnap.exists()) {
                                    const data = docSnap.data();
                                    if (data.interactionMode === 'drawing' && data.answer) {
                                        hasSubmitted = true;
                                        console.log('[resetStudentUIState] Student has submitted drawing answer, locking button');
                                    }
                                }
                            } catch (error) {
                                console.error('[resetStudentUIState] Error checking submission status:', error);
                            }
                        }
                        
                        const submitDrawingBtn = document.getElementById('submit-drawing-btn');
                        
                        // 如果已提交，鎖定按鈕和畫布
                        if (hasSubmitted) {
                            submitDrawingBtn.disabled = true;
                            submitDrawingBtn.classList.remove('btn-primary');
                            submitDrawingBtn.classList.add('btn-gray');
                            submitDrawingBtn.textContent = '✓ 已送出答案';
                            canvas.style.pointerEvents = 'none'; // 禁用畫布交互
                        } else {
                            // Only clear the drawing canvas if it's NOT resuming from a pause.
                            if (!isResumingFromPause) {
                                clearDrawingCanvas(); // Clears only the student's drawing layer.
                                studentUploadedImageDataURL = null; // Clear student uploaded image too
                                studentImageCtx.clearRect(0, 0, studentImageCanvas.width, studentImageCanvas.height);
                            }
                            
                            submitDrawingBtn.disabled = false;
                            submitDrawingBtn.classList.remove('btn-gray');
                            submitDrawingBtn.classList.add('btn-primary');
                            submitDrawingBtn.textContent = '送出答案 ✉️';
                            canvas.style.pointerEvents = 'auto'; // 啟用畫布交互
                            
                            // Reset drawing tools to default values.
                            const colorSelect = document.getElementById('color-select');
                            const sizeSelect = document.getElementById('size-select');
                            const penToolBtn = document.getElementById('pen-tool-btn');
                            const eraserBtn = document.getElementById('eraser-btn');

                            colorSelect.value = 'black';
                            sizeSelect.value = '2';
                            drawingCtx.strokeStyle = 'black'; 
                            drawingCtx.lineWidth = 2;
                            drawingCtx.globalCompositeOperation = 'source-over'; 
                            
                            penToolBtn.classList.add('border-blue-500');
                            eraserBtn.classList.remove('border-blue-500');

                            updateColorSwatch(colorSelect.value);
                        }
                    })();
                    break;
                case 'url_dispatch': // This mode now handles both URL and HTML
                    // Content is dynamically generated, no specific reset needed here beyond clearing in showInteractionUI
                    break;
                case 'recording':
                    // 🚀 NEW: 檢查學生是否已提交錄音答案，永久鎖定已提交的按鈕
                    (async () => {
                        let hasSubmitted = false;
                        if (currentRole === 'student' && studentName && classroomCode) {
                            try {
                                const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
                                const docSnap = await getDoc(studentRef);
                                if (docSnap.exists()) {
                                    const data = docSnap.data();
                                    if (data.interactionMode === 'recording' && data.answer) {
                                        hasSubmitted = true;
                                        console.log('[resetStudentUIState] Student has submitted recording answer, locking buttons');
                                    }
                                }
                            } catch (error) {
                                console.error('[resetStudentUIState] Error checking submission status:', error);
                            }
                        }
                        
                        // 如果已提交，鎖定所有按鈕
                        if (hasSubmitted) {
                            document.getElementById('start-recording-btn').disabled = true;
                            document.getElementById('stop-recording-btn').disabled = true;
                            document.getElementById('play-recording-btn').disabled = true;
                            document.getElementById('reset-recording-btn').disabled = true;
                            const submitRecordingBtn = document.getElementById('submit-recording-btn');
                            submitRecordingBtn.disabled = true;
                            submitRecordingBtn.classList.remove('btn-primary');
                            submitRecordingBtn.classList.add('btn-gray');
                            submitRecordingBtn.textContent = '✓ 已送出答案';
                            recordingStatusText.textContent = '已送出錄音答案';
                        } else {
                            // Reset recording state
                            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                                mediaRecorder.stop();
                            }
                            if (audioStream) {
                                audioStream.getTracks().forEach(track => track.stop());
                            }
                            audioChunks = [];
                            audioBlob = null;
                            audioDataURL = null;
                            document.getElementById('audio-preview').classList.add('hidden');
                            document.getElementById('audio-preview').src = '';
                            document.getElementById('start-recording-btn').disabled = false;
                            document.getElementById('stop-recording-btn').disabled = true;
                            document.getElementById('play-recording-btn').disabled = true;
                            document.getElementById('reset-recording-btn').disabled = true;
                            document.getElementById('submit-recording-btn').disabled = true;
                            recordingStatusText.textContent = '準備錄音...';
                            recordingStatusIcon.classList.remove('fa-spin', 'text-red-500');
                            recordingStatusIcon.classList.add('text-gray-400');
                        }
                    })();
                    break;
                case 'quick_answer':
                    // Reset quick answer state
                    document.getElementById('quick-answer-status-text').textContent = '等待搶答開始...';
                    document.getElementById('quick-answer-result').classList.add('hidden');
                    document.getElementById('quick-answer-locked').classList.add('hidden');
                    document.getElementById('quick-answer-button-container').innerHTML = '';
                    document.getElementById('quick-answer-button-container').classList.add('pointer-events-none');
                    break;
                case 'sequencing':
                    // 🚀 NEW: 檢查學生是否已提交排序題答案，永久鎖定已提交的按鈕
                    (async () => {
                        let hasSubmitted = false;
                        if (currentRole === 'student' && studentName && classroomCode) {
                            try {
                                const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
                                const docSnap = await getDoc(studentRef);
                                if (docSnap.exists()) {
                                    const data = docSnap.data();
                                    if (data.interactionMode === 'sequencing' && data.answer) {
                                        hasSubmitted = true;
                                        console.log('[resetStudentUIState] Student has submitted sequencing answer, locking button');
                                    }
                                }
                            } catch (error) {
                                console.error('[resetStudentUIState] Error checking submission status:', error);
                            }
                        }
                        
                        const submitSequencingBtn = document.getElementById('submit-sequencing-btn');
                        
                        // 如果已提交，鎖定按鈕
                        if (hasSubmitted) {
                            submitSequencingBtn.disabled = true;
                            submitSequencingBtn.classList.remove('btn-primary');
                            submitSequencingBtn.classList.add('btn-gray');
                            submitSequencingBtn.textContent = '✓ 已送出答案';
                            // 禁用排序項目的拖動
                            document.getElementById('sequencing-items-container').style.pointerEvents = 'none';
                        } else {
                            // 🚀 FIX: 不要在這裡清空容器！
                            // setupSequencingUI 會在需要時自己清空並重新填充
                            // 如果這裡清空，會導致在後續快照更新時（settingsChanged=false）容器被清空但不重新渲染
                            document.getElementById('sequencing-items-container').style.pointerEvents = 'auto';
                            submitSequencingBtn.disabled = false;
                            submitSequencingBtn.classList.remove('btn-gray');
                            submitSequencingBtn.classList.add('btn-primary');
                            submitSequencingBtn.textContent = '送出答案 ✉️';
                        }
                    })();
                    break;
                case 'matching':
                    // 🚀 NEW: 檢查學生是否已提交配對題答案，永久鎖定已提交的按鈕
                    (async () => {
                        let hasSubmitted = false;
                        if (currentRole === 'student' && studentName && classroomCode) {
                            try {
                                const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
                                const docSnap = await getDoc(studentRef);
                                if (docSnap.exists()) {
                                    const data = docSnap.data();
                                    if (data.interactionMode === 'matching' && data.answer) {
                                        hasSubmitted = true;
                                        console.log('[resetStudentUIState] Student has submitted matching answer, locking button');
                                    }
                                }
                            } catch (error) {
                                console.error('[resetStudentUIState] Error checking submission status:', error);
                            }
                        }
                        
                        const submitMatchingBtn = document.getElementById('submit-matching-btn');
                        
                        // 如果已提交，鎖定按鈕
                        if (hasSubmitted) {
                            submitMatchingBtn.disabled = true;
                            submitMatchingBtn.classList.remove('btn-primary');
                            submitMatchingBtn.classList.add('btn-gray');
                            submitMatchingBtn.textContent = '✓ 已送出答案';
                            // 禁用配對項目的點擊
                            document.getElementById('matching-column-a').style.pointerEvents = 'none';
                            document.getElementById('matching-column-b').style.pointerEvents = 'none';
                        } else {
                            // 🚀 FIX: 不要在這裡清空容器！
                            // setupMatchingUI 會在需要時自己清空並重新填充
                            // 如果這裡清空，會導致在後續快照更新時（settingsChanged=false）容器被清空但不重新渲染
                            document.getElementById('matching-column-a').style.pointerEvents = 'auto';
                            document.getElementById('matching-column-b').style.pointerEvents = 'auto';
                            submitMatchingBtn.disabled = false;
                            submitMatchingBtn.classList.remove('btn-gray');
                            submitMatchingBtn.classList.add('btn-primary');
                            submitMatchingBtn.textContent = '送出答案 ✉️';
                            currentMatchingSelection.leftItem = null;
                            currentMatchingSelection.rightItem = null;
                        }
                    })();
                    break;
                case 'reading_comprehension':
                    // 🚀 FIX: 檢查學生是否已提交，永久鎖定已提交的答案
                    (async () => {
                        const submitReadingBtn = document.getElementById('submit-reading-btn');
                        
                        // 檢查 Firebase 中是否已有提交記錄
                        let hasSubmitted = false;
                        if (currentRole === 'student' && studentName && classroomCode) {
                            try {
                                const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
                                const docSnap = await getDoc(studentRef);
                                if (docSnap.exists()) {
                                    const data = docSnap.data();
                                    if (data.interactionMode === 'reading_comprehension' && data.answer) {
                                        hasSubmitted = true;
                                        console.log('[resetStudentUIState] Student has submitted reading answer, locking button');
                                    }
                                }
                            } catch (error) {
                                console.error('[resetStudentUIState] Error checking submission status:', error);
                            }
                        }
                        
                        // 如果已提交，永久鎖定按鈕
                        if (hasSubmitted) {
                            submitReadingBtn.disabled = true;
                            submitReadingBtn.classList.remove('btn-primary');
                            submitReadingBtn.classList.add('btn-gray');
                            submitReadingBtn.textContent = '✓ 已送出答案';
                        }
                        // 否則，只有在不是從暫停恢復時才重置按鈕
                        else if (!isResumingFromPause) {
                            submitReadingBtn.disabled = false;
                            submitReadingBtn.classList.remove('btn-gray');
                            submitReadingBtn.classList.add('btn-primary');
                            submitReadingBtn.textContent = '送出答案 ✉️';
                        }
                    })();
                    break;
                case 'quick_poll':
                    // Reset quick poll state
                    document.getElementById('quick-poll-options-container').innerHTML = '';
                    document.getElementById('quick-poll-options-container').classList.remove('hidden');
                    document.getElementById('quick-poll-voted-status').classList.add('hidden');
                    document.getElementById('quick-poll-question-display').textContent = '';
                    break;
            }
        }

        /**
         * Toggles the enabled/disabled state of student interaction elements.
         * @param {boolean} disable - True to disable, false to enable.
         */
        function toggleStudentInteractionElements(disable) {
            const studentInteractionView = document.getElementById('student-interaction-view');
            // Select all interactive elements within the student interaction view, excluding the pause overlay itself.
            const interactiveElements = studentInteractionView.querySelectorAll(
                'button, textarea, input[type="file"], select, input[type="radio"]' // Added input[type="radio"]
            );

            interactiveElements.forEach(el => {
                // Only disable if the element is not the pause overlay itself or its children
                if (!el.closest('#student-pause-overlay')) {
                    if (disable) {
                        el.disabled = disable;
                        // Add a class for visual feedback if needed, e.g., gray out
                        if (el.tagName === 'BUTTON' && !el.classList.contains('btn-gray')) {
                            el.classList.add('btn-gray');
                            el.classList.remove('btn-primary', 'btn-green', 'btn-orange', 'btn-purple', 'btn-teal', 'bg-indigo-600', 'hover:bg-indigo-700', 'bg-yellow-600', 'hover:bg-yellow-700'); // Remove original colors
                        }
                    } else {
                        // 🎯 CRITICAL FIX: 檢查是否已提交答案，防止重新啟用已鎖定的按鈕
                        const hasDataSubmitted = el.hasAttribute('data-submitted');
                        const hasDataAttribute = el.hasAttribute('data-original-text');
                        const textContent = el.textContent || '';
                        const hasSubmittedText = textContent.includes('已送出') || textContent.includes('✓');
                        const hasSubmitted = hasDataSubmitted || hasDataAttribute || hasSubmittedText;
                        
                        // 🎯 如果按鈕已提交，保持禁用狀態
                        if (hasSubmitted) {
                            el.disabled = true; // 保持禁用
                            return; // 跳過後續的樣式恢復邏輯
                        }
                        
                        // 未提交的按鈕才重新啟用
                        el.disabled = false;
                        
                        // Re-enable and restore original styles
                        if (el.tagName === 'BUTTON' && el.classList.contains('btn-gray')) {
                            el.classList.remove('btn-gray');
                            // Restore based on common button types or specific IDs
                            if (el.id === 'submit-text-btn' || el.id === 'submit-drawing-btn' || el.id === 'submit-recording-btn' || el.id === 'submit-custom-mc-btn' || el.id === 'submit-reading-btn' || el.id === 'submit-sequencing-btn' || el.id === 'submit-matching-btn') {
                                el.classList.add('btn-primary');
                            } else if (el.classList.contains('answer-btn')) {
                                // For answer buttons, re-apply their specific colors
                                if (el.dataset.answer === 'O') el.classList.add('bg-green-500');
                                else if (el.dataset.answer === 'X') el.classList.add('bg-red-500');
                                else if (el.dataset.answer === '1') el.classList.add('bg-blue-500');
                                else if (el.dataset.answer === '2') el.classList.add('bg-yellow-500');
                                else if (el.dataset.answer === '3') el.classList.add('bg-green-500');
                                else if (el.dataset.answer === '4') el.classList.add('bg-red-500');
                            } else if (el.id === 'start-recording-btn') {
                                el.classList.add('btn-green');
                            } else if (el.id === 'stop-recording-btn') {
                                el.classList.add('btn-red');
                            } else if (el.id === 'play-recording-btn') {
                                el.classList.add('btn-primary');
                            } else if (el.id === 'reset-recording-btn') {
                                el.classList.add('btn-orange');
                            } else if (el.id === 'pen-tool-btn') {
                                el.classList.add('border-blue-500'); // Pen button border
                            }
                        }
                    }
                }
            });

            // Handle canvas interaction separately
            canvas.style.pointerEvents = disable ? 'none' : 'auto';

            // Handle recording specific buttons that might be disabled by default
            if (currentInteractionMode === 'recording' && !disable) {
                // Only enable start if not already recording
                if (mediaRecorder && mediaRecorder.state === 'inactive') {
                    document.getElementById('start-recording-btn').disabled = false;
                }
                // Other recording buttons remain disabled until recording starts/stops
            }
        }
        
        /**
         * Displays a custom message box.
         * @param {string} message - The message to display.
         * @param {'info' | 'success' | 'error' | 'warning'} type - The message type, influencing its color.
         */
        function showMessage(message, type = 'info') {
            const msgBox = document.getElementById('message-box');
            const msgContent = document.getElementById('message-content');
            msgContent.textContent = message;
            // Use z-index 10001 to ensure message appears above all modals (modals use z-index up to 10000)
            msgBox.className = 'fixed top-4 left-1/2 -translate-x-1/2 px-6 py-3 rounded-lg shadow-lg transition-all duration-300 transform text-white font-semibold';
            msgBox.style.zIndex = '10001';
            switch (type) {
                case 'success': msgBox.classList.add('bg-green-500'); break;
                case 'error': msgBox.classList.add('bg-red-500'); break;
                case 'warning': msgBox.classList.add('bg-yellow-500'); break;
                case 'info': msgBox.classList.add('bg-blue-500'); break;
                default: msgBox.classList.add('bg-blue-500'); break;
            }
            msgBox.classList.remove('hidden');
            setTimeout(() => {
                msgBox.classList.add('hidden');
            }, 3000); // Auto-hide after 3 seconds.
        }

        /**
         * 生成統一的檔案名稱（包含教室代碼和時間戳記）
         * @param {string} baseName - 檔案基礎名稱（例如：'學生回應'、'是非題統計'）
         * @param {string} extension - 檔案副檔名（例如：'csv'、'zip'）
         * @returns {string} 完整檔名（格式：教室代碼_檔案名稱_YYYYMMDD_HHMMSS.副檔名）
         */
        function generateFilename(baseName, extension) {
            const now = new Date();
            const timestamp = now.getFullYear() +
                            String(now.getMonth() + 1).padStart(2, '0') +
                            String(now.getDate()).padStart(2, '0') + '_' +
                            String(now.getHours()).padStart(2, '0') +
                            String(now.getMinutes()).padStart(2, '0') +
                            String(now.getSeconds()).padStart(2, '0');
            
            const classroomPrefix = classroomCode ? `${classroomCode}_` : '';
            return `${classroomPrefix}${baseName}_${timestamp}.${extension}`;
        }

        /**
         * Question Bank Management Functions
         */
        function updateQuestionBankList() {
            const list = document.getElementById('question-bank-list');
            if (questionBanks.length === 0) {
                list.innerHTML = '<div class="text-gray-500 text-sm italic text-center">目前沒有儲存的題庫</div>';
            } else {
                list.innerHTML = questionBanks.map((bank, index) => `
                    <div class="flex items-center justify-between p-2 bg-gray-50 rounded border">
                        <span class="text-sm font-medium text-gray-700">${bank.name}</span>
                        <div class="flex gap-2">
                            <button onclick="loadQuestionBankToTextarea(${index})" class="px-2 py-1 bg-blue-500 hover:bg-blue-600 text-white text-xs rounded">載入</button>
                            <button onclick="deleteQuestionBank(${index})" class="px-2 py-1 bg-red-500 hover:bg-red-600 text-white text-xs rounded">刪除</button>
                        </div>
                    </div>
                `).join('');
            }
        }

        function loadQuestionBankFromFile() {
            const fileInput = document.getElementById('question-bank-file-input');
            const file = fileInput.files[0];

            if (!file) {
                showMessage('請選擇一個txt檔案', 'error');
                return;
            }

            if (!file.name.toLowerCase().endsWith('.txt')) {
                showMessage('只能上傳txt格式的檔案', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const fileName = file.name.replace('.txt', '');

                // Check if bank with same name exists
                const existingIndex = questionBanks.findIndex(bank => bank.name === fileName);
                if (existingIndex !== -1) {
                    if (confirm(`題庫「${fileName}」已存在，是否要覆蓋？`)) {
                        questionBanks[existingIndex] = { name: fileName, content: content };
                    } else {
                        return;
                    }
                } else {
                    questionBanks.push({ name: fileName, content: content });
                }

                updateQuestionBankList();
                showMessage(`題庫「${fileName}」載入成功`, 'success');
                fileInput.value = ''; // Clear file input
            };

            reader.onerror = function() {
                showMessage('讀取檔案時發生錯誤', 'error');
            };

            reader.readAsText(file, 'UTF-8');
        }

        function saveQuestionBankFromTextarea() {
            const nameInput = document.getElementById('question-bank-name-input');
            const textarea = document.getElementById('custom-mc-questions-textarea');
            const name = nameInput.value.trim();
            const content = textarea.value.trim();

            if (!name) {
                showMessage('請輸入題庫名稱', 'error');
                return;
            }

            if (!content) {
                showMessage('題目內容不能為空', 'error');
                return;
            }

            // Check if bank with same name exists
            const existingIndex = questionBanks.findIndex(bank => bank.name === name);
            if (existingIndex !== -1) {
                if (confirm(`題庫「${name}」已存在，是否要覆蓋？`)) {
                    questionBanks[existingIndex] = { name: name, content: content };
                } else {
                    return;
                }
            } else {
                questionBanks.push({ name: name, content: content });
            }

            updateQuestionBankList();
            showMessage(`題庫「${name}」儲存成功`, 'success');
            nameInput.value = ''; // Clear name input
        }

        function loadQuestionBankToTextarea(index) {
            if (index >= 0 && index < questionBanks.length) {
                const textarea = document.getElementById('custom-mc-questions-textarea');
                textarea.value = questionBanks[index].content;
                showMessage(`題庫「${questionBanks[index].name}」已載入到輸入框`, 'success');
            }
        }

        function deleteQuestionBank(index) {
            if (index >= 0 && index < questionBanks.length) {
                const bankName = questionBanks[index].name;
                if (confirm(`確定要刪除題庫「${bankName}」嗎？`)) {
                    questionBanks.splice(index, 1);
                    updateQuestionBankList();
                    showMessage(`題庫「${bankName}」已刪除`, 'success');
                }
            }
        }

        // Make functions globally accessible for onclick handlers
        window.loadQuestionBankToTextarea = loadQuestionBankToTextarea;
        window.deleteQuestionBank = deleteQuestionBank;

        function clearAllQuestionBanks() {
            questionBanks = [];
            updateQuestionBankList();

            // Clear reading comprehension question banks
            readingQuestionBanks = [];
            localStorage.removeItem('readingQuestionBanks');
            updateReadingBankList();
        }

        // ==================== Sequencing Question Bank Functions ====================

        function updateSequencingBankList() {
            const list = document.getElementById('seq-bank-list');
            if (sequencingQuestionBanks.length === 0) {
                list.innerHTML = '<div class="text-gray-500 text-sm italic text-center">目前沒有儲存的題庫</div>';
            } else {
                list.innerHTML = sequencingQuestionBanks.map((bank, index) => `
                    <div class="flex items-center justify-between p-2 bg-gray-50 rounded border">
                        <span class="text-sm font-medium text-gray-700">${bank.name}</span>
                        <div class="flex gap-2">
                            <button onclick="loadSequencingBankToTextarea(${index})" class="px-2 py-1 bg-blue-500 hover:bg-blue-600 text-white text-xs rounded">載入</button>
                            <button onclick="deleteSequencingBank(${index})" class="px-2 py-1 bg-red-500 hover:bg-red-600 text-white text-xs rounded">刪除</button>
                        </div>
                    </div>
                `).join('');
            }
        }

        function loadSequencingBankFromFile() {
            const fileInput = document.getElementById('seq-bank-file-input');
            const file = fileInput.files[0];

            if (!file) {
                showMessage('請選擇一個txt檔案', 'error');
                return;
            }

            if (!file.name.toLowerCase().endsWith('.txt')) {
                showMessage('只能上傳txt格式的檔案', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const fileName = file.name.replace('.txt', '');
                const lines = content.split('\n').map(line => line.trim()).filter(line => line);

                if (lines.length < 2) {
                    showMessage('題庫格式錯誤：至少需要2個排序項目', 'error');
                    return;
                }

                const question = '排序題';
                const items = lines.join('\n');

                const existingIndex = sequencingQuestionBanks.findIndex(bank => bank.name === fileName);
                if (existingIndex !== -1) {
                    if (confirm(`題庫「${fileName}」已存在，是否要覆蓋？`)) {
                        sequencingQuestionBanks[existingIndex] = { name: fileName, question: question, items: items };
                    } else {
                        return;
                    }
                } else {
                    sequencingQuestionBanks.push({ name: fileName, question: question, items: items });
                }

                updateSequencingBankList();
                showMessage(`題庫「${fileName}」載入成功`, 'success');
                fileInput.value = '';
            };

            reader.onerror = function() {
                showMessage('讀取檔案時發生錯誤', 'error');
            };

            reader.readAsText(file, 'UTF-8');
        }

        function saveSequencingBank() {
            const nameInput = document.getElementById('seq-bank-name-input');
            const itemsTextarea = document.getElementById('sequencing-items-textarea');

            const name = nameInput.value.trim();
            const question = '排序題';
            const items = itemsTextarea.value.trim();

            if (!name) {
                showMessage('請輸入題庫名稱', 'error');
                return;
            }

            if (!items) {
                showMessage('排序項目不能為空', 'error');
                return;
            }

            const existingIndex = sequencingQuestionBanks.findIndex(bank => bank.name === name);
            if (existingIndex !== -1) {
                if (confirm(`題庫「${name}」已存在，是否要覆蓋？`)) {
                    sequencingQuestionBanks[existingIndex] = { name: name, question: question, items: items };
                } else {
                    return;
                }
            } else {
                sequencingQuestionBanks.push({ name: name, question: question, items: items });
            }

            updateSequencingBankList();
            showMessage(`題庫「${name}」儲存成功`, 'success');
            nameInput.value = '';
        }

        function loadSequencingBankToTextarea(index) {
            if (index >= 0 && index < sequencingQuestionBanks.length) {
                const bank = sequencingQuestionBanks[index];
                document.getElementById('sequencing-items-textarea').value = bank.items;
                showMessage(`題庫「${bank.name}」已載入到輸入框`, 'success');
            }
        }

        function deleteSequencingBank(index) {
            if (index >= 0 && index < sequencingQuestionBanks.length) {
                const bankName = sequencingQuestionBanks[index].name;
                if (confirm(`確定要刪除題庫「${bankName}」嗎？`)) {
                    sequencingQuestionBanks.splice(index, 1);
                    updateSequencingBankList();
                    showMessage(`題庫「${bankName}」已刪除`, 'success');
                }
            }
        }

        // ==================== Matching Question Bank Functions ====================

        function updateMatchingBankList() {
            const list = document.getElementById('match-bank-list');
            if (matchingQuestionBanks.length === 0) {
                list.innerHTML = '<div class="text-gray-500 text-sm italic text-center">目前沒有儲存的題庫</div>';
            } else {
                list.innerHTML = matchingQuestionBanks.map((bank, index) => `
                    <div class="flex items-center justify-between p-2 bg-gray-50 rounded border">
                        <span class="text-sm font-medium text-gray-700">${bank.name}</span>
                        <div class="flex gap-2">
                            <button onclick="loadMatchingBankToTextarea(${index})" class="px-2 py-1 bg-blue-500 hover:bg-blue-600 text-white text-xs rounded">載入</button>
                            <button onclick="deleteMatchingBank(${index})" class="px-2 py-1 bg-red-500 hover:bg-red-600 text-white text-xs rounded">刪除</button>
                        </div>
                    </div>
                `).join('');
            }
        }

        function loadMatchingBankFromFile() {
            const fileInput = document.getElementById('match-bank-file-input');
            const file = fileInput.files[0];

            if (!file) {
                showMessage('請選擇一個txt檔案', 'error');
                return;
            }

            if (!file.name.toLowerCase().endsWith('.txt')) {
                showMessage('只能上傳txt格式的檔案', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const fileName = file.name.replace('.txt', '');
                const lines = content.split('\n').map(line => line.trim()).filter(line => line);

                if (lines.length < 2) {
                    showMessage('題庫格式錯誤：至少需要2組配對項目', 'error');
                    return;
                }

                const question = '配對題';
                const pairs = lines.join('\n');

                const existingIndex = matchingQuestionBanks.findIndex(bank => bank.name === fileName);
                if (existingIndex !== -1) {
                    if (confirm(`題庫「${fileName}」已存在，是否要覆蓋？`)) {
                        matchingQuestionBanks[existingIndex] = { name: fileName, question: question, pairs: pairs };
                    } else {
                        return;
                    }
                } else {
                    matchingQuestionBanks.push({ name: fileName, question: question, pairs: pairs });
                }

                updateMatchingBankList();
                showMessage(`題庫「${fileName}」載入成功`, 'success');
                fileInput.value = '';
            };

            reader.onerror = function() {
                showMessage('讀取檔案時發生錯誤', 'error');
            };

            reader.readAsText(file, 'UTF-8');
        }

        function saveMatchingBank() {
            const nameInput = document.getElementById('match-bank-name-input');
            const pairsTextarea = document.getElementById('matching-pairs-textarea');

            const name = nameInput.value.trim();
            const question = '配對題';
            const pairs = pairsTextarea.value.trim();

            if (!name) {
                showMessage('請輸入題庫名稱', 'error');
                return;
            }

            if (!pairs) {
                showMessage('配對項目不能為空', 'error');
                return;
            }

            const existingIndex = matchingQuestionBanks.findIndex(bank => bank.name === name);
            if (existingIndex !== -1) {
                if (confirm(`題庫「${name}」已存在，是否要覆蓋？`)) {
                    matchingQuestionBanks[existingIndex] = { name: name, question: question, pairs: pairs };
                } else {
                    return;
                }
            } else {
                matchingQuestionBanks.push({ name: name, question: question, pairs: pairs });
            }

            updateMatchingBankList();
            showMessage(`題庫「${name}」儲存成功`, 'success');
            nameInput.value = '';
        }

        function loadMatchingBankToTextarea(index) {
            if (index >= 0 && index < matchingQuestionBanks.length) {
                const bank = matchingQuestionBanks[index];
                document.getElementById('matching-pairs-textarea').value = bank.pairs;
                showMessage(`題庫「${bank.name}」已載入到輸入框`, 'success');
            }
        }

        function deleteMatchingBank(index) {
            if (index >= 0 && index < matchingQuestionBanks.length) {
                const bankName = matchingQuestionBanks[index].name;
                if (confirm(`確定要刪除題庫「${bankName}」嗎？`)) {
                    matchingQuestionBanks.splice(index, 1);
                    updateMatchingBankList();
                    showMessage(`題庫「${bankName}」已刪除`, 'success');
                }
            }
        }

        // Make functions globally accessible
        window.loadSequencingBankToTextarea = loadSequencingBankToTextarea;
        window.deleteSequencingBank = deleteSequencingBank;
        window.loadMatchingBankToTextarea = loadMatchingBankToTextarea;
        window.deleteMatchingBank = deleteMatchingBank;

        /**
         * Hides the custom message box.
         */
        function hideMessage() {
            document.getElementById('message-box').classList.add('hidden');
        }

        // --- Firebase Functions ---
        /**
         * NEW: (Teacher) Announces the drawn student to Firestore.
         * @param {string} studentName - The name of the student who was drawn.
         */
        async function announceDrawnStudent(studentName) {
            if (!classroomCode) return;
            const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
            try {
                await setDoc(controlRef, {
                    lastDrawnStudent: {
                        name: studentName,
                        timestamp: new Date() // 使用新 Date 物件來確保每次都能觸發監聽
                    }
                }, { merge: true });
            } catch (error) {
                console.error("Failed to announce drawn student:", error);
                showMessage("宣布抽籤結果失敗。", "error");
            }
        }
        /**
         * (Teacher) Sets the current interaction mode and clears old student response data.
         * @param {string} mode - 'true_false', 'multiple_choice', 'text_input', 'drawing', 'url_dispatch', 'recording', or 'waiting'.
         * @param {object} [options={}] - Optional settings for the mode, e.g., custom questions.
         */
        async function setInteractionMode(mode, options = {}) {
            console.log(`[Teacher] Setting mode to: ${mode}, forceReset: ${options.forceReset || false}`);
            currentInteractionMode = mode; 
            // Use classroomCode in the Firestore path
            const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
            const showStatisticsBtn = document.getElementById('show-statistics-btn');
            
            // 🚀 NEW: Setup teacher answer listener for matching and sequencing modes
            if (mode === 'matching' || mode === 'sequencing') {
                setupTeacherAnswerListener();
            }
            const downloadMediaBtn = document.getElementById('download-media-btn');
            const aiTextSummaryBtn = document.getElementById('ai-text-summary-btn');
            const showUnsubmittedStudentsBtn = document.getElementById('show-unsubmitted-students-btn'); // NEW
            const viewQuestionsBtn = document.getElementById('view-questions-btn'); // NEW
            const viewReadingQuestionsBtn = document.getElementById('view-reading-questions-btn'); // NEW
            const downloadResponsesBtn = document.getElementById('download-responses-btn'); // NEW
            const showMatchingAnswerBtn = document.getElementById('show-matching-answer-btn'); // NEW
            const showSequencingAnswerBtn = document.getElementById('show-sequencing-answer-btn'); // NEW

            // MODIFIED: Show statistics button for true_false, multiple_choice, and reading_comprehension
            showStatisticsBtn.classList.toggle('hidden', mode !== 'true_false' && mode !== 'multiple_choice' && mode !== 'reading_comprehension');
            
            // NEW: Show answer buttons for matching and sequencing modes
            showMatchingAnswerBtn.classList.toggle('hidden', mode !== 'matching');
            showSequencingAnswerBtn.classList.toggle('hidden', mode !== 'sequencing');

            // NEW: Show view questions button only for multiple_choice with custom questions
            const hasCustomQuestions = mode === 'multiple_choice' && options.customQuestions && options.customQuestions.length > 0;
            viewQuestionsBtn.classList.toggle('hidden', !hasCustomQuestions);

            // NEW: Show view reading questions button only for reading_comprehension
            viewReadingQuestionsBtn.classList.toggle('hidden', mode !== 'reading_comprehension');
            
            // NEW: Show peer review button only for text_input and drawing modes
            const startPeerReviewBtn = document.getElementById('start-peer-review-btn');
            startPeerReviewBtn.classList.toggle('hidden', mode !== 'text_input' && mode !== 'drawing');
            
            // NEW: Reset peer review button state when starting new interaction
            if (mode !== 'waiting') {
                peerReviewActive = false;
                startPeerReviewBtn.innerHTML = '<i class="fas fa-heart mr-2"></i> 開始互評 ❤️';
                document.getElementById('peer-review-stats-container').classList.add('hidden');
                
                // Reset peer review status in Firebase for new interaction
                const peerReviewRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'peerReview');
                setDoc(peerReviewRef, { active: false }).catch(error => {
                    console.error('Error resetting peer review status:', error);
                });
                
                // Clear student voting history for new interaction
                studentVotedWorks.clear();
                
                // Clear saved canvas state for new interaction
                savedCanvasState = null;
            }
            downloadMediaBtn.classList.toggle('hidden', mode !== 'drawing' && mode !== 'recording');
            aiTextSummaryBtn.classList.toggle('hidden', mode !== 'text_input');
            // NEW: Show unsubmitted students button for specific modes
            showUnsubmittedStudentsBtn.classList.toggle('hidden', mode === 'waiting' || mode === 'url_dispatch');
            // NEW: Show download responses button for text_input, multiple_choice with custom questions, and reading_comprehension
            const showDownloadBtn = mode === 'text_input' || (mode === 'multiple_choice' && hasCustomQuestions) || mode === 'reading_comprehension';
            downloadResponsesBtn.classList.toggle('hidden', !showDownloadBtn);


            // NEW: Hide pause button for URL/HTML dispatch modes
            const togglePauseBtn = document.getElementById('toggle-pause-btn');
            togglePauseBtn.classList.toggle('hidden', mode === 'url_dispatch');


            try {
                // Clear previous student responses unless it's a waiting state.
                if (mode !== 'waiting') {
                    const studentsColRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses');
                    const querySnapshot = await getDocs(studentsColRef);
                    const deletePromises = [];
                    querySnapshot.forEach((doc) => {
                        deletePromises.push(deleteDoc(doc.ref));
                    });
                    await Promise.all(deletePromises);
                    console.log("[Teacher] Cleared all previous student responses.");
                    lastSelectedStudentCard = null; // Clear highlight on monitor view
                }

                // Prepare data payload for Firestore.
                const payload = { 
                    active_mode: mode,
                    backgroundImage: teacherUploadedBackgroundImageDataURL || null,
                    teacherId: userId, // Store teacher ID
                    isPaused: isResponsePaused, // Use current local pause state
                    lastDrawnStudent: null, // <-- 在此新增 (清除上次抽籤紀錄)
                    showMatchingAnswer: false, // Reset matching answer display
                    showSequencingAnswer: false, // Reset sequencing answer display
                    // 🚀 NEW: Force UI reset with monotonic token when options.forceReset is true
                    modeResetToken: options.forceReset ? Date.now() : (window.lastModeResetToken || 0)
                };
                
                // Store the token globally for comparison
                window.lastModeResetToken = payload.modeResetToken;

                // MODIFIED: Add combined dispatch settings if in that mode.
                if (mode === 'url_dispatch') {
                    payload.dispatchSettings = dispatchSettings; // Send the entire dispatchSettings object
                } else {
                    payload.dispatchSettings = null; // Clear dispatch settings if not in URL_DISPATCH mode
                }

                // NEW: Add custom multiple choice questions if in that mode.
                // If mode is multiple_choice and options.customQuestions is explicitly null, it means no custom questions.
                if (mode === 'multiple_choice' && options.hasOwnProperty('customQuestions')) {
                    payload.multiple_choice_questions = options.customQuestions;
                } else {
                    payload.multiple_choice_questions = null; // Clear if not multiple_choice mode or if customQuestions not provided
                }
                currentMultipleChoiceQuestions = payload.multiple_choice_questions; // Update global for teacher monitor

                // NEW: Add sequencing settings if in that mode
                if (mode === 'sequencing' && options.question && options.correctOrder) {
                    payload.sequencingSettings = {
                        question: options.question,
                        correctOrder: options.correctOrder
                    };
                } else {
                    payload.sequencingSettings = null;
                }

                // NEW: Add matching settings if in that mode
                if (mode === 'matching' && options.question && options.pairs) {
                    payload.matchingSettings = {
                        question: options.question,
                        pairs: options.pairs
                    };
                } else {
                    payload.matchingSettings = null;
                }

                // NEW: Add reading comprehension data if in that mode
                if (mode === 'reading_comprehension' && options.readingData) {
                    payload.readingComprehensionData = options.readingData;
                } else {
                    payload.readingComprehensionData = null;
                }

                await setDoc(controlRef, payload, { merge: true });

                // Handle student responses listener based on mode
                if (studentResponsesUnsubscribe) {
                    studentResponsesUnsubscribe();
                    studentResponsesUnsubscribe = null;
                }

                if (mode === 'url_dispatch') { // Now handles both URL and HTML
                    // For URL/HTML dispatch, listen to student submissions for real-time distraction updates
                    listenToStudentSubmissions(mode);
                } else if (mode === 'waiting') {
                    // When going to 'waiting' mode, ensure the student responses container is cleared
                    // and shows the "waiting" message.
                    document.getElementById('student-responses-container').innerHTML = '<p class="text-gray-500 text-center col-span-full">正在等待學生作答...</p>';
                } else { // For other interaction modes (true_false, multiple_choice, text_input, drawing, recording, quick_answer)
                    listenToStudentSubmissions(mode); // Ensure this listener is active
                }

            } catch (error) {
                console.error("設定互動模式或清除學生資料失敗:", error);
                showMessage("操作失敗，請檢查網路連線或聯繫管理員。", "error");
            }
        }

        /**
         * NEW: (Student) Displays the lottery winner in an overlay.
         * @param {string} winnerName - The name of the student who was drawn.
         */
         function showLotteryWinner(winnerName) {
            // 檢查是否已存在一個抽籤結果的畫面
            let overlay = document.getElementById('lottery-winner-overlay');
            if (overlay) overlay.remove(); // 移除舊的

            overlay = document.createElement('div');
            overlay.id = 'lottery-winner-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                animation: fadeIn 0.5s ease-in-out;
            `;

            // 檢查是否為自己被抽中
            const isWinner = (winnerName === studentName);
            const winnerMessage = isWinner ? "恭喜你被抽中了！" : `抽中了： ${winnerName}`;
            const iconColor = isWinner ? '#4ade80' : '#60a5fa'; // 綠色 (自己) 或 藍色 (別人)

            overlay.innerHTML = `
                <div style="text-align: center; color: white; font-size: 3rem; font-weight: bold;">
                    <i class="fas fa-dice" style="color: ${iconColor}; font-size: 6rem; margin-bottom: 20px;"></i>
                    <h1 style="margin: 20px 0; color: white;">${winnerMessage}</h1>
                    <p style="font-size: 1.5rem; color: #d1d5db;">點擊任意位置關閉</p>
                </div>
                <style>
                    @keyframes fadeIn {
                        from { opacity: 0; transform: scale(0.8); }
                        to { opacity: 1; transform: scale(1); }
                    }
                </style>
            `;

            overlay.addEventListener('click', () => {
                overlay.remove();
            });

            document.body.appendChild(overlay);

            // 5 秒後自動關閉
            setTimeout(() => {
                if (overlay.parentElement) {
                    overlay.remove();
                }
            }, 5000);
        }

        /**
         * NEW: (Student) Listens for lottery results from the teacher.
         * 🚀 OPTIMIZED: 使用 ListenerManager 管理監聽器
         */
        function listenToLottery() {
            const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
            let lastTimestamp = null; // 用於防止重複顯示同一個抽籤結果

            const unsubscribe = onSnapshot(controlRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    const drawnStudent = data.lastDrawnStudent;

                    if (drawnStudent && drawnStudent.name) {
                        // 轉換 Firestore 時間戳
                        const eventTimestamp = drawnStudent.timestamp?.toMillis(); 
                        
                        // 檢查這是否是一個新的抽籤事件
                        if (eventTimestamp && eventTimestamp !== lastTimestamp) {
                            lastTimestamp = eventTimestamp;
                            
                            // 🚀 FIX: 移除搶答模式的限制，讓所有模式都能顯示抽籤結果
                            console.log('[Lottery] Showing lottery winner:', drawnStudent.name);
                            showLotteryWinner(drawnStudent.name);
                        }
                    }
                }
            });
            
            // 使用 ListenerManager 註冊監聽器
            ListenerManager.register('lottery', unsubscribe);
            // 同時保留舊變數以保持兼容性
            lotteryUnsubscribe = unsubscribe;
        }

        /**
         * NEW: (Student) Monitors student attention by detecting page visibility changes and window blur/focus events.
         * When student switches tabs or navigates away, their distraction status is updated in Firebase.
         */
        async function startStudentAttentionMonitoring() {
            if (!studentName || !userId || !classroomCode) {
                console.warn('[Attention] Cannot start monitoring: student info not set');
                return;
            }

            // 防止重複註冊監聽器
            if (attentionMonitoringActive) {
                console.log('[Attention] Monitoring already active, skipping duplicate registration');
                return;
            }

            console.log('[Attention] Starting student attention monitoring for:', studentName);
            
            // 初始化狀態變量（先設置，確保事件監聽器可以使用）
            isStudentCurrentlyDistracted = false;
            studentDistractionCount = 0;
            attentionMonitoringActive = true;

            // 更新分心狀態到 Firebase
            const updateDistractionStatus = async (isDistracted) => {
                try {
                    // 🚀 FIX: 寫入 presence 集合，而不是 studentResponses 集合
                    const presenceRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'presence', userId);
                    
                    if (isDistracted && !isStudentCurrentlyDistracted) {
                        // 學生剛開始分心
                        studentDistractionCount++;
                        isStudentCurrentlyDistracted = true;
                        
                        await setDoc(presenceRef, {
                            name: studentName,
                            isDistracted: true,
                            distractionCount: studentDistractionCount,
                            lastDistractionTime: new Date(),
                            timestamp: new Date()
                        }, { merge: true });
                        
                        console.log(`[Attention] ✅ Student ${studentName} is distracted (count: ${studentDistractionCount})`);
                        console.log(`[Attention] Firebase presence updated with isDistracted: true`);
                    } else if (!isDistracted && isStudentCurrentlyDistracted) {
                        // 學生回到頁面
                        isStudentCurrentlyDistracted = false;
                        
                        await setDoc(presenceRef, {
                            name: studentName,
                            isDistracted: false,
                            distractionCount: studentDistractionCount,
                            returnTime: new Date(),
                            timestamp: new Date()
                        }, { merge: true });
                        
                        console.log(`[Attention] ✅ Student ${studentName} returned to page`);
                        console.log(`[Attention] Firebase presence updated with isDistracted: false`);
                    } else {
                        console.log(`[Attention] No state change - isDistracted: ${isDistracted}, current: ${isStudentCurrentlyDistracted}`);
                    }
                } catch (error) {
                    console.error('[Attention] ❌ Failed to update distraction status:', error);
                }
            };

            // 監聽頁面可見性變化（分頁切換）- Chrome/Edge/Firefox 支援
            document.addEventListener('visibilitychange', () => {
                const hidden = document.hidden;
                console.log(`[Attention] 📋 visibilitychange event - document.hidden: ${hidden}`);
                if (hidden) {
                    console.log('[Attention] 🔴 Page hidden - student switched tab or minimized window');
                    updateDistractionStatus(true);
                } else {
                    console.log('[Attention] 🟢 Page visible - student returned to tab');
                    updateDistractionStatus(false);
                }
            });

            // 監聽視窗失焦/獲得焦點（切換到其他應用程式）
            window.addEventListener('blur', () => {
                console.log('[Attention] 🔴 Window blur - student switched to another window');
                updateDistractionStatus(true);
            });

            window.addEventListener('focus', () => {
                console.log('[Attention] 🟢 Window focus - student returned to window');
                updateDistractionStatus(false);
            });

            // 🚀 FIX: 初始化 presence 文檔，確保學生剛加入時就能被教師端監控
            try {
                const presenceRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'presence', userId);
                await setDoc(presenceRef, {
                    name: studentName,
                    isDistracted: false,
                    distractionCount: 0,
                    joinTime: new Date(),
                    timestamp: new Date()
                }, { merge: true });
                
                console.log(`[Attention] ✅ Initialized presence monitoring for ${studentName}`);
                console.log(`[Attention] 📊 Initial state - isDistracted: false, count: 0`);
            } catch (error) {
                console.error('[Attention] ❌ Failed to initialize presence monitoring:', error);
            }
        }

        /**
         * (Student) Listens for changes in the teacher's interaction mode and switches the student interface accordingly.
         * 🚀 OPTIMIZED: 使用 ListenerManager 管理監聽器
         */
        function listenToInteractionMode() {
            // Use classroomCode in the Firestore path
            const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control'); 

            interactionModeUnsubscribe = onSnapshot(controlRef, async (docSnap) => {
                const studentPauseOverlay = document.getElementById('student-pause-overlay');
                const interactionMultipleChoice = document.getElementById('interaction-multiple-choice'); // Get the MC container

                if (!docSnap.exists()) {
                    // Teacher has ended the class session (control document deleted)
                    console.log("[Student] Teacher has ended the class session.");
                    classroomCode = null; // Clear student's classroom code
                    studentName = null; // Clear student's name
                    document.getElementById('user-id-display').textContent = userId; // Reset user ID display
                    showMessage('老師已結束課程，請重新選擇角色。', 'info');
                    showView('entry'); // Go back to the initial entry screen
                    // Unsubscribe from student responses and presence if they were active
                    if (studentResponsesUnsubscribe) {
                        studentResponsesUnsubscribe();
                        studentResponsesUnsubscribe = null;
                    }
                    // IMPORTANT: Unsubscribe student's presence listener as well when class ends
                    if (classroomPresenceUnsubscribe) {
                        classroomPresenceUnsubscribe();
                        classroomPresenceUnsubscribe = null;
                    }
                    studentPauseOverlay.classList.add('hidden'); // Hide overlay if class ends
                    currentInteractionMode = null; // Reset global mode for student
                    isResponsePaused = false; // Reset global pause state for student
                    attentionMonitoringActive = false; // Reset attention monitoring flag
                    studentDistractionCount = 0; // Reset distraction count
                    isStudentCurrentlyDistracted = false; // Reset distraction state
                    return; // Exit the function as the session is over
                }

                const data = docSnap.data();
                const newMode = data.active_mode || 'waiting';
                const newIsResponsePaused = data.isPaused || false;
                const newBackgroundImage = data.backgroundImage || null;
                const newMultipleChoiceQuestions = data.multiple_choice_questions || null;
                const newResetTimestamp = data.resetTimestamp || null;
                const newModeResetToken = data.modeResetToken || 0;

                // Determine if the interaction mode itself has changed
                const modeChanged = (currentInteractionMode !== newMode);
                // Determine if the pause state has changed within the same mode
                const pauseStateChanged = (currentInteractionMode === newMode && isResponsePaused !== newIsResponsePaused);
                // Determine if we are resuming from a pause (mode is same, was paused, now not paused)
                const isResumingFromPause = (currentInteractionMode === newMode) && isResponsePaused && !newIsResponsePaused;
                // 🎯 NEW: Determine if teacher clicked "Reset Answers" button
                const resetRequested = (window.lastResetTimestamp !== newResetTimestamp && newResetTimestamp !== null);
                // 🚀 NEW: Determine if teacher forced a mode reset (e.g., quick answer restart)
                const modeResetTokenChanged = (window.lastStudentModeResetToken !== newModeResetToken && newModeResetToken !== 0);


                // Update global states *before* acting on them
                currentInteractionMode = newMode;
                isResponsePaused = newIsResponsePaused;
                teacherUploadedBackgroundImageDataURL = newBackgroundImage; // Update teacher background image
                currentMultipleChoiceQuestions = newMultipleChoiceQuestions; // Update custom MC questions
                window.lastResetTimestamp = newResetTimestamp; // Track reset timestamp
                window.lastStudentModeResetToken = newModeResetToken; // Track mode reset token


                console.log(`[Student] Detected mode: ${currentInteractionMode}, Paused: ${isResponsePaused}, Mode Changed: ${modeChanged}, pauseStateChanged: ${pauseStateChanged}, resetRequested: ${resetRequested}, modeResetTokenChanged: ${modeResetTokenChanged}`);

                if (currentInteractionMode === 'waiting') {
                    showView('studentWaiting');
                    studentPauseOverlay.classList.add('hidden'); // Hide overlay in waiting view
                } else {
                    showView('studentInteraction');

                    // Call showInteractionUI if mode changed OR token changed OR if this is the first time entering this mode
                    // We determine "first time" by checking if any interaction UI is currently visible
                    const anyUIVisible = Object.values(interactionUIs).some(ui => !ui.classList.contains('hidden'));

                    if (modeChanged || modeResetTokenChanged || !anyUIVisible) {
                        console.log(`[Student] Calling showInteractionUI (modeChanged: ${modeChanged}, tokenChanged: ${modeResetTokenChanged}, firstTime: ${!anyUIVisible})`);
                        
                        // 🚀 FIX: Unsubscribe old quick answer listener when restarting
                        if (modeResetTokenChanged && currentInteractionMode === 'quick_answer' && quickAnswerUnsubscribe) {
                            console.log('[Student] Unsubscribing old quick answer listener before restart');
                            quickAnswerUnsubscribe();
                            quickAnswerUnsubscribe = null;
                        }
                        
                        showInteractionUI(currentInteractionMode, false); // Not resuming from pause if mode changed
                    }
                    // If mode hasn't changed and a UI is already visible, we don't need to call showInteractionUI
                    // This preserves the DOM state (including content) during pause/resume

                    // 🎯 NEW: If teacher clicked "Reset Answers", reset student UI state
                    if (resetRequested && currentInteractionMode !== 'waiting') {
                        console.log('[Student] Teacher reset all answers, resetting UI state');
                        resetStudentUIState(currentInteractionMode, false);
                    }

                    console.log('[Student] Setting pause overlay, isResponsePaused:', isResponsePaused);
                    if (isResponsePaused) {
                        studentPauseOverlay.classList.remove('hidden');
                        toggleStudentInteractionElements(true); // Disable elements if paused
                    } else {
                        studentPauseOverlay.classList.add('hidden');
                        toggleStudentInteractionElements(false); // Enable elements if not paused
                    }

                    // Specific UI updates that need to happen on every snapshot change
                    if (currentInteractionMode === 'drawing') {
                        requestAnimationFrame(() => {
                            // BUG FIX: Only call setupCanvas (which resizes and clears the drawing canvas)
                            // when the mode truly changes to 'drawing'.
                            // On other updates (like pause/resume or background image change),
                            // we only need to reload images and redraw the combined canvas,
                            // preserving the student's existing drawing.
                            if (modeChanged) {
                                setupCanvas();
                            }
                            loadBackgroundImage(); // Reload background in case teacher changed it
                            loadStudentImage();    // Reload student-uploaded image
                            drawCombinedCanvas();  // Redraw all layers
                        });
                    } else if (currentInteractionMode === 'url_dispatch') { // This mode now handles both URL and HTML
                        const currentDispatchSettings = data.dispatchSettings; // Get the combined settings
                        if (currentDispatchSettings) {
                            if (currentDispatchSettings.type === 'url' && currentDispatchSettings.url) {
                                displayDispatchedUrl(currentDispatchSettings);
                            } else if (currentDispatchSettings.type === 'html' && currentDispatchSettings.htmlContent) {
                                displayDispatchedHtml(currentDispatchSettings.htmlContent);
                            }
                        }
                    } else if (currentInteractionMode === 'multiple_choice') { // NEW: Handle custom multiple choice questions
                        await renderMultipleChoiceQuestions(currentMultipleChoiceQuestions);
                        // Apply/remove enlarged-buttons class based on whether custom questions exist
                        if (!currentMultipleChoiceQuestions || currentMultipleChoiceQuestions.length === 0) {
                            interactionMultipleChoice.classList.add('enlarged-buttons');
                        } else {
                            interactionMultipleChoice.classList.remove('enlarged-buttons');
                        }
                    } else if (currentInteractionMode === 'sequencing') {
                        const sequencingSettings = data.sequencingSettings;
                        const showSequencingAnswer = data.showSequencingAnswer || false;
                        console.log('[Student] Sequencing mode detected, settings:', sequencingSettings, 'showAnswer:', showSequencingAnswer, 'modeChanged:', modeChanged);
                        if (sequencingSettings) {
                            // 🚀 FIX: 智能變更檢測 - 只在設置真的改變時才重新渲染UI
                            // 這樣可以：
                            // 1. 支持晚加入的學生和頁面刷新
                            // 2. 避免在其他快照更新時清空學生的進度
                            const settingsChanged = JSON.stringify(sequencingSettings) !== JSON.stringify(lastSequencingSettings);
                            console.log('[Student] Sequencing settings changed:', settingsChanged);
                            
                            if (settingsChanged) {
                                console.log('[Student] Setting up sequencing UI with new data:', sequencingSettings);
                                setupSequencingUI(sequencingSettings);
                                lastSequencingSettings = JSON.parse(JSON.stringify(sequencingSettings)); // Deep clone
                            } else {
                                console.log('[Student] Sequencing settings unchanged, keeping current UI');
                            }
                            
                            // 🚀 NEW: 顯示正確答案的順序，或在重新開始時恢復原始介面
                            if (showSequencingAnswer && !window.lastShowSequencingAnswer) {
                                // 狀態從 false 變為 true：顯示答案
                                console.log('[Student] Showing sequencing correct answers');
                                displaySequencingCorrectAnswers(sequencingSettings);
                            } else if (!showSequencingAnswer && window.lastShowSequencingAnswer) {
                                // 狀態從 true 變為 false：重新開始，恢復原始介面
                                console.log('[Student] Resetting sequencing UI (teacher clicked reset)');
                                setupSequencingUI(sequencingSettings);
                            }
                            window.lastShowSequencingAnswer = showSequencingAnswer;
                        } else {
                            console.warn('[Student] Sequencing mode active but no settings provided');
                            lastSequencingSettings = null;
                        }
                    } else if (currentInteractionMode === 'matching') {
                        const matchingSettings = data.matchingSettings;
                        const showMatchingAnswer = data.showMatchingAnswer || false;
                        console.log('[Student] Matching mode detected, settings:', matchingSettings, 'showAnswer:', showMatchingAnswer, 'modeChanged:', modeChanged);
                        if (matchingSettings) {
                            // 🚀 FIX: 智能變更檢測 - 只在設置真的改變時才重新渲染UI
                            // 這樣可以：
                            // 1. 支持晚加入的學生和頁面刷新
                            // 2. 避免在其他快照更新時清空學生的進度
                            const settingsChanged = JSON.stringify(matchingSettings) !== JSON.stringify(lastMatchingSettings);
                            console.log('[Student] Matching settings changed:', settingsChanged);
                            
                            if (settingsChanged) {
                                console.log('[Student] Setting up matching UI with new data:', matchingSettings);
                                setupMatchingUI(matchingSettings);
                                lastMatchingSettings = JSON.parse(JSON.stringify(matchingSettings)); // Deep clone
                            } else {
                                console.log('[Student] Matching settings unchanged, keeping current UI');
                            }
                            
                            // 🚀 NEW: 顯示正確答案的連線，或在重新開始時恢復原始介面
                            if (showMatchingAnswer && !window.lastShowMatchingAnswer) {
                                // 狀態從 false 變為 true：顯示答案
                                console.log('[Student] Showing matching correct answers');
                                // 🚀 FIX: Wait for DOM to be ready before displaying answers
                                (async () => {
                                    try {
                                        await waitForMatchingDomReady(matchingSettings);
                                        displayMatchingCorrectAnswers(matchingSettings);
                                    } catch (error) {
                                        console.error('[Student] Failed to display matching answers:', error);
                                        showMessage('無法顯示配對答案，DOM未準備好。', 'error');
                                    }
                                })();
                            } else if (!showMatchingAnswer && window.lastShowMatchingAnswer) {
                                // 狀態從 true 變為 false：重新開始，恢復原始介面
                                console.log('[Student] Resetting matching UI (teacher clicked reset)');
                                setupMatchingUI(matchingSettings);
                            }
                            window.lastShowMatchingAnswer = showMatchingAnswer;
                        } else {
                            console.warn('[Student] Matching mode active but no settings provided');
                            lastMatchingSettings = null;
                        }
                    } else if (currentInteractionMode === 'reading_comprehension') {
                        const readingData = data.readingComprehensionData;
                        // 🚀 FIX: 只在模式改變或從暫停恢復時重新渲染，暫停時不要清空學生的選項
                        // 移除 pauseStateChanged 條件，因為暫停只是阻止提交，不應該清空UI
                        if (readingData && (modeChanged || isResumingFromPause)) {
                            console.log('[Student] Displaying reading comprehension, modeChanged:', modeChanged, 'isResumingFromPause:', isResumingFromPause);
                            displayReadingComprehensionForStudent(readingData);
                            // Only reset submit button if mode changed (not when resuming from pause)
                            if (modeChanged) {
                                document.getElementById('submit-reading-btn').disabled = false;
                            }
                        }
                        // 啟動排行榜監聽（如果尚未啟動）
                        if (modeChanged) {
                            listenToReadingLeaderboard();
                        }
                    } else if (currentInteractionMode === 'quick_poll') {
                        if (modeChanged) {
                            listenToQuickPollConfig();
                        }
                    }
                }
            }, (error) => {
                console.error("[Student] Error listening to interaction mode:", error);
                // This error might indicate a network issue or permission denied, not necessarily class end.
                // So, keep the student in waiting view or current view, and just show an error.
                showMessage("無法接收老師指令，請檢查網路連線。", "error");
            });
            
            // 🚀 OPTIMIZED: 使用 ListenerManager 註冊監聽器
            ListenerManager.register('interactionMode', interactionModeUnsubscribe);
        }
        
        /**
         * (Student) Updates the reading leaderboard display based on current student responses.
         * 🚀 HELPER: 排行榜渲染邏輯，可被監聽器和手動調用共用
         */
        function updateReadingLeaderboardDisplay(studentsData) {
            const leaderboardContainer = document.getElementById('reading-leaderboard');
            const leaderboardList = document.getElementById('reading-leaderboard-list');
            
            if (!leaderboardContainer || !leaderboardList) {
                console.warn('[Leaderboard] DOM elements not found');
                return;
            }
            
            const questions = readingComprehensionData.questions;
            
            // 只在有題目時顯示排行榜
            if (!questions || questions.length === 0) {
                leaderboardContainer.classList.add('hidden');
                return;
            }
            
            const rankedStudents = [];
            
            // 計算每個學生的正確率
            studentsData.forEach(student => {
                if (student.answer) {
                    try {
                        const studentAnswers = JSON.parse(student.answer);
                        let correctCount = 0;
                        studentAnswers.forEach((ans, index) => {
                            if (questions[index] && ans === questions[index].correctAnswer) {
                                correctCount++;
                            }
                        });
                        const accuracy = Math.round((correctCount / questions.length) * 100);
                        rankedStudents.push({
                            name: student.name,
                            correctCount: correctCount,
                            totalQuestions: questions.length,
                            accuracy: accuracy,
                            timestamp: student.timestamp // 🚀 NEW: 保存提交時間戳用於排序
                        });
                    } catch (e) {
                        // 答案格式錯誤，不加入排名
                        console.warn('[Leaderboard] Invalid answer format for student:', student.name);
                    }
                }
            });
            
            // 🚀 FIX: 排序邏輯 - 正確數降序 → 提交時間升序（先交卷排名更高） → 姓名升序
            rankedStudents.sort((a, b) => {
                // 1. 主要排序：正確數高的在前
                if (b.correctCount !== a.correctCount) {
                    return b.correctCount - a.correctCount;
                }
                // 2. 次要排序：提交時間早的在前（同分時先交卷排名更高）
                if (a.timestamp && b.timestamp) {
                    const timeA = a.timestamp.toMillis ? a.timestamp.toMillis() : new Date(a.timestamp).getTime();
                    const timeB = b.timestamp.toMillis ? b.timestamp.toMillis() : new Date(b.timestamp).getTime();
                    if (timeA !== timeB) {
                        return timeA - timeB;
                    }
                }
                // 3. 最後排序：姓名字母順序
                return a.name.localeCompare(b.name);
            });
            
            // 只顯示前十名
            const top10 = rankedStudents.slice(0, 10);
            
            if (top10.length > 0) {
                leaderboardContainer.classList.remove('hidden');
                leaderboardList.innerHTML = '';
                
                top10.forEach((student, index) => {
                    const rank = index + 1;
                    let badgeClass = 'bg-gray-100 text-gray-700 border-gray-300';
                    let icon = '';
                    let rankText = `第${rank}名`;
                    
                    if (rank === 1) {
                        badgeClass = 'bg-yellow-100 text-yellow-700 border-yellow-300';
                        icon = '🥇';
                        rankText = '';
                    } else if (rank === 2) {
                        badgeClass = 'bg-gray-200 text-gray-700 border-gray-400';
                        icon = '🥈';
                        rankText = '';
                    } else if (rank === 3) {
                        badgeClass = 'bg-orange-100 text-orange-700 border-orange-300';
                        icon = '🥉';
                        rankText = '';
                    } else if (rank <= 5) {
                        badgeClass = 'bg-blue-100 text-blue-700 border-blue-300';
                        icon = '🏅';
                        rankText = `第${rank}名`;
                    } else {
                        badgeClass = 'bg-purple-50 text-purple-600 border-purple-200';
                        icon = '⭐';
                        rankText = `第${rank}名`;
                    }
                    
                    const card = document.createElement('div');
                    card.className = `${badgeClass} border-2 rounded-lg p-2 sm:p-3 text-center transition-all hover:scale-105 hover:shadow-md`;
                    card.innerHTML = `
                        <div class="text-2xl sm:text-3xl mb-1">${icon}</div>
                        <div class="font-bold text-xs sm:text-sm truncate mb-1">${student.name}</div>
                        ${rankText ? `<div class="text-xs font-semibold mb-1">${rankText}</div>` : ''}
                        <div class="text-xs sm:text-sm font-medium">${student.correctCount}/${student.totalQuestions}</div>
                        <div class="text-xs text-gray-600">${student.accuracy}%</div>
                    `;
                    leaderboardList.appendChild(card);
                });
            } else {
                // 🚀 FIX: 清空排行榜並隱藏容器，防止顯示舊數據
                leaderboardList.innerHTML = '';
                leaderboardContainer.classList.add('hidden');
            }
        }
        
        /**
         * (Student) Listens to all student responses and displays the top 10 leaderboard for reading comprehension.
         * 🚀 NEW: 閱讀測驗排行榜監聽
         * ✨ OPTIMIZED: 使用全域 readingComprehensionData，由 listenToInteractionMode 更新
         * 
         * 實作說明：
         * - listenToInteractionMode 已經監聽 control 文檔並更新 readingComprehensionData
         * - 本函數只需監聽 studentResponses 集合，使用已經更新的全域變數
         * - 當題目更新時，listenToInteractionMode 會重新調用 displayReadingComprehensionForStudent
         * - 這樣可以避免重複監聽同一個文檔，減少 Firestore 讀取
         */
        function listenToReadingLeaderboard() {
            if (!classroomCode) {
                console.warn('[Leaderboard] Classroom code not set');
                return;
            }
            
            // 如果已經有監聽器，先註銷
            if (ListenerManager.has('readingLeaderboard')) {
                console.log('[Leaderboard] Already listening, skipping');
                return;
            }
            
            const studentsColRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses');
            
            const unsubscribe = onSnapshot(studentsColRef, (querySnapshot) => {
                const studentsData = [];
                querySnapshot.forEach(doc => {
                    studentsData.push(doc.data());
                });
                updateReadingLeaderboardDisplay(studentsData);
            }, (error) => {
                console.error('[Leaderboard] Error listening:', error);
            });
            
            ListenerManager.register('readingLeaderboard', unsubscribe);
            console.log('[Leaderboard] Started listening for reading comprehension leaderboard');
        }
        
        /**
         * (Student) Displays the dispatched URL or YouTube video.
         * @param {object} settings - The URL settings object from Firestore.
         */
        function displayDispatchedUrl(settings) {
            const container = interactionUIs.url_dispatch;
            container.innerHTML = ''; // Clear previous content

            if (settings.isYoutube) {
                const videoId = getYouTubeVideoId(settings.url);
                console.log('YouTube URL:', settings.url, 'Video ID:', videoId); // 調試信息
                if (videoId) {
                    const embedContainer = document.createElement('div');
                    embedContainer.className = 'youtube-embed-container';
                    
                    // 添加載入中的提示
                    embedContainer.innerHTML = `<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center;">
                        <i class="fas fa-spinner fa-spin text-2xl mb-2"></i><br>
                        影片載入中...
                    </div>`;
                    
                    const embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0&showinfo=0&modestbranding=1`;
                    console.log('Embed URL:', embedUrl); // 調試信息
                    
                    // 創建iframe元素
                    const iframe = document.createElement('iframe');
                    iframe.src = embedUrl;
                    iframe.frameBorder = '0';
                    iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
                    iframe.allowFullscreen = true;
                    iframe.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0;';
                    
                    // 載入完成後移除載入提示
                    iframe.onload = function() {
                        const loadingDiv = embedContainer.querySelector('div');
                        if (loadingDiv) loadingDiv.remove();
                    };
                    
                    // 錯誤處理
                    iframe.onerror = function() {
                        embedContainer.innerHTML = `<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center;">
                            <i class="fas fa-exclamation-triangle text-2xl mb-2"></i><br>
                            影片載入失敗
                        </div>`;
                    };
                    
                    embedContainer.appendChild(iframe);
                    container.appendChild(embedContainer);
                } else {
                    console.error('無效的 YouTube 網址:', settings.url); // 調試信息
                    container.innerHTML = `<p class="text-red-500">無效的 YouTube 網址。</p>`;
                }
            } else {
                const card = document.createElement('a');
                card.className = 'url-card';
                card.href = settings.url;
                card.target = '_blank';
                card.rel = 'noopener noreferrer';
                card.innerHTML = `
                    <i class="fas fa-external-link-alt url-card-icon"></i>
                    <p class="url-card-text">老師分享了一個連結</p>
                    <p class="url-card-link">${settings.url}</p>
                `;
                container.appendChild(card);
            }
        }

        /**
         * NEW: (Student) Displays the dispatched HTML content in an iframe.
         * @param {string} htmlContent - The HTML content to display.
         */
        function displayDispatchedHtml(htmlContent) {
            const container = interactionUIs.url_dispatch; // Use the same container
            container.innerHTML = ''; // Clear previous content
            
            const iframe = document.createElement('iframe');
            iframe.id = 'html-content-iframe'; // Re-use the ID for consistency if needed, but it's internal to this function now
            iframe.sandbox = 'allow-scripts allow-same-origin allow-popups allow-forms';
            iframe.srcdoc = htmlContent;
            iframe.style.cssText = 'width: 100vw; height: 100vh; margin: 0; padding: 0; border: none; background-color: white; display: block;';
            container.appendChild(iframe);

            // Add status indicator
            const statusIndicator = document.createElement('div');
            statusIndicator.className = 'html-dispatch-indicator';
            statusIndicator.textContent = '教師派送html中...';
            container.appendChild(statusIndicator);

            // Apply the specific HTML dispatch container styles to the outer container
            container.style.cssText = 'position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; margin: 0; padding: 0; border: none; overflow: hidden; background-color: white; z-index: 1000;';
        }

        /**
         * Extracts YouTube video ID from various URL formats.
         * @param {string} url - The YouTube URL.
         * @returns {string|null} The video ID or null if not found.
         */
        function getYouTubeVideoId(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }


        /**
         * (Student) Submits the answer to Firestore.
         * @param {string | object} answer - The student's answer.
         * @returns {Promise<boolean>} Returns true if successful, false if failed
         */
        async function submitAnswer(answer, extraFields = {}) {
            // NEW: Prevent submission if paused
            if (isResponsePaused) {
                showMessage('老師已暫停回覆，無法送出答案。', 'error');
                throw new Error('Response is paused');
            }

            if (!studentName || !userId || !classroomCode) {
                console.error("Student name, User ID, or Classroom Code not set. Cannot submit answer.");
                showMessage("學生姓名、用戶ID或教室代碼未設定，無法送出答案。", "error");
                throw new Error('Student info not set');
            }
            // Use classroomCode in the Firestore path
            const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
            try {
                 await setDoc(studentRef, { 
                    name: studentName,
                    answer: answer,
                    interactionMode: currentInteractionMode, // 🎯 CRITICAL FIX: 儲存互動模式，讓 resetStudentUIState 能正確檢查提交狀態
                    timestamp: new Date(),
                    ...extraFields // 🔥 NEW: Allow adding extra fields like modeResetToken
                }, { merge: true });
                console.log(`[Student] ${studentName} submitted answer:`, answer, 'mode:', currentInteractionMode, 'extraFields:', extraFields);
                return true;
            } catch (error) {
                console.error("送出答案失敗:", error);
                showMessage("送出答案失敗，請檢查網路連線。", "error");
                throw error;
            }
        }
        
        /**
         * 🚀 NEW: (Teacher) 創建單個學生卡片（統一的卡片生成邏輯，支持所有9種互動模式）
         * @param {Object} student - 學生數據
         * @param {HTMLElement} container - 學生卡片容器
         * @param {string} mode - 當前互動模式
         * @param {Array} rankedStudents - 排名數據（閱讀測驗模式使用）
         */
        function createStudentCard(student, container, mode, rankedStudents = []) {
            const card = document.createElement('div');
            card.className = 'student-response-item';
            card.setAttribute('data-student-name', student.name);

            let answerContentHTML = '';
            
            // 處理所有模式的答案顯示
            if (mode === 'url_dispatch') {
                // URL dispatch mode: show online indicator
                answerContentHTML = `<i class="fas fa-check-circle text-green-500 text-2xl"></i>`;
            } else if (student.answer === null || student.answer === undefined) {
                // 學生未提交答案（所有模式通用）
                answerContentHTML = `<p class="text-gray-400">尚未作答</p>`;
            } else if (mode === 'drawing') {
                // 繪圖模式
                if (String(student.answer).startsWith('data:image')) {
                    answerContentHTML = `<img src="${student.answer}" alt="${student.name} 的繪圖" class="w-full h-auto rounded-md border max-h-32 object-contain cursor-pointer" data-full-image="${student.answer}"/>`;
                } else {
                    answerContentHTML = `<p class="text-gray-500">繪圖未完成或格式錯誤</p>`;
                }
            } else if (mode === 'recording') {
                // 錄音模式
                if (String(student.answer).startsWith('data:audio')) {
                    answerContentHTML = `<audio controls src="${student.answer}" class="w-full"></audio>`;
                } else {
                    answerContentHTML = `<p class="text-gray-500">錄音未完成或格式錯誤</p>`;
                }
            } else if (mode === 'text_input') {
                // 文字輸入模式
                answerContentHTML = `<p class="text-gray-700 whitespace-pre-wrap">${student.answer || '(空白)'}</p>`;
            } else if (mode === 'multiple_choice' && Array.isArray(student.answer) && currentMultipleChoiceQuestions) {
                // 自訂選擇題模式
                answerContentHTML = `<div class="flex flex-col w-full">`;
                student.answer.forEach((qAns, index) => {
                    const question = currentMultipleChoiceQuestions[qAns.qIndex];
                    if (question) {
                        const isCorrect = (String(qAns.ans) === String(question.correctAnswer));
                        answerContentHTML += `
                            <div class="mc-question-answer">
                                <i class="icon fas ${isCorrect ? 'fa-check-circle correct-icon' : 'fa-times-circle incorrect-icon'}"></i>
                                <span class="question-text">Q${qAns.qIndex + 1}:</span>
                                <span class="student-choice">${qAns.ans}</span>
                            </div>
                        `;
                    }
                });
                answerContentHTML += `</div>`;
            } else if (mode === 'quick_answer') {
                // 搶答模式
                if (student.answer && student.answer.includes('搶答成功')) {
                    answerContentHTML = `<div class="text-center">
                        <i class="fas fa-trophy text-yellow-500 text-4xl mb-2"></i>
                        <p class="text-xl font-bold text-green-600">搶答成功！</p>
                        <p class="text-lg text-gray-600">第一名</p>
                    </div>`;
                } else {
                    answerContentHTML = `<p class="text-gray-500">未搶答或搶答失敗</p>`;
                }
            } else if (mode === 'sequencing') {
                // 排序題模式
                try {
                    const studentOrder = JSON.parse(student.answer);
                    const correctOrder = sequencingData.correctOrder;
                    let isCorrect = true;

                    answerContentHTML = `<div class="flex flex-col w-full gap-1">`;
                    studentOrder.forEach((item, index) => {
                        const correct = correctOrder[index] === item;
                        if (!correct) isCorrect = false;
                        answerContentHTML += `
                            <div class="flex items-center gap-2 text-sm">
                                <i class="fas ${correct ? 'fa-check-circle text-green-500' : 'fa-times-circle text-red-500'}"></i>
                                <span class="font-bold">${index + 1}.</span>
                                <span>${item}</span>
                            </div>
                        `;
                    });
                    answerContentHTML += `</div>`;
                } catch (e) {
                    answerContentHTML = `<p class="text-gray-500">答案格式錯誤</p>`;
                }
            } else if (mode === 'matching') {
                // 配對題模式
                try {
                    const studentMatches = JSON.parse(student.answer);
                    const correctPairs = matchingData.pairs;
                    let correctCount = 0;

                    answerContentHTML = `<div class="flex flex-col w-full gap-1">`;
                    studentMatches.forEach(match => {
                        const correctPair = correctPairs.find(p => p.left === match.left);
                        const isCorrect = correctPair && correctPair.right === match.right;
                        if (isCorrect) correctCount++;

                        answerContentHTML += `
                            <div class="flex items-center gap-2 text-xs">
                                <i class="fas ${isCorrect ? 'fa-check-circle text-green-500' : 'fa-times-circle text-red-500'}"></i>
                                <span>${match.left}</span>
                                <i class="fas fa-arrow-right text-gray-400"></i>
                                <span>${match.right}</span>
                            </div>
                        `;
                    });
                    answerContentHTML += `<div class="text-xs text-gray-600 mt-1">正確: ${correctCount}/${studentMatches.length}</div></div>`;
                } catch (e) {
                    answerContentHTML = `<p class="text-gray-500">答案格式錯誤</p>`;
                }
            } else if (mode === 'reading_comprehension') {
                // 閱讀測驗模式
                try {
                    const studentAnswers = JSON.parse(student.answer);
                    const questions = readingComprehensionData.questions;
                    let correctCount = 0;

                    answerContentHTML = `<div class="flex flex-col w-full" style="font-size: 10px; gap: 1px;">`;
                    studentAnswers.forEach((ans, index) => {
                        if (questions[index]) {
                            const isCorrect = (ans === questions[index].correctAnswer);
                            if (isCorrect) correctCount++;

                            answerContentHTML += `
                                <div class="flex items-center whitespace-nowrap" style="gap: 4px; line-height: 1.3;">
                                    <i class="fas ${isCorrect ? 'fa-check-circle text-green-500' : 'fa-times-circle text-red-500'}" style="font-size: 11px;"></i>
                                    <span class="font-bold" style="min-width: 22px;">Q${index + 1}</span>
                                    <span class="text-gray-700" style="min-width: 32px;">答:${ans || '未'}</span>
                                    ${!isCorrect && ans > 0 ? `<span class="text-gray-500" style="font-size: 9px;">(正確:${questions[index].correctAnswer})</span>` : ''}
                                </div>
                            `;
                        }
                    });
                    
                    // 計算正確率和排名
                    const accuracy = Math.round((correctCount / questions.length) * 100);
                    const rankInfo = rankedStudents.find(r => r.name === student.name);
                    const rank = rankInfo ? rankedStudents.indexOf(rankInfo) + 1 : null;
                    
                    // 排名徽章顏色
                    let rankBadgeClass = 'bg-gray-100 text-gray-700';
                    let rankIcon = '';
                    if (rank === 1) {
                        rankBadgeClass = 'bg-yellow-100 text-yellow-700';
                        rankIcon = '🥇 ';
                    } else if (rank === 2) {
                        rankBadgeClass = 'bg-gray-200 text-gray-700';
                        rankIcon = '🥈 ';
                    } else if (rank === 3) {
                        rankBadgeClass = 'bg-orange-100 text-orange-700';
                        rankIcon = '🥉 ';
                    } else if (rank <= 5) {
                        rankBadgeClass = 'bg-blue-100 text-blue-700';
                        rankIcon = '🏅 ';
                    }
                    
                    const rankBadge = rank ? `<span class="px-1.5 py-0.5 ${rankBadgeClass} text-xs font-bold rounded ml-1">${rankIcon}第${rank}名</span>` : '';
                    
                    answerContentHTML += `<div class="font-bold mt-1 pt-1 border-t flex items-center justify-between ${correctCount === questions.length ? 'text-green-600' : 'text-gray-700'}" style="font-size: 10px;">
                        <span>正確: ${correctCount}/${questions.length} (${accuracy}%)</span>
                        ${rankBadge}
                    </div></div>`;
                } catch (e) {
                    answerContentHTML = `<p class="text-gray-500">答案格式錯誤</p>`;
                }
            } else {
                // 預設選擇題模式 (1-4)
                answerContentHTML = `<p class="text-2xl font-bold text-blue-600">${student.answer}</p>`;
            }
            
            // 從全局 presence Map 中讀取學生分心狀態（所有模式通用）
            const presenceData = activeStudentsPresenceMap.get(student.name) || { isDistracted: false, distractionCount: 0 };
            const isDistracted = presenceData.isDistracted;
            const distractionCount = presenceData.distractionCount;
            const distractionBadge = distractionCount > 0 
                ? `<span class="ml-1 px-1.5 py-0.5 bg-orange-100 text-orange-700 text-xs font-bold rounded">${distractionCount}次</span>` 
                : '';
            const distractionWarning = isDistracted 
                ? `<i class="fas fa-exclamation-triangle text-red-600 ml-1 animate-pulse" title="學生分心中"></i>` 
                : '';
            const cardBgClass = isDistracted ? 'bg-red-50 border-2 border-red-400' : '';
            
            card.className = `student-response-item ${cardBgClass}`;
            card.innerHTML = `
                <div class="name-box flex items-center justify-between">
                    <span>${student.name}</span>
                    <span class="flex items-center">${distractionWarning}${distractionBadge}</span>
                </div>
                <div class="answer-box">
                    ${answerContentHTML}
                </div>
            `;
            container.appendChild(card);
            
            // 特殊處理：繪圖模式添加點擊放大功能
            if (mode === 'drawing') {
                const imgElement = card.querySelector('.answer-box img');
                if (imgElement) {
                    imgElement.addEventListener('click', (e) => {
                        const fullImageUrl = e.target.dataset.fullImage;
                        showMagnifiedDrawing(fullImageUrl);
                    });
                }
            }
        }

        /**
         * (Teacher) Listens for all student submissions and dynamically displays them.
         * 🚀 OPTIMIZED: 使用 ListenerManager 管理監聽器
         * @param {string} mode - The current interaction mode, used to determine the answer type.
         */
        function listenToStudentSubmissions(mode) {
             // Use classroomCode in the Firestore path
             const studentsColRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses');
             const container = document.getElementById('student-responses-container');

             const unsubscribe = onSnapshot(studentsColRef, (querySnapshot) => {
                container.innerHTML = ''; 
                lastSelectedStudentCard = null; 
                
                // REMOVED: document.getElementById('responded-student-count').textContent = querySnapshot.size; 

                // 🚀 NEW: 為所有模式統一處理 - 顯示所有在線學生（包括未提交的）
                // 創建一個 Map 來快速查找已提交答案的學生
                const responsesMap = new Map();
                querySnapshot.forEach((doc) => {
                    const student = doc.data();
                    responsesMap.set(student.name, student);
                });
                
                // 為所有在線學生創建響應數組（包括未提交答案的）
                let responses = [];
                activeStudentNames.forEach(studentName => {
                    if (responsesMap.has(studentName)) {
                        // 學生已提交答案
                        responses.push(responsesMap.get(studentName));
                    } else {
                        // 學生未提交答案，創建佔位數據
                        responses.push({
                            name: studentName,
                            answer: null
                        });
                    }
                });
                
                // 🚀 FIX: 即使沒有學生在線，也要處理（清空容器）
                if (responses.length === 0) {
                    container.innerHTML = '<p class="text-gray-500 text-center col-span-full">沒有學生在線...</p>';
                    allStudentResponses = [];
                    clearStudentsByAnswerList();
                    return;
                }
                
                // 計算閱讀測驗排名（如果是閱讀測驗模式）
                let rankedStudents = [];
                if (mode === 'reading_comprehension' && readingComprehensionData.questions) {
                    responses.forEach(student => {
                        if (student.answer) {
                            try {
                                const studentAnswers = JSON.parse(student.answer);
                                const questions = readingComprehensionData.questions;
                                let correctCount = 0;
                                studentAnswers.forEach((ans, index) => {
                                    if (questions[index] && ans === questions[index].correctAnswer) {
                                        correctCount++;
                                    }
                                });
                                const accuracy = Math.round((correctCount / questions.length) * 100);
                                rankedStudents.push({
                                    name: student.name,
                                    correctCount: correctCount,
                                    totalQuestions: questions.length,
                                    accuracy: accuracy,
                                    timestamp: student.timestamp // 🚀 NEW: 保存提交時間戳用於排序
                                });
                            } catch (e) {
                                // 答案格式錯誤，不加入排名
                            }
                        }
                    });
                    // 🚀 FIX: 排序邏輯 - 正確數降序 → 提交時間升序（先交卷排名更高） → 姓名升序
                    rankedStudents.sort((a, b) => {
                        // 1. 主要排序：正確數高的在前
                        if (b.correctCount !== a.correctCount) {
                            return b.correctCount - a.correctCount;
                        }
                        // 2. 次要排序：提交時間早的在前（同分時先交卷排名更高）
                        if (a.timestamp && b.timestamp) {
                            const timeA = a.timestamp.toMillis ? a.timestamp.toMillis() : new Date(a.timestamp).getTime();
                            const timeB = b.timestamp.toMillis ? b.timestamp.toMillis() : new Date(b.timestamp).getTime();
                            if (timeA !== timeB) {
                                return timeA - timeB;
                            }
                        }
                        // 3. 最後排序：姓名字母順序
                        return a.name.localeCompare(b.name);
                    });
                    
                    // 🚀 NEW: 重新排序 responses 數組：已提交的按排名，未提交的按姓名排在後面
                    const rankMap = new Map();
                    rankedStudents.forEach((student, index) => {
                        rankMap.set(student.name, index);
                    });
                    
                    responses.sort((a, b) => {
                        const hasAnswerA = a.answer !== null && a.answer !== undefined;
                        const hasAnswerB = b.answer !== null && b.answer !== undefined;
                        
                        // 已提交的排在前面
                        if (hasAnswerA && !hasAnswerB) return -1;
                        if (!hasAnswerA && hasAnswerB) return 1;
                        
                        // 都已提交：按排名
                        if (hasAnswerA && hasAnswerB) {
                            const rankA = rankMap.has(a.name) ? rankMap.get(a.name) : 9999;
                            const rankB = rankMap.has(b.name) ? rankMap.get(b.name) : 9999;
                            return rankA - rankB;
                        }
                        
                        // 都未提交：按姓名
                        return a.name.localeCompare(b.name);
                    });
                }
                
                // 🚀 NEW: 使用統一的卡片生成函數（支持所有9種模式，包含分心狀態監控）
                responses.forEach(student => {
                    createStudentCard(student, container, mode, rankedStudents);
                });

                allStudentResponses = responses;

                // Special handling for quick answer mode
                if (mode === 'quick_answer') {
                    console.log('Teacher: Processing quick answer responses:', responses);
                    const quickAnswerWinners = responses.filter(student =>
                        student.answer && student.answer.includes('搶答成功')
                    );
                    console.log('Teacher: Quick answer winners found:', quickAnswerWinners);

                    if (quickAnswerWinners.length > 0) {
                        const winner = quickAnswerWinners[0]; // First one to answer
                        console.log('Teacher: Showing winner:', winner.name);
                        showQuickAnswerWinner(winner.name);
                    }
                }

                if (!statisticsModal.classList.contains('hidden')) {
                    drawChart(allStudentResponses, currentInteractionMode);
                }
             }, (error) => {
                 console.error("[Teacher] Error listening to student submissions:", error);
                 showMessage("無法監聽學生作答，請檢查連線。", "error");
             });
             
             // 🚀 OPTIMIZED: 使用 ListenerManager 註冊監聽器
             ListenerManager.register('studentResponses', unsubscribe);
             studentResponsesUnsubscribe = unsubscribe; // 保持兼容性
        }

        /**
         * 🚀 NEW: (Teacher) 更新學生卡片的分心狀態顯示
         * 當 presence 數據更新時，同步更新主視圖中已渲染的學生卡片
         */
        function updateStudentCardsDistractionStatus() {
            const container = document.getElementById('student-responses-container');
            if (!container) return;
            
            // 找到所有學生卡片
            const studentCards = container.querySelectorAll('.student-response-item[data-student-name]');
            
            studentCards.forEach(card => {
                const studentName = card.getAttribute('data-student-name');
                if (!studentName) return;
                
                // 從 Map 中讀取分心狀態
                const presenceData = activeStudentsPresenceMap.get(studentName) || { isDistracted: false, distractionCount: 0 };
                const isDistracted = presenceData.isDistracted;
                const distractionCount = presenceData.distractionCount;
                
                // 更新卡片背景樣式
                if (isDistracted) {
                    card.classList.add('bg-red-50', 'border-2', 'border-red-400');
                } else {
                    card.classList.remove('bg-red-50', 'border-2', 'border-red-400');
                }
                
                // 🚀 FIX: 使用更穩健的方式更新分心指示器
                const nameBox = card.querySelector('.name-box');
                if (nameBox) {
                    // 重新構建整個 name-box 的 HTML（確保狀態正確）
                    const distractionWarning = isDistracted 
                        ? `<i class="fas fa-exclamation-triangle text-red-600 ml-1 animate-pulse" title="學生分心中"></i>` 
                        : '';
                    const distractionBadge = distractionCount > 0 
                        ? `<span class="ml-1 px-1.5 py-0.5 bg-orange-100 text-orange-700 text-xs font-bold rounded">${distractionCount}次</span>` 
                        : '';
                    
                    nameBox.innerHTML = `
                        <span>${studentName}</span>
                        <span class="flex items-center">${distractionWarning}${distractionBadge}</span>
                    `;
                }
            });
        }

        /**
         * (Teacher) Listens for student online presence and updates the active student count list.
         * This listener should be persistent as long as the teacher is in the classroom.
         * 🚀 OPTIMIZED: 使用 ListenerManager 管理監聽器
         */
        function listenToClassroomPresence() {
            // Only set up the listener if it's not already active
            if (ListenerManager.has('classroomPresence')) {
                console.log("Presence listener already active. Skipping re-subscription.");
                return;
            }

            if (!classroomCode) {
                console.warn("Classroom code not set, cannot listen to presence.");
                return;
            }

            const presenceColRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'presence');
            const activeStudentCountSpan = document.getElementById('active-student-count');
            const modalStudentNamesDiv = document.getElementById('modal-student-names');
            const monitorContainer = document.getElementById('student-responses-container');

            const unsubscribe = onSnapshot(presenceColRef, (querySnapshot) => {
                // 🚀 FIX: 儲存完整的學生數據（包含分心狀態），而不只是姓名
                const activeStudentsData = []; // 新增：儲存完整學生資料
                activeStudentNames = []; // 保持向後兼容
                activeStudentsPresenceMap.clear(); // 🚀 NEW: 清空舊數據
                
                querySnapshot.forEach(doc => {
                    const studentData = doc.data();
                    activeStudentNames.push(studentData.name);
                    activeStudentsData.push(studentData); // 儲存完整數據
                    // 🚀 NEW: 將完整的 presence 數據存入 Map（key: 學生名字, value: presence 數據）
                    activeStudentsPresenceMap.set(studentData.name, {
                        isDistracted: studentData.isDistracted === true,
                        distractionCount: studentData.distractionCount || 0
                    });
                });
                
                activeStudentCountSpan.textContent = activeStudentNames.length;

                // Update the student list modal with distraction status.
                modalStudentNamesDiv.innerHTML = ''; 
                if (lastSelectedModalStudent) { // Clear highlight in modal when list rebuilds
                    lastSelectedModalStudent.classList.remove('modal-selected-student-border');
                    lastSelectedModalStudent = null;
                }

                if (activeStudentsData.length === 0) {
                    modalStudentNamesDiv.innerHTML = '<p class="text-gray-500 text-sm col-span-full">沒有學生在線</p>';
                } else {
                    // 🚀 FIX: 按照姓名排序並顯示學生及其分心狀態
                    activeStudentsData.sort((a, b) => a.name.localeCompare(b.name)).forEach(student => {
                        const p = document.createElement('p');
                        p.className = 'flex items-center justify-between'; // 使用 flex 布局
                        p.setAttribute('data-student-name', student.name); // 🚀 FIX: 添加 data 屬性以便抽籤查找
                        
                        // 學生姓名容器
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = student.name;
                        
                        // 分心狀態容器
                        const statusContainer = document.createElement('span');
                        statusContainer.className = 'flex items-center gap-1';
                        
                        // 檢查分心狀態
                        const isDistracted = student.isDistracted === true;
                        const distractionCount = student.distractionCount || 0;
                        
                        // 添加分心次數徽章（如果有分心記錄）
                        if (distractionCount > 0) {
                            const badge = document.createElement('span');
                            badge.className = 'px-1.5 py-0.5 bg-orange-100 text-orange-700 text-xs font-bold rounded';
                            badge.textContent = `${distractionCount}次`;
                            statusContainer.appendChild(badge);
                        }
                        
                        // 添加當前分心警告圖標（如果正在分心）
                        if (isDistracted) {
                            const warning = document.createElement('i');
                            warning.className = 'fas fa-exclamation-triangle text-red-600 animate-pulse';
                            warning.title = '學生分心中';
                            statusContainer.appendChild(warning);
                        }
                        
                        p.appendChild(nameSpan);
                        p.appendChild(statusContainer);
                        modalStudentNamesDiv.appendChild(p);
                    });
                }

                // 🚀 FIX: 實時更新主視圖中學生卡片的分心狀態
                // 當 presence 更新時，手動更新已渲染的學生卡片
                updateStudentCardsDistractionStatus();
            }, (error) => {
                console.error("[Teacher] Error listening to classroom presence:", error);
                // If there's an error, maybe the listener broke, so clear it.
                ListenerManager.unregister('classroomPresence');
                classroomPresenceUnsubscribe = null;
                showMessage("無法監聽學生在線狀態，請檢查連線。", "error");
            });
            
            // 🚀 OPTIMIZED: 使用 ListenerManager 註冊監聽器
            ListenerManager.register('classroomPresence', unsubscribe);
            classroomPresenceUnsubscribe = unsubscribe; // 保持兼容性
        }

        /**
         * (Teacher) Manually refreshes the online student count and responded student count.
         */
        async function manualRefreshCounts() {
            if (!classroomCode) {
                console.warn("Classroom code not set, cannot manually refresh counts.");
                return;
            }
            // Use classroomCode in the Firestore path
            const presenceColRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'presence');
            try {
                const presenceSnapshot = await getDocs(presenceColRef);
                activeStudentNames = []; // Clear and re-populate
                presenceSnapshot.forEach(doc => activeStudentNames.push(doc.data().name));
                document.getElementById('active-student-count').textContent = activeStudentNames.length;
            } catch (error) {
                console.error("Manual refresh: Failed to get online student count:", error);
            }

            // Use classroomCode in the Firestore path
            const responsesColRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses');
            try {
                const responsesSnapshot = await getDocs(responsesColRef);
                // REMOVED: document.getElementById('responded-student-count').textContent = responsesSnapshot.size;
                
                const responsesData = [];
                responsesSnapshot.forEach(doc => responsesData.push(doc.data()));
                allStudentResponses = responsesData; 

                if (!statisticsModal.classList.contains('hidden')) {
                    drawChart(allStudentResponses, currentInteractionMode);
                }
                showMessage('統計數據已更新！', 'info');
            } catch (error) {
                console.error("Manual refresh: Failed to get responded student count:", error);
            }
        }


        // --- Magnified Drawing Modal Functions ---
        const magnifiedImageModal = document.getElementById('magnified-image-modal');
        const magnifiedImage = document.getElementById('magnified-image');
        const magnifiedImageModalCloseBtn = document.getElementById('magnified-image-modal-close-btn');

        function showMagnifiedDrawing(imageUrl) {
            magnifiedImage.src = imageUrl;
            magnifiedImageModal.classList.remove('hidden');
        }

        function hideMagnifiedDrawing() {
            magnifiedImageModal.classList.add('hidden');
            magnifiedImage.src = ''; 
        }

        // --- Student List Modal (Teacher Side) ---
        const studentListModal = document.getElementById('student-list-modal');
        const studentListModalCloseBtn = document.getElementById('student-list-modal-close-btn');

        function showStudentListModal() {
            studentListModal.classList.remove('hidden');
        }

        function hideStudentListModal() {
            studentListModal.classList.add('hidden');
            if (lastSelectedModalStudent) { // Clear highlight in modal when closing
                lastSelectedModalStudent.classList.remove('modal-selected-student-border');
                lastSelectedModalStudent = null;
            }
        }

        // --- NEW: Unsubmitted Students Modal Functions ---
        const unsubmittedStudentsModal = document.getElementById('unsubmitted-students-modal');
        const unsubmittedStudentsModalCloseBtn = document.getElementById('unsubmitted-students-modal-close-btn');
        const modalUnsubmittedStudentNamesDiv = document.getElementById('modal-unsubmitted-student-names');

        /**
         * Calculates the list of students who are active but have not submitted an answer.
         * @param {string[]} activeStudents - Array of names of all active students.
         * @param {Object[]} respondedStudents - Array of response objects from students.
         * @returns {string[]} Sorted array of names of unsubmitted students.
         */
        function getUnsubmittedStudents(activeStudents, respondedStudents) {
            // 只計算真正有提交答案的學生（answer 字段不為空）
            const respondedNames = new Set(
                respondedStudents
                    .filter(s => s.answer !== undefined && s.answer !== null && s.answer !== '')
                    .map(s => s.name)
            );
            return activeStudents.filter(name => !respondedNames.has(name)).sort();
        }

        /**
         * Displays the modal with the list of unsubmitted students.
         */
        function showUnsubmittedStudentsModal() {
            const unsubmittedNames = getUnsubmittedStudents(activeStudentNames, allStudentResponses);
            modalUnsubmittedStudentNamesDiv.innerHTML = '';
            if (unsubmittedNames.length === 0) {
                modalUnsubmittedStudentNamesDiv.innerHTML = '<p class="text-gray-500 text-sm col-span-full">所有學生皆已作答或無學生在線</p>';
            } else {
                unsubmittedNames.forEach(name => {
                    const p = document.createElement('p');
                    p.textContent = name;
                    p.className = 'bg-red-100 p-2 rounded-md text-center text-red-700 font-medium overflow-hidden text-ellipsis whitespace-nowrap';
                    modalUnsubmittedStudentNamesDiv.appendChild(p);
                });
            }
            unsubmittedStudentsModal.classList.remove('hidden');
        }

        /**
         * Hides the unsubmitted students modal.
         */
        function hideUnsubmittedStudentsModal() {
            unsubmittedStudentsModal.classList.add('hidden');
        }


        // --- Statistics Chart Modal (Teacher Side) ---
        const statisticsModal = document.getElementById('statistics-modal');
        const chartModalCloseBtn = document.getElementById('chart-modal-close-btn');
        const chartSvg = d3.select("#chart-svg");
        const studentsByAnswerListContainer = document.getElementById('students-by-answer-list-container');
        const studentsByAnswerListTitle = document.getElementById('students-by-answer-list-title');
        const studentsByAnswerNamesParagraph = document.getElementById('students-by-answer-names');


        function showStatisticsModal() {
            statisticsModal.classList.remove('hidden');
            drawChart(allStudentResponses, currentInteractionMode); 
        }

        function hideStatisticsModal() {
            statisticsModal.classList.add('hidden');
            chartSvg.selectAll("*").remove();
            clearStudentsByAnswerList();
        }

        function downloadStudentResponses() {
            if (!allStudentResponses || allStudentResponses.length === 0) {
                showMessage('目前沒有學生回應可以下載。', 'warning');
                return;
            }

            let csvData = [];
            let filename = '';
            
            if (currentInteractionMode === 'text_input') {
                // 文字題模式
                csvData.push('學生姓名,學生回應');
                
                allStudentResponses.forEach(student => {
                    const studentName = student.name || '未知學生';
                    let responseText = student.answer || '';
                    
                    // 清理回應文字中的換行符號和雙引號，避免影響CSV格式
                    responseText = responseText.replace(/[\r\n]/g, ' ').replace(/"/g, '""');
                    
                    // 如果內容包含逗號或雙引號，需要用雙引號包圍
                    if (responseText.includes(',') || responseText.includes('"') || responseText.includes('\n')) {
                        responseText = `"${responseText}"`;
                    }
                    
                    csvData.push(`${studentName},${responseText}`);
                });
                
                filename = generateFilename('學生回應', 'csv');
                
            } else if (currentInteractionMode === 'multiple_choice' && currentMultipleChoiceQuestions) {
                // 自訂選擇題模式
                
                // 第一部分：題目資訊
                csvData.push('=== 題目資訊 ===');
                csvData.push('題號,題目內容,選項A,選項B,選項C,選項D,正確答案');
                
                currentMultipleChoiceQuestions.forEach((question, index) => {
                    const questionText = `"${question.questionText.replace(/"/g, '""')}"`;
                    const optionA = `"${question.options[0].replace(/"/g, '""')}"`;
                    const optionB = `"${question.options[1].replace(/"/g, '""')}"`;
                    const optionC = `"${question.options[2].replace(/"/g, '""')}"`;
                    const optionD = `"${question.options[3].replace(/"/g, '""')}"`;
                    const correctAnswer = `選項${['A', 'B', 'C', 'D'][parseInt(question.correctAnswer) - 1]}`;
                    
                    csvData.push(`第${index + 1}題,${questionText},${optionA},${optionB},${optionC},${optionD},${correctAnswer}`);
                });
                
                // 空行分隔
                csvData.push('');
                
                // 第二部分：學生答題結果
                csvData.push('=== 學生答題結果 ===');
                
                // 建立表頭
                let header = '學生姓名';
                currentMultipleChoiceQuestions.forEach((_, index) => {
                    header += `,第${index + 1}題答案,第${index + 1}題結果`;
                });
                header += ',總分,總題數,正確率';
                csvData.push(header);
                
                // 建立每個學生的答題結果
                allStudentResponses.forEach(student => {
                    const studentName = student.name || '未知學生';
                    let row = studentName;
                    let correctCount = 0;
                    let totalQuestions = currentMultipleChoiceQuestions.length;
                    
                    if (Array.isArray(student.answer)) {
                        // 為每題加入答案和結果
                        currentMultipleChoiceQuestions.forEach((question, questionIndex) => {
                            const studentAnswer = student.answer.find(ans => ans.qIndex === questionIndex);
                            if (studentAnswer) {
                                const answerText = `選項${['A', 'B', 'C', 'D'][parseInt(studentAnswer.ans) - 1]}`;
                                const isCorrect = String(studentAnswer.ans) === String(question.correctAnswer);
                                const result = isCorrect ? '正確' : '錯誤';
                                if (isCorrect) correctCount++;
                                row += `,${answerText},${result}`;
                            } else {
                                row += ',未作答,錯誤';
                            }
                        });
                    } else {
                        // 如果學生沒有回答或格式不正確
                        currentMultipleChoiceQuestions.forEach(() => {
                            row += ',未作答,錯誤';
                        });
                    }
                    
                    // 加入統計資訊
                    const accuracy = totalQuestions > 0 ? ((correctCount / totalQuestions) * 100).toFixed(1) : '0.0';
                    row += `,${correctCount},${totalQuestions},${accuracy}%`;
                    
                    csvData.push(row);
                });
                
                filename = generateFilename('選擇題結果', 'csv');

            } else if (currentInteractionMode === 'reading_comprehension' && readingComprehensionData.questions) {
                // 閱讀測驗模式

                // 第一部分：文本內容
                csvData.push('=== 閱讀文本 ===');
                const readingText = `"${readingComprehensionData.text.replace(/"/g, '""')}"`;
                csvData.push(`文本內容,${readingText}`);
                csvData.push('');

                // 第二部分：題目資訊
                csvData.push('=== 題目資訊 ===');
                csvData.push('題號,PIRLS層次,題目內容,選項1,選項2,選項3,選項4,正確答案');

                readingComprehensionData.questions.forEach((question, index) => {
                    const levelNames = ['直接提取', '直接推論', '詮釋整合', '比較評估'];
                    const levelName = levelNames[question.level - 1] || '未分類';
                    const questionText = `"${question.question.replace(/"/g, '""')}"`;
                    const option1 = `"${question.options[0].replace(/"/g, '""')}"`;
                    const option2 = `"${question.options[1].replace(/"/g, '""')}"`;
                    const option3 = `"${question.options[2].replace(/"/g, '""')}"`;
                    const option4 = `"${question.options[3].replace(/"/g, '""')}"`;
                    const correctAnswer = `選項${question.correctAnswer}`;

                    csvData.push(`第${index + 1}題,${levelName},${questionText},${option1},${option2},${option3},${option4},${correctAnswer}`);
                });

                // 空行分隔
                csvData.push('');

                // 第三部分：學生答題結果
                csvData.push('=== 學生答題結果 ===');

                // 建立表頭
                let header = '學生姓名';
                readingComprehensionData.questions.forEach((_, index) => {
                    header += `,第${index + 1}題答案,第${index + 1}題結果`;
                });
                header += ',總分,總題數,正確率';
                csvData.push(header);

                // 建立每個學生的答題結果
                allStudentResponses.forEach(student => {
                    const studentName = student.name || '未知學生';
                    let row = studentName;
                    let correctCount = 0;
                    let totalQuestions = readingComprehensionData.questions.length;

                    try {
                        let studentAnswers = [];
                        if (typeof student.answer === 'string') {
                            studentAnswers = JSON.parse(student.answer);
                        } else if (Array.isArray(student.answer)) {
                            studentAnswers = student.answer;
                        }

                        // 為每題加入答案和結果
                        readingComprehensionData.questions.forEach((question, questionIndex) => {
                            const studentAnswer = studentAnswers[questionIndex];
                            if (studentAnswer && studentAnswer > 0) {
                                const answerText = `選項${studentAnswer}`;
                                const isCorrect = studentAnswer === question.correctAnswer;
                                const result = isCorrect ? '正確' : '錯誤';
                                if (isCorrect) correctCount++;
                                row += `,${answerText},${result}`;
                            } else {
                                row += ',未作答,錯誤';
                            }
                        });
                    } catch (e) {
                        // 如果解析失敗，全部標記為未作答
                        readingComprehensionData.questions.forEach(() => {
                            row += ',未作答,錯誤';
                        });
                    }

                    // 加入統計資訊
                    const accuracy = totalQuestions > 0 ? ((correctCount / totalQuestions) * 100).toFixed(1) : '0.0';
                    row += `,${correctCount},${totalQuestions},${accuracy}%`;

                    csvData.push(row);
                });

                filename = generateFilename('閱讀測驗結果', 'csv');

            } else {
                showMessage('目前模式不支援下載功能。', 'warning');
                return;
            }

            // 建立CSV內容
            const csvContent = csvData.join('\n');

            // 建立下載連結，加上BOM確保正確顯示中文
            const bom = '\uFEFF';
            const blob = new Blob([bom + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showMessage(`已下載學生回應檔案: ${filename}`, 'success');
        }

        // NEW: View Questions Modal Functions
        function showViewQuestionsModal() {
            if (!currentMultipleChoiceQuestions || currentMultipleChoiceQuestions.length === 0) {
                showMessage('目前沒有自訂題目可以查看。', 'info');
                return;
            }
            
            const modal = document.getElementById('view-questions-modal');
            const container = document.getElementById('questions-display-container');
            
            // 清空容器
            container.innerHTML = '';
            
            // 生成題目顯示HTML
            currentMultipleChoiceQuestions.forEach((question, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'bg-gray-50 p-4 rounded-lg border';
                questionDiv.innerHTML = `
                    <h5 class="font-bold text-lg mb-3">第 ${index + 1} 題</h5>
                    <p class="text-gray-800 mb-4">${question.questionText}</p>
                    <div class="space-y-2">
                        <p class="font-medium text-gray-700">選項：</p>
                        <div class="grid grid-cols-2 gap-2">
                            ${question.options.map((option, optIndex) => 
                                `<div class="p-2 bg-white rounded border text-sm">
                                    ${String.fromCharCode(65 + optIndex)}. ${option}
                                </div>`
                            ).join('')}
                        </div>
                    </div>
                    <div class="mt-4">
                        <label class="block text-sm font-medium text-gray-700 mb-2">正確答案：</label>
                        <select class="correct-answer-select w-full p-2 border rounded" data-question-index="${index}">
                            ${question.options.map((option, optIndex) => {
                                const optionValue = String.fromCharCode(65 + optIndex);
                                const isSelected = question.correctAnswer === optionValue || question.correctAnswer === (optIndex + 1).toString();
                                return `<option value="${optionValue}" ${isSelected ? 'selected' : ''}>${optionValue}. ${option}</option>`;
                            }).join('')}
                        </select>
                    </div>
                `;
                container.appendChild(questionDiv);
            });
            
            modal.classList.remove('hidden');
        }

        function hideViewQuestionsModal() {
            document.getElementById('view-questions-modal').classList.add('hidden');
        }

        async function saveCorrectAnswers() {
            if (!currentMultipleChoiceQuestions || currentMultipleChoiceQuestions.length === 0) {
                showMessage('沒有題目可以儲存。', 'error');
                return;
            }
            
            try {
                // 更新currentMultipleChoiceQuestions中的正確答案
                const selects = document.querySelectorAll('.correct-answer-select');
                selects.forEach(select => {
                    const questionIndex = parseInt(select.getAttribute('data-question-index'));
                    let newCorrectAnswer = select.value;
                    
                    // NEW: 將字母格式轉換為數字格式以保持一致性
                    if (newCorrectAnswer === 'A') newCorrectAnswer = '1';
                    else if (newCorrectAnswer === 'B') newCorrectAnswer = '2';
                    else if (newCorrectAnswer === 'C') newCorrectAnswer = '3';
                    else if (newCorrectAnswer === 'D') newCorrectAnswer = '4';
                    
                    if (currentMultipleChoiceQuestions[questionIndex]) {
                        currentMultipleChoiceQuestions[questionIndex].correctAnswer = newCorrectAnswer;
                    }
                });
                
                // 更新Firestore中的題目資料
                const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
                await updateDoc(controlRef, {
                    multiple_choice_questions: currentMultipleChoiceQuestions
                });
                
                // NEW: 等待一小段時間確保Firestore更新完成，然後觸發重新批改
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // NEW: 自動重新批改所有學生已提交的答案
                await regradeAllStudentAnswers();
                
                // NEW: 確保教師端UI使用最新的正確答案進行渲染
                // 由於重新批改會觸發Firebase監聽器，UI會自動重新渲染
                
                showMessage('正確答案已更新並重新批改所有作答！', 'success');
                hideViewQuestionsModal();
            } catch (error) {
                console.error('更新正確答案失敗:', error);
                showMessage('更新失敗，請稍後再試。', 'error');
            }
        }

        // NEW: 重新批改所有學生答案的函數
        async function regradeAllStudentAnswers() {
            if (!currentMultipleChoiceQuestions || currentMultipleChoiceQuestions.length === 0) {
                return;
            }

            try {
                const studentsColRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses');
                const querySnapshot = await getDocs(studentsColRef);
                
                const batch = writeBatch(db);
                let regradeCount = 0;

                querySnapshot.forEach((docSnapshot) => {
                    const studentData = docSnapshot.data();
                    
                    // 只處理選擇題的答案（Array格式）
                    if (Array.isArray(studentData.answer)) {
                        // 更新學生答案時間戳以觸發UI重新渲染（答案內容保持不變）
                        const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', docSnapshot.id);
                        batch.update(studentRef, {
                            regraded: true,
                            regradeTimestamp: new Date(),
                            timestamp: new Date(), // 更新時間戳以觸發監聽器重新評判答案
                            forceUpdate: Math.random() // 添加隨機數強制觸發監聽器
                        });
                        regradeCount++;
                    }
                });

                if (regradeCount > 0) {
                    await batch.commit();
                    console.log(`重新批改了 ${regradeCount} 位學生的答案`);
                }
            } catch (error) {
                console.error('重新批改答案失敗:', error);
                throw error;
            }
        }

        function clearStudentsByAnswerList() {
            studentsByAnswerListContainer.classList.add('hidden');
            studentsByAnswerListTitle.textContent = '';
            studentsByAnswerNamesParagraph.textContent = ''; 
        }

        function displayStudentsForAnswer(answer, mode, questionIndex = null) {
            clearStudentsByAnswerList();
            studentsByAnswerListContainer.classList.remove('hidden');

            let filteredStudents;
            let titleText;

            if (mode === 'multiple_choice' && questionIndex !== null && currentMultipleChoiceQuestions) {
                // For custom multiple choice, filter by specific question and correctness
                const question = currentMultipleChoiceQuestions[questionIndex];
                if (!question) {
                    studentsByAnswerListTitle.textContent = `問題 ${questionIndex + 1} 不存在。`;
                    studentsByAnswerNamesParagraph.textContent = '';
                    return;
                }
                
                // 'answer' here is 'correct' or 'incorrect'
                if (answer === 'correct') {
                    filteredStudents = allStudentResponses.filter(s => 
                        Array.isArray(s.answer) && 
                        s.answer.some(q => q.qIndex === questionIndex && String(q.ans) === String(question.correctAnswer))
                    );
                    titleText = `問題 ${questionIndex + 1} 答對的學生：`;
                } else if (answer === 'incorrect') {
                     filteredStudents = allStudentResponses.filter(s => 
                        Array.isArray(s.answer) && 
                        s.answer.some(q => q.qIndex === questionIndex && String(q.ans) !== String(question.correctAnswer))
                    );
                    titleText = `問題 ${questionIndex + 1} 答錯的學生：`;
                } else { // Should not happen with current chart logic
                    filteredStudents = [];
                    titleText = `問題 ${questionIndex + 1} 的學生：`;
                }
            } else {
                // For default multiple choice or true/false
                filteredStudents = allStudentResponses.filter(s => s.answer === answer);
                titleText = `選擇「${answer}」的學生：`;
            }

            const studentNames = filteredStudents.map(s => s.name).sort(); 
            studentsByAnswerListTitle.textContent = studentNames.length > 0 ? `${titleText} ${studentNames.join(', ')}` : `${titleText} 沒有學生選擇此答案。`;
            studentsByAnswerNamesParagraph.textContent = ''; // Clear this as the title now contains names
        }

        function drawChart(responses, mode) { // Changed parameter name from 'data' to 'responses' to avoid conflict
            chartSvg.selectAll("*").remove();
            clearStudentsByAnswerList();

            let chartData = {}; // Renamed 'data' to 'chartData'
            const filteredResponses = responses.filter(r => {
                if (mode === 'true_false' && (r.answer === 'O' || r.answer === 'X')) return true;
                if (mode === 'multiple_choice') {
                    if (currentMultipleChoiceQuestions) { // Custom MC
                        return Array.isArray(r.answer);
                    } else { // Default MC
                        return (r.answer >= '1' && r.answer <= '4');
                    }
                }
                if (mode === 'reading_comprehension') {
                    // Check if answer is a valid JSON array
                    try {
                        const parsed = JSON.parse(r.answer);
                        return Array.isArray(parsed);
                    } catch (e) {
                        return false;
                    }
                }
                return false;
            });

            const totalValidResponses = filteredResponses.length;

            if (totalValidResponses === 0) {
                chartSvg.append("text")
                    .attr("x", chartSvg.attr("width") / 2)
                    .attr("y", chartSvg.attr("height") / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .style("fill", "#666")
                    .text("目前沒有作答資料。");
                return;
            }

            if (mode === 'true_false') {
                chartData = { 'O': 0, 'X': 0 }; // Use chartData
                filteredResponses.forEach(r => { chartData[r.answer]++; });
                drawPieChart(chartData, totalValidResponses); // Pass chartData
            } else if (mode === 'multiple_choice') {
                if (currentMultipleChoiceQuestions) { // Custom Multiple Choice Chart
                    drawCustomMultipleChoiceBarChart(filteredResponses, currentMultipleChoiceQuestions);
                } else { // Default Multiple Choice Chart
                    chartData = { '1': 0, '2': 0, '3': 0, '4': 0 }; // Use chartData
                    filteredResponses.forEach(r => { chartData[r.answer]++; });
                    drawBarChart(chartData, totalValidResponses); // Pass chartData
                }
            } else if (mode === 'reading_comprehension') {
                if (readingComprehensionData && readingComprehensionData.questions) {
                    drawReadingComprehensionChart(filteredResponses, readingComprehensionData.questions);
                }
            }
        }

        function drawPieChart(data, totalValidResponses) {
            const width = +chartSvg.attr("width");
            const height = +chartSvg.attr("height");
            const radius = Math.min(width, height) / 2 - 20;
            const g = chartSvg.append("g").attr("transform", `translate(${width / 2},${height / 2})`);
            const color = d3.scaleOrdinal().domain(Object.keys(data)).range(['#16a34a', '#dc2626']); // Green for O, Red for X
            const pie = d3.pie().value(d => d[1]).sort(null);
            const arc = d3.arc().innerRadius(0).outerRadius(radius);
            const arcs = g.selectAll(".arc").data(pie(Object.entries(data))).enter().append("g").attr("class", "arc");

            arcs.append("path")
                .attr("d", arc) 
                .attr("fill", d => color(d.data[0])) 
                .attr("stroke", "white").style("stroke-width", "2px")
                .on("click", (event, d) => displayStudentsForAnswer(d.data[0], 'true_false')); 

            arcs.append("text")
                .attr("transform", d => `translate(${arc.centroid(d)})`)
                .attr("dy", "0.35em")
                .text(d => {
                    const percentage = totalValidResponses > 0 ? ((d.data[1] / totalValidResponses) * 100).toFixed(1) : 0;
                    return `${d.data[0]}: ${d.data[1]} (${percentage}%)`;
                }) 
                .style("font-size", "14px").style("text-anchor", "middle").style("fill", "white");
        }

        function drawBarChart(data, totalValidResponses) {
            const width = +chartSvg.attr("width") - 60;
            const height = +chartSvg.attr("height") - 60;
            const margin = {top: 20, right: 20, bottom: 30, left: 40};
            const x = d3.scaleBand().range([0, width]).padding(0.1).domain(Object.keys(data));
            const y = d3.scaleLinear().range([height, 0]).domain([0, d3.max(Object.values(data)) || 1]); 
            const color = d3.scaleOrdinal().domain(Object.keys(data)).range(['#2563eb', '#ca8a04', '#16a34a', '#dc2626']);
            const g = chartSvg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            g.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x));
            g.append("g").call(d3.axisLeft(y).ticks(Math.min(10, d3.max(Object.values(data)) || 1)).tickFormat(d3.format('d')));

            g.selectAll(".bar").data(Object.entries(data)).enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d[0]) + x.bandwidth() / 2) 
                .attr("y", d => y(d[1])) 
                .attr("width", x.bandwidth())
                .attr("height", d => height - y(d[1])) 
                .attr("fill", d => color(d[0]))
                .on("click", (event, d) => displayStudentsForAnswer(d[0], 'multiple_choice')); 
            
            g.selectAll(".bar-label").data(Object.entries(data)).enter().append("text")
                .attr("class", "bar-label")
                .attr("x", d => x(d[0]) + x.bandwidth() / 2) 
                .attr("y", d => y(d[1]) - 5) 
                .attr("text-anchor", "middle").style("font-size", "12px")
                .text(d => {
                    const percentage = totalValidResponses > 0 ? ((d[1] / totalValidResponses) * 100).toFixed(1) : 0;
                    return `${d[1]} (${percentage}%)`;
                }); 
        }

        /**
         * NEW: Draws a bar chart for custom multiple choice questions, showing correctness rate per question.
         * @param {Array} responses - All student responses.
         * @param {Array} questions - The custom multiple choice questions.
         */
        function drawCustomMultipleChoiceBarChart(responses, questions) {
            const width = +chartSvg.attr("width") - 60;
            const height = +chartSvg.attr("height") - 60;
            const margin = {top: 20, right: 20, bottom: 60, left: 40}; // Increased bottom margin for question labels
            
            const questionStats = questions.map((q, qIndex) => {
                let correctCount = 0;
                let answeredCount = 0; // Count students who attempted this question

                responses.forEach(studentResponse => {
                    if (Array.isArray(studentResponse.answer)) {
                        const studentQAnswer = studentResponse.answer.find(ans => ans.qIndex === qIndex);
                        if (studentQAnswer) {
                            answeredCount++;
                            if (String(studentQAnswer.ans) === String(q.correctAnswer)) {
                                correctCount++;
                            }
                        }
                    }
                });
                return {
                    questionIndex: qIndex,
                    questionText: `Q${qIndex + 1}`, // Display as Q1, Q2 etc.
                    correctCount: correctCount,
                    answeredCount: answeredCount,
                    correctRate: answeredCount > 0 ? (correctCount / answeredCount) * 100 : 0
                };
            });

            // Filter out questions with no attempts if desired, or show 0%
            const displayStats = questionStats.filter(s => s.answeredCount > 0);
            if (displayStats.length === 0) {
                chartSvg.append("text")
                    .attr("x", chartSvg.attr("width") / 2)
                    .attr("y", chartSvg.attr("height") / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .style("fill", "#666")
                    .text("目前沒有學生作答任何自訂選擇題。");
                return;
            }

            const x = d3.scaleBand()
                .range([0, width])
                .padding(0.2)
                .domain(displayStats.map(d => d.questionText));

            const y = d3.scaleLinear()
                .range([height, 0])
                .domain([0, 100]); // Percentage from 0 to 100

            const g = chartSvg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            // X-axis
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "rotate(-45)") // Rotate labels for readability
                .style("text-anchor", "end");

            // Y-axis
            g.append("g")
                .call(d3.axisLeft(y).ticks(10).tickFormat(d => `${d}%`));

            // Bars
            g.selectAll(".bar")
                .data(displayStats)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d.questionText))
                .attr("y", d => y(d.correctRate))
                .attr("width", x.bandwidth())
                .attr("height", d => height - y(d.correctRate))
                .attr("fill", "#2563eb") // A nice blue color
                .on("click", (event, d) => displayStudentsForAnswer('correct', 'multiple_choice', d.questionIndex)); // Click to show correct students

            // Labels on bars
            g.selectAll(".bar-label")
                .data(displayStats)
                .enter().append("text")
                .attr("class", "bar-label")
                .attr("x", d => x(d.questionText) + x.bandwidth() / 2)
                .attr("y", d => y(d.correctRate) - 5)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .text(d => `${d.correctRate.toFixed(1)}%`);

            // Y-axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("答對率 (%)");
        }

        /**
         * Draw reading comprehension statistics chart with PIRLS level analysis
         */
        function drawReadingComprehensionChart(responses, questions) {
            const width = +chartSvg.attr("width") - 60;
            const height = +chartSvg.attr("height") - 60;
            const margin = {top: 20, right: 20, bottom: 80, left: 60};

            // Calculate statistics for each question
            const questionStats = questions.map((q, qIndex) => {
                let correctCount = 0;
                let answeredCount = 0;

                responses.forEach(studentResponse => {
                    try {
                        const studentAnswers = JSON.parse(studentResponse.answer);
                        if (Array.isArray(studentAnswers) && studentAnswers[qIndex] !== undefined) {
                            answeredCount++;
                            if (studentAnswers[qIndex] === q.correctAnswer) {
                                correctCount++;
                            }
                        }
                    } catch (e) {
                        // Invalid answer format
                    }
                });

                return {
                    questionIndex: qIndex,
                    questionText: `Q${qIndex + 1}`,
                    level: q.level,
                    correctCount: correctCount,
                    answeredCount: answeredCount,
                    correctRate: answeredCount > 0 ? (correctCount / answeredCount) * 100 : 0
                };
            });

            // Calculate PIRLS level statistics
            const levelStats = [1, 2, 3, 4].map(level => {
                const levelQuestions = questionStats.filter(q => q.level === level);
                if (levelQuestions.length === 0) return null;

                const totalCorrect = levelQuestions.reduce((sum, q) => sum + q.correctCount, 0);
                const totalAnswered = levelQuestions.reduce((sum, q) => sum + q.answeredCount, 0);

                return {
                    level: level,
                    correctRate: totalAnswered > 0 ? (totalCorrect / totalAnswered) * 100 : 0,
                    questionCount: levelQuestions.length
                };
            }).filter(s => s !== null);

            const displayStats = questionStats.filter(s => s.answeredCount > 0);
            if (displayStats.length === 0) {
                chartSvg.append("text")
                    .attr("x", chartSvg.attr("width") / 2)
                    .attr("y", chartSvg.attr("height") / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .style("fill", "#666")
                    .text("目前沒有學生作答閱讀測驗。");
                return;
            }

            const x = d3.scaleBand()
                .range([0, width])
                .padding(0.2)
                .domain(displayStats.map(d => d.questionText));

            const y = d3.scaleLinear()
                .range([height, 0])
                .domain([0, 100]);

            const g = chartSvg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            // Define colors for each PIRLS level
            const levelColors = {
                1: '#3b82f6', // Blue - 直接提取
                2: '#8b5cf6', // Purple - 直接推論
                3: '#f59e0b', // Amber - 詮釋整合
                4: '#ef4444'  // Red - 比較評估
            };

            // X-axis
            g.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end");

            // Y-axis
            g.append("g")
                .call(d3.axisLeft(y).ticks(10).tickFormat(d => `${d}%`));

            // Bars
            g.selectAll(".bar")
                .data(displayStats)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d.questionText))
                .attr("y", d => y(d.correctRate))
                .attr("width", x.bandwidth())
                .attr("height", d => height - y(d.correctRate))
                .attr("fill", d => levelColors[d.level])
                .style("cursor", "pointer");

            // Labels on bars
            g.selectAll(".bar-label")
                .data(displayStats)
                .enter().append("text")
                .attr("class", "bar-label")
                .attr("x", d => x(d.questionText) + x.bandwidth() / 2)
                .attr("y", d => y(d.correctRate) - 5)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .text(d => `${d.correctRate.toFixed(1)}%`);

            // Y-axis label
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("答對率 (%)");

            // PIRLS Level Legend and Statistics
            const legendY = height + 50;
            const levelIcons = ['📖', '💭', '🔗', '⚖️'];
            const levelTexts = ['直接提取', '直接推論', '詮釋整合', '比較評估'];

            levelStats.forEach((stat, i) => {
                const legendX = i * 140;

                // Color box
                g.append("rect")
                    .attr("x", legendX)
                    .attr("y", legendY)
                    .attr("width", 15)
                    .attr("height", 15)
                    .attr("fill", levelColors[stat.level]);

                // Text
                g.append("text")
                    .attr("x", legendX + 20)
                    .attr("y", legendY + 12)
                    .style("font-size", "11px")
                    .text(`${levelIcons[i]} L${stat.level}: ${stat.correctRate.toFixed(1)}%`);
            });
        }


        // --- Sequencing Question Logic ---
        function setupSequencingUI(data) {
            console.log('[setupSequencingUI] Setting up sequencing UI with data:', data);
            const questionText = document.getElementById('sequencing-question-text');
            const container = document.getElementById('sequencing-items-container');

            if (!questionText || !container) {
                console.error('[setupSequencingUI] DOM elements not found!');
                return;
            }

            questionText.textContent = data.question || '請依照正確順序排列以下項目';
            container.innerHTML = '';

            if (!data.correctOrder || !Array.isArray(data.correctOrder) || data.correctOrder.length === 0) {
                console.error('[setupSequencingUI] Invalid or empty correctOrder array:', data.correctOrder);
                container.innerHTML = '<p class="text-red-500 text-center">無法載入排序項目</p>';
                return;
            }

            // Shuffle items
            const shuffled = [...data.correctOrder].sort(() => Math.random() - 0.5);
            console.log('[setupSequencingUI] Shuffled items:', shuffled);

            shuffled.forEach((text, index) => {
                const item = document.createElement('div');
                item.className = 'sequencing-item';
                item.draggable = true;
                item.dataset.text = text;
                item.innerHTML = `
                    <div class="sequencing-item-number">${index + 1}</div>
                    <div class="sequencing-item-text">${text}</div>
                `;

                // Drag events
                item.addEventListener('dragstart', (e) => {
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const dragging = document.querySelector('.sequencing-item.dragging');
                    if (dragging && dragging !== item) {
                        const rect = item.getBoundingClientRect();
                        const midY = rect.top + rect.height / 2;
                        if (e.clientY < midY) {
                            container.insertBefore(dragging, item);
                        } else {
                            container.insertBefore(dragging, item.nextSibling);
                        }
                    }
                });

                // Touch events for mobile
                let touchStartY = 0;
                item.addEventListener('touchstart', (e) => {
                    touchStartY = e.touches[0].clientY;
                    item.classList.add('dragging');
                });

                item.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (target && target.classList.contains('sequencing-item') && target !== item) {
                        if (touch.clientY < touchStartY) {
                            container.insertBefore(item, target);
                        } else {
                            container.insertBefore(item, target.nextSibling);
                        }
                        touchStartY = touch.clientY;
                    }
                });

                item.addEventListener('touchend', () => {
                    item.classList.remove('dragging');
                });

                container.appendChild(item);
            });

            // Update numbers after any change
            updateSequencingNumbers();
        }

        function updateSequencingNumbers() {
            const items = document.querySelectorAll('.sequencing-item');
            items.forEach((item, index) => {
                const numberDiv = item.querySelector('.sequencing-item-number');
                if (numberDiv) numberDiv.textContent = index + 1;
            });
        }

        // --- Matching Question Logic ---
        function setupMatchingUI(data) {
            console.log('[setupMatchingUI] Setting up matching UI with data:', data);
            const questionText = document.getElementById('matching-question-text');
            const columnA = document.getElementById('matching-column-a');
            const columnB = document.getElementById('matching-column-b');
            const svg = document.getElementById('matching-svg-canvas');

            if (!questionText || !columnA || !columnB || !svg) {
                console.error('[setupMatchingUI] DOM elements not found!');
                return;
            }

            questionText.textContent = data.question || '請將左右兩側相關的項目配對';
            columnA.innerHTML = '';
            columnB.innerHTML = '';
            svg.innerHTML = '';

            if (!data.pairs || !Array.isArray(data.pairs) || data.pairs.length === 0) {
                console.error('[setupMatchingUI] Invalid or empty pairs array:', data.pairs);
                columnA.innerHTML = '<p class="text-red-500">無法載入配對項目</p>';
                return;
            }

            // Shuffle items
            const leftItems = data.pairs.map(p => p.left).sort(() => Math.random() - 0.5);
            const rightItems = data.pairs.map(p => p.right).sort(() => Math.random() - 0.5);
            console.log('[setupMatchingUI] Left items:', leftItems, 'Right items:', rightItems);

            leftItems.forEach((text, index) => {
                const item = document.createElement('div');
                item.className = 'matching-item';
                item.dataset.side = 'left';
                item.dataset.text = text;
                item.dataset.index = index;
                // ✨ Add safe ID for reliable element selection (avoids special character issues)
                item.id = `matching-left-${index}`;
                item.textContent = text;
                item.addEventListener('click', () => handleMatchingClick(item));
                columnA.appendChild(item);
            });

            rightItems.forEach((text, index) => {
                const item = document.createElement('div');
                item.className = 'matching-item';
                item.dataset.side = 'right';
                item.dataset.text = text;
                item.dataset.index = index;
                // ✨ Add safe ID for reliable element selection (avoids special character issues)
                item.id = `matching-right-${index}`;
                item.textContent = text;
                item.addEventListener('click', () => handleMatchingClick(item));
                columnB.appendChild(item);
            });
        }

        function handleMatchingClick(item) {
            const side = item.dataset.side;

            if (item.classList.contains('matched')) {
                // Unmatch
                const matchedWith = item.dataset.matchedWith;
                delete item.dataset.matchedWith;
                item.classList.remove('matched');

                // Find and unmatch partner
                const partner = document.querySelector(`.matching-item[data-side="${side === 'left' ? 'right' : 'left'}"][data-text="${matchedWith}"]`);
                if (partner) {
                    delete partner.dataset.matchedWith;
                    partner.classList.remove('matched');
                }

                redrawMatchingLines();
                return;
            }

            if (side === 'left') {
                if (currentMatchingSelection.leftItem === item) {
                    currentMatchingSelection.leftItem.classList.remove('selected');
                    currentMatchingSelection.leftItem = null;
                } else {
                    if (currentMatchingSelection.leftItem) {
                        currentMatchingSelection.leftItem.classList.remove('selected');
                    }
                    currentMatchingSelection.leftItem = item;
                    item.classList.add('selected');
                }
            } else {
                if (currentMatchingSelection.rightItem === item) {
                    currentMatchingSelection.rightItem.classList.remove('selected');
                    currentMatchingSelection.rightItem = null;
                } else {
                    if (currentMatchingSelection.rightItem) {
                        currentMatchingSelection.rightItem.classList.remove('selected');
                    }
                    currentMatchingSelection.rightItem = item;
                    item.classList.add('selected');
                }
            }

            // If both sides selected, create match
            if (currentMatchingSelection.leftItem && currentMatchingSelection.rightItem) {
                const left = currentMatchingSelection.leftItem;
                const right = currentMatchingSelection.rightItem;

                left.classList.remove('selected');
                right.classList.remove('selected');
                left.classList.add('matched');
                right.classList.add('matched');

                left.dataset.matchedWith = right.dataset.text;
                right.dataset.matchedWith = left.dataset.text;

                currentMatchingSelection.leftItem = null;
                currentMatchingSelection.rightItem = null;

                redrawMatchingLines();
            }
        }

        function redrawMatchingLines() {
            const svg = document.getElementById('matching-svg-canvas');
            svg.innerHTML = '';

            const container = document.querySelector('.matching-container');
            const rect = container.getBoundingClientRect();
            svg.setAttribute('width', rect.width);
            svg.setAttribute('height', rect.height);

            // 🎨 Add SVG gradients for beautiful connecting lines
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            
            // Pink gradient for default matching lines
            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient.setAttribute('id', 'lineGradient');
            gradient.setAttribute('x1', '0%');
            gradient.setAttribute('y1', '0%');
            gradient.setAttribute('x2', '100%');
            gradient.setAttribute('y2', '0%');
            gradient.innerHTML = `
                <stop offset="0%" style="stop-color:#ec4899;stop-opacity:1" />
                <stop offset="50%" style="stop-color:#f472b6;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#ec4899;stop-opacity:1" />
            `;
            defs.appendChild(gradient);

            // Green gradient for correct matches
            const gradientCorrect = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradientCorrect.setAttribute('id', 'lineGradientCorrect');
            gradientCorrect.setAttribute('x1', '0%');
            gradientCorrect.setAttribute('y1', '0%');
            gradientCorrect.setAttribute('x2', '100%');
            gradientCorrect.setAttribute('y2', '0%');
            gradientCorrect.innerHTML = `
                <stop offset="0%" style="stop-color:#10b981;stop-opacity:1" />
                <stop offset="50%" style="stop-color:#34d399;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#10b981;stop-opacity:1" />
            `;
            defs.appendChild(gradientCorrect);

            // Red gradient for incorrect matches
            const gradientIncorrect = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradientIncorrect.setAttribute('id', 'lineGradientIncorrect');
            gradientIncorrect.setAttribute('x1', '0%');
            gradientIncorrect.setAttribute('y1', '0%');
            gradientIncorrect.setAttribute('x2', '100%');
            gradientIncorrect.setAttribute('y2', '0%');
            gradientIncorrect.innerHTML = `
                <stop offset="0%" style="stop-color:#ef4444;stop-opacity:1" />
                <stop offset="50%" style="stop-color:#f87171;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#ef4444;stop-opacity:1" />
            `;
            defs.appendChild(gradientIncorrect);

            svg.appendChild(defs);

            // Draw matching lines with smooth curves
            let lineIndex = 0;
            document.querySelectorAll('.matching-item.matched[data-side="left"]').forEach(leftItem => {
                const rightText = leftItem.dataset.matchedWith;
                const rightItem = document.querySelector(`.matching-item[data-side="right"][data-text="${rightText}"]`);

                if (rightItem) {
                    const leftRect = leftItem.getBoundingClientRect();
                    const rightRect = rightItem.getBoundingClientRect();

                    const x1 = leftRect.right - rect.left;
                    const y1 = leftRect.top + leftRect.height / 2 - rect.top;
                    const x2 = rightRect.left - rect.left;
                    const y2 = rightRect.top + rightRect.height / 2 - rect.top;

                    // 🎨 Create smooth Bezier curve with gradient stroke
                    const controlPointX = (x1 + x2) / 2;
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const d = `M ${x1} ${y1} C ${controlPointX} ${y1}, ${controlPointX} ${y2}, ${x2} ${y2}`;
                    line.setAttribute('d', d);
                    line.setAttribute('class', 'matching-line');
                    
                    // ✨ Explicitly set stroke with gradient
                    line.setAttribute('stroke', 'url(#lineGradient)');
                    line.setAttribute('stroke-width', window.innerWidth >= 768 ? '5' : '4');
                    line.setAttribute('fill', 'none');
                    line.setAttribute('stroke-linecap', 'round');
                    
                    // 🎬 Stagger animation for visual appeal
                    line.style.animationDelay = `${lineIndex * 0.1}s`;
                    lineIndex++;
                    
                    svg.appendChild(line);
                }
            });
        }

        /**
         * 🚀 NEW: Wait for matching DOM elements to be ready
         * @param {object} settings - The matching settings
         * @returns {Promise} Resolves when DOM is ready, rejects after timeout
         */
        async function waitForMatchingDomReady(settings) {
            const timeout = 500; // 500ms timeout
            const startTime = Date.now();
            
            return new Promise((resolve, reject) => {
                const checkDom = () => {
                    // Check if first left and right items exist
                    const leftItem = document.getElementById('matching-left-0');
                    const rightItem = document.getElementById('matching-right-0');
                    
                    if (leftItem && rightItem) {
                        console.log('[waitForMatchingDomReady] DOM ready, elements found');
                        resolve();
                    } else {
                        const elapsed = Date.now() - startTime;
                        if (elapsed > timeout) {
                            console.error('[waitForMatchingDomReady] Timeout after', elapsed, 'ms, DOM not ready');
                            reject(new Error('Matching DOM timeout'));
                        } else {
                            console.log('[waitForMatchingDomReady] Waiting for DOM... elapsed:', elapsed, 'ms');
                            requestAnimationFrame(checkDom);
                        }
                    }
                };
                
                requestAnimationFrame(checkDom);
            });
        }

        /**
         * 🚀 NEW: Display correct answers for matching questions
         * @param {object} matchingSettings - The matching settings with correct pairs
         */
        function displayMatchingCorrectAnswers(matchingSettings) {
            if (!matchingSettings || !matchingSettings.pairs || !Array.isArray(matchingSettings.pairs)) {
                console.error('[displayMatchingCorrectAnswers] Invalid matching settings:', matchingSettings);
                return;
            }

            console.log('[displayMatchingCorrectAnswers] Displaying correct answers for matching');

            // 1. Clear existing selections and matches (清除學生的配對狀態)
            document.querySelectorAll('.matching-item').forEach(item => {
                item.classList.remove('selected', 'matched');
                delete item.dataset.matchedWith;
            });

            // 2. ✨ Find items by text content (since they're shuffled, we can't use fixed indices)
            // 只畫綠色連線就好，這樣視覺上更清晰
            matchingSettings.pairs.forEach(pair => {
                // Use Array.from to find items by text content (more reliable than querySelector with special chars)
                const leftItems = Array.from(document.querySelectorAll('.matching-item[data-side="left"]'));
                const rightItems = Array.from(document.querySelectorAll('.matching-item[data-side="right"]'));
                
                const leftItem = leftItems.find(item => item.dataset.text === pair.left);
                const rightItem = rightItems.find(item => item.dataset.text === pair.right);

                if (leftItem && rightItem) {
                    // 只標記 data-matchedWith 和 ID 用於畫線，不添加 matched 類
                    leftItem.dataset.matchedWith = rightItem.id;
                    rightItem.dataset.matchedWith = leftItem.id;
                    // 添加特殊類以區分這是答案顯示模式
                    leftItem.classList.add('answer-revealed');
                    rightItem.classList.add('answer-revealed');
                    console.log(`[displayMatchingCorrectAnswers] Paired: ${leftItem.id} ↔ ${rightItem.id}`);
                } else {
                    console.warn(`[displayMatchingCorrectAnswers] Could not find items for pair:`, pair);
                }
            });

            // 3. Redraw lines with correct answer gradient
            const svg = document.getElementById('matching-svg-canvas');
            svg.innerHTML = '';

            const container = document.querySelector('.matching-container');
            const rect = container.getBoundingClientRect();
            svg.setAttribute('width', rect.width);
            svg.setAttribute('height', rect.height);
            svg.setAttribute('style', 'pointer-events: none; z-index: 10;');

            // Add gradients and drop shadow for visual depth
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            
            // Gradient for correct answers
            const gradientCorrect = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradientCorrect.setAttribute('id', 'lineGradientCorrect');
            gradientCorrect.setAttribute('x1', '0%');
            gradientCorrect.setAttribute('y1', '0%');
            gradientCorrect.setAttribute('x2', '100%');
            gradientCorrect.setAttribute('y2', '0%');
            gradientCorrect.innerHTML = `
                <stop offset="0%" style="stop-color:#10b981;stop-opacity:1" />
                <stop offset="50%" style="stop-color:#34d399;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#10b981;stop-opacity:1" />
            `;
            defs.appendChild(gradientCorrect);
            
            // Drop shadow for depth
            const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
            filter.setAttribute('id', 'dropShadow');
            filter.innerHTML = `<feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.3"/>`;
            defs.appendChild(filter);
            
            svg.appendChild(defs);

            // Draw correct answer lines using matched IDs
            let lineIndex = 0;
            document.querySelectorAll('.matching-item[data-side="left"].answer-revealed').forEach(leftItem => {
                const rightId = leftItem.dataset.matchedWith;
                const rightItem = document.getElementById(rightId);

                if (rightItem) {
                    const leftRect = leftItem.getBoundingClientRect();
                    const rightRect = rightItem.getBoundingClientRect();

                    const x1 = leftRect.right - rect.left;
                    const y1 = leftRect.top + leftRect.height / 2 - rect.top;
                    const x2 = rightRect.left - rect.left;
                    const y2 = rightRect.top + rightRect.height / 2 - rect.top;

                    const controlPointX = (x1 + x2) / 2;
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const d = `M ${x1} ${y1} C ${controlPointX} ${y1}, ${controlPointX} ${y2}, ${x2} ${y2}`;
                    line.setAttribute('d', d);
                    line.setAttribute('class', 'matching-line');
                    line.setAttribute('stroke', 'url(#lineGradientCorrect)');
                    line.setAttribute('stroke-width', window.innerWidth >= 768 ? '5' : '4');
                    line.setAttribute('fill', 'none');
                    line.setAttribute('stroke-linecap', 'round');
                    line.setAttribute('filter', 'url(#dropShadow)');
                    line.style.animationDelay = `${lineIndex * 0.1}s`;
                    lineIndex++;

                    svg.appendChild(line);
                    console.log(`[displayMatchingCorrectAnswers] Drew line from ${leftItem.id} to ${rightId}`);
                }
            });

            console.log(`[displayMatchingCorrectAnswers] Drew ${lineIndex} lines total`);

            // 4. Disable interaction - remove click handlers by blocking pointer events
            const matchingContainer = document.querySelector('.matching-container');
            if (matchingContainer) {
                matchingContainer.style.pointerEvents = 'none';
            }

            // 5. Show message to student
            showMessage('老師已顯示正確答案！', 'info');
        }

        /**
         * 🚀 NEW: Display correct answers for sequencing questions
         * @param {object} sequencingSettings - The sequencing settings with correct order
         */
        function displaySequencingCorrectAnswers(sequencingSettings) {
            if (!sequencingSettings || !sequencingSettings.correctOrder || !Array.isArray(sequencingSettings.correctOrder)) {
                console.error('[displaySequencingCorrectAnswers] Invalid sequencing settings:', sequencingSettings);
                return;
            }

            console.log('[displaySequencingCorrectAnswers] Displaying correct answers for sequencing');

            const container = document.getElementById('sequencing-items-container');
            if (!container) {
                console.error('[displaySequencingCorrectAnswers] Container not found');
                return;
            }

            // 1. Clear existing items
            container.innerHTML = '';

            // 2. Render items in correct order with visual indicators
            sequencingSettings.correctOrder.forEach((text, index) => {
                const item = document.createElement('div');
                item.className = 'sequencing-item correct-answer';
                item.draggable = false;
                item.innerHTML = `
                    <div class="sequencing-item-number text-xs sm:text-sm md:text-base px-2 sm:px-2.5 py-1 sm:py-1.5 rounded">${index + 1}</div>
                    <div class="sequencing-item-text flex-1 text-base sm:text-lg md:text-xl">${text}</div>
                    <div class="sequencing-item-check">
                        <svg class="w-5 h-5 sm:w-6 sm:h-6 md:w-7 md:h-7 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/>
                        </svg>
                    </div>
                `;
                container.appendChild(item);
            });

            // 3. Disable interaction - freeze drag handlers
            const items = container.querySelectorAll('.sequencing-item');
            items.forEach(item => {
                item.draggable = false;
                item.style.pointerEvents = 'none';
            });

            // 4. Disable submit button
            const submitBtn = document.getElementById('submit-sequencing-btn');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.style.opacity = '0.5';
            }

            // 5. Show message to student
            showMessage('老師已顯示正確答案！', 'info');
        }

        /**
         * 🚀 NEW: Teacher listener for answer display flags
         */
        let teacherAnswerUnsubscribe = null; // Track listener to prevent duplicates
        
        function setupTeacherAnswerListener() {
            if (!classroomCode) return;
            
            // 🔥 Unsubscribe existing listener to prevent memory leak
            if (teacherAnswerUnsubscribe) {
                console.log('[setupTeacherAnswerListener] Unsubscribing existing listener');
                teacherAnswerUnsubscribe();
                teacherAnswerUnsubscribe = null;
            }
            
            const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
            teacherAnswerUnsubscribe = onSnapshot(controlRef, (docSnap) => {
                if (!docSnap.exists()) return;
                const data = docSnap.data();
                
                // Display matching answer if flag is true
                if (data.showMatchingAnswer && data.matchingSettings) {
                    displayTeacherMatchingAnswer(data.matchingSettings);
                }
                
                // Display sequencing answer if flag is true
                if (data.showSequencingAnswer && data.sequencingSettings) {
                    displayTeacherSequencingAnswer(data.sequencingSettings);
                }
            });
            
            console.log('[setupTeacherAnswerListener] New listener registered');
        }

        /**
         * 🚀 NEW: Display correct answers for teacher (matching questions)
         */
        function displayTeacherMatchingAnswer(matchingSettings) {
            const display = document.getElementById('teacher-answer-display');
            const content = document.getElementById('teacher-answer-content');
            const title = document.getElementById('teacher-answer-title');
            
            if (!matchingSettings || !matchingSettings.pairs) return;
            
            title.textContent = '配對題正確答案';
            content.innerHTML = '<ol class="list-decimal list-inside space-y-2 text-lg">' + 
                matchingSettings.pairs.map((pair, i) => 
                    `<li><strong>${pair.left}</strong> → ${pair.right}</li>`
                ).join('') + '</ol>';
            display.classList.remove('hidden');
        }

        /**
         * 🚀 NEW: Display correct answers for teacher (sequencing questions)
         */
        function displayTeacherSequencingAnswer(sequencingSettings) {
            const display = document.getElementById('teacher-answer-display');
            const content = document.getElementById('teacher-answer-content');
            const title = document.getElementById('teacher-answer-title');
            
            if (!sequencingSettings || !sequencingSettings.correctOrder) return;
            
            title.textContent = '排序題正確答案';
            content.innerHTML = '<ol class="list-decimal list-inside space-y-2 text-lg">' + 
                sequencingSettings.correctOrder.map((item, i) => 
                    `<li>${item}</li>`
                ).join('') + '</ol>';
            display.classList.remove('hidden');
        }

        // --- Drawing Board Logic ---
        function setupCanvas() {
            const canvasElement = document.getElementById('drawing-canvas');
            if (!canvasElement.offsetParent) return; // Don't setup if not visible
            let renderedWidth = canvasElement.clientWidth;
            let renderedHeight = canvasElement.clientHeight;

            canvasElement.width = Math.min(MAX_IMAGE_DIMENSION * 2, Math.max(1, renderedWidth)); 
            canvasElement.height = Math.min(MAX_IMAGE_DIMENSION * 2, Math.max(1, renderedHeight));

            [backgroundCanvas, studentImageCanvas, drawingCanvas].forEach(c => {
                c.width = canvasElement.width;
                c.height = canvasElement.height;
            });

            drawingCtx.lineJoin = 'round';
            drawingCtx.lineCap = 'round';
            drawingCtx.strokeStyle = document.getElementById('color-select').value;
            drawingCtx.lineWidth = parseInt(document.getElementById('size-select').value);
            drawingCtx.globalCompositeOperation = 'source-over';

            // Only clear drawingCanvas if it's a new session, not just a resize within the same session.
            // This is handled by the `resetStudentUIState` function now.
            // For setupCanvas, it's about setting dimensions and initial drawing context properties.
            // The actual clearing should be conditional based on pause state.
            // However, for a fresh setup (e.g., first time entering drawing mode), it should be cleared.
            // The logic in resetStudentUIState is responsible for this.
            // So, here, we just ensure the canvases are ready.
            backgroundCtx.fillStyle = 'white';
            backgroundCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            studentImageCtx.clearRect(0, 0, studentImageCanvas.width, studentImageCanvas.height);
        }

        function loadBackgroundImage() {
            backgroundCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            backgroundCtx.fillStyle = 'white';
            backgroundCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);

            if (teacherUploadedBackgroundImageDataURL) {
                const tempImg = new Image();
                tempImg.onload = () => {
                    const canvasRatio = backgroundCanvas.width / backgroundCanvas.height;
                    const imgRatio = tempImg.width / tempImg.height;
                    let drawWidth, drawHeight, offsetX, offsetY;
                    if (imgRatio > canvasRatio) { 
                        drawHeight = backgroundCanvas.width / imgRatio;
                        drawWidth = backgroundCanvas.width;
                        offsetY = (backgroundCanvas.height - drawHeight) / 2;
                        offsetX = 0;
                    } else { 
                        drawWidth = backgroundCanvas.height * imgRatio;
                        drawHeight = backgroundCanvas.height;
                        offsetX = (backgroundCanvas.width - drawWidth) / 2;
                        offsetY = 0;
                    }
                    backgroundCtx.drawImage(tempImg, offsetX, offsetY, drawWidth, drawHeight);
                    drawCombinedCanvas();
                };
                tempImg.src = teacherUploadedBackgroundImageDataURL;
            } else {
                drawCombinedCanvas();
            }
        }

        function loadStudentImage() {
            studentImageCtx.clearRect(0, 0, studentImageCanvas.width, studentImageCanvas.height);

            if (studentUploadedImageDataURL) {
                const tempImg = new Image();
                tempImg.onload = () => {
                    const canvasRatio = studentImageCanvas.width / studentImageCanvas.height;
                    const imgRatio = tempImg.width / tempImg.height;
                    let drawWidth, drawHeight, offsetX, offsetY;
                    if (imgRatio > canvasRatio) { 
                        drawHeight = studentImageCanvas.width / imgRatio;
                        drawWidth = studentImageCanvas.width;
                        offsetY = (studentImageCanvas.height - drawHeight) / 2;
                        offsetX = 0;
                    } else { 
                        drawWidth = studentImageCanvas.height * imgRatio;
                        drawHeight = studentImageCanvas.height;
                        offsetX = (studentImageCanvas.width - drawWidth) / 2;
                        offsetY = 0;
                    }
                    studentImageCtx.drawImage(tempImg, offsetX, offsetY, drawWidth, drawHeight);
                    drawCombinedCanvas();
                };
                tempImg.src = studentUploadedImageDataURL;
            } else {
                drawCombinedCanvas();
            }
        }

        function drawCombinedCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(backgroundCanvas, 0, 0);
            ctx.drawImage(studentImageCanvas, 0, 0);
            ctx.drawImage(drawingCanvas, 0, 0);
        }

        /**
         * 🚀 OPTIMIZED: 繪圖函式（將被節流包裝）
         */
        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault(); 
            const { offsetX, offsetY } = getMousePos(e); 
            drawingCtx.beginPath();
            drawingCtx.moveTo(lastX, lastY);
            drawingCtx.lineTo(offsetX, offsetY);
            drawingCtx.stroke();
            [lastX, lastY] = [offsetX, offsetY];
            drawCombinedCanvas();
        }
        
        // 🚀 OPTIMIZED: 創建節流版本的繪圖函式（16ms ≈ 60 FPS）
        const throttledDraw = Utils.throttle(draw, 16);

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect(); 
            let clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const rawOffsetX = clientX - rect.left;
            const rawOffsetY = clientY - rect.top;
            const scaleX = canvas.width / rect.width; 
            const scaleY = canvas.height / rect.height;
            return { offsetX: rawOffsetX * scaleX, offsetY: rawOffsetY * scaleY };
        }
        
        function startDrawing(e) {
            isDrawing = true;
            const { offsetX, offsetY } = getMousePos(e); 
            [lastX, lastY] = [offsetX, offsetY];
        }

        function stopDrawing() { isDrawing = false; }
        
        function clearDrawingCanvas() {
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            drawCombinedCanvas();
        }

        function updateColorSwatch(color) {
            const swatch = document.getElementById('current-color-swatch');
            if (swatch) swatch.style.backgroundColor = color;
        }
        
        // --- AI Settings Modal Functions ---
        const aiSettingsModal = document.getElementById('ai-settings-modal');
        const aiSettingsModalCloseBtn = document.getElementById('ai-settings-modal-close-btn');
        const aiSourceSelect = document.getElementById('ai-source-select');
        const geminiApiKeyGroup = document.getElementById('gemini-api-key-group');
        const geminiApiKeyInput = document.getElementById('gemini-api-key-input');
        const saveAiSettingsBtn = document.getElementById('save-ai-settings-btn');

        function showAISettingsModal() {
            aiSourceSelect.value = aiSettings.aiSource;
            geminiApiKeyInput.value = aiSettings.geminiApiKey;
            geminiApiKeyGroup.classList.toggle('hidden', aiSettings.aiSource !== 'gemini-custom');
            aiSettingsModal.classList.remove('hidden');
        }

        function hideAISettingsModal() {
            aiSettingsModal.classList.add('hidden');
        }

        function saveAISettings() {
            aiSettings.aiSource = aiSourceSelect.value;
            aiSettings.geminiApiKey = geminiApiKeyInput.value.trim();
            localStorage.setItem('aiSettings', JSON.stringify(aiSettings));
            showMessage('AI 設定已儲存！', 'success');
            hideAISettingsModal();
        }

        /**
         * 檢查 API KEY 是否已設定並符合基本格式要求
         * 如果未設定或格式明顯錯誤，顯示警告訊息並打開 AI 設定模態框
         * @returns {boolean} 如果 API KEY 通過基本檢查返回 true，否則返回 false
         */
        function checkAPIKey() {
            const apiKey = aiSettings.geminiApiKey?.trim();
            
            // 檢查是否為空或預設值
            if (!apiKey || apiKey === '12345678') {
                const errorMsg = '⚠️ 請先在 AI 設定中填寫您的 Google AI Studio API Key！';
                console.error('[API KEY 驗證]', errorMsg, { currentKey: apiKey || '(空值)' });
                showMessage(errorMsg, 'warning');
                // 顯示訊息後立即打開設定框（訊息 z-index 更高，不會被遮擋）
                showAISettingsModal();
                return false;
            }
            
            // 檢查基本格式：Google API Key 通常至少 30 字符
            if (apiKey.length < 30) {
                const errorMsg = `❌ API KEY 格式錯誤！通常至少需要 30 個字符，您只輸入了 ${apiKey.length} 個字符。`;
                console.error('[API KEY 驗證] 格式檢查失敗:', {
                    errorType: 'KEY_TOO_SHORT',
                    expectedMinLength: 30,
                    actualLength: apiKey.length,
                    keyPreview: apiKey.substring(0, 10) + '...',
                    message: errorMsg
                });
                showMessage(errorMsg, 'error');
                // 顯示訊息後立即打開設定框（訊息 z-index 更高，不會被遮擋）
                showAISettingsModal();
                return false;
            }
            
            return true;
        }

        function loadAISettings() {
            const savedSettings = localStorage.getItem('aiSettings');
            if (savedSettings) {
                try {
                    const parsedSettings = JSON.parse(savedSettings);
                    if (parsedSettings.aiSource) aiSettings.aiSource = parsedSettings.aiSource;
                    // MODIFIED: If geminiApiKey is empty after loading, set default.
                    aiSettings.geminiApiKey = parsedSettings.geminiApiKey || '12345678'; 
                } catch (e) {
                    console.error("Failed to parse AI settings from localStorage:", e);
                    // If parsing fails, set default API key
                    aiSettings.geminiApiKey = '12345678';
                }
            } else {
                // If no settings are saved at all, set default API key
                aiSettings.geminiApiKey = '12345678';
            }
        }

        // --- New: URL/HTML Dispatch Settings Modal Functions (Combined) ---
        const urlDispatchModal = document.getElementById('url-dispatch-settings-modal');
        const urlDispatchModalCloseBtn = document.getElementById('url-dispatch-settings-modal-close-btn');
        
        const urlDispatchSection = document.getElementById('url-dispatch-section');
        const htmlDispatchSection = document.getElementById('html-dispatch-section');
        const dispatchTypeRadios = document.querySelectorAll('input[name="dispatchType"]');

        const urlInput = document.getElementById('dispatch-url-input');
        const isYoutubeCheckbox = document.getElementById('is-youtube-checkbox');
        
        const dispatchHtmlUploadInput = document.getElementById('dispatch-html-upload-input');
        const clearDispatchHtmlBtn = document.getElementById('clear-dispatch-html-btn');
        const dispatchHtmlStatus = document.getElementById('dispatch-html-status');

        function showUrlDispatchSettingsModal() {
            // Set radio button based on current dispatchSettings.type
            document.querySelector(`input[name="dispatchType"][value="${dispatchSettings.type}"]`).checked = true;
            
            // Show/hide sections based on type
            urlDispatchSection.classList.toggle('hidden', dispatchSettings.type === 'html');
            htmlDispatchSection.classList.toggle('hidden', dispatchSettings.type === 'url');

            // Populate URL fields
            urlInput.value = dispatchSettings.url;
            isYoutubeCheckbox.checked = dispatchSettings.isYoutube;

            // Update HTML status
            dispatchHtmlStatus.textContent = dispatchSettings.htmlContent ? '已上傳 HTML 檔案。' : '目前沒有 HTML 檔案。';

            urlDispatchModal.classList.remove('hidden');
        }

        function hideUrlDispatchSettingsModal() {
            urlDispatchModal.classList.add('hidden');
        }

        function saveDispatchSettings() { // Renamed from saveUrlDispatchSettings
            dispatchSettings.type = document.querySelector('input[name="dispatchType"]:checked').value;

            if (dispatchSettings.type === 'url') {
                dispatchSettings.url = urlInput.value.trim();
                dispatchSettings.isYoutube = isYoutubeCheckbox.checked;
                dispatchSettings.htmlContent = null; // Clear HTML content if switching to URL
            } else { // type === 'html'
                // htmlContent is updated via handleHtmlFile or clearDispatchHtml
                dispatchSettings.url = ''; // Clear URL if switching to HTML
                dispatchSettings.isYoutube = false; // Clear YouTube flag
            }
            
            localStorage.setItem('dispatchSettings', JSON.stringify(dispatchSettings));
            showMessage('派送設定已儲存！', 'success');
            hideUrlDispatchSettingsModal();
        }

        function clearDispatchSettings() { // Renamed from clearUrlDispatchSettings
            urlInput.value = '';
            isYoutubeCheckbox.checked = false;
            dispatchHtmlUploadInput.value = ''; // Clear file input
            dispatchHtmlStatus.textContent = '目前沒有 HTML 檔案。';

            dispatchSettings = { type: 'url', url: '', isYoutube: false, htmlContent: null }; // Reset global variable
            localStorage.removeItem('dispatchSettings'); // Clear from localStorage
            
            // Reset UI to default (URL selected)
            document.querySelector('input[name="dispatchType"][value="url"]').checked = true;
            urlDispatchSection.classList.remove('hidden');
            htmlDispatchSection.classList.add('hidden');
        }

        function loadDispatchSettings() { // Renamed from loadUrlDispatchSettings
            const savedSettings = localStorage.getItem('dispatchSettings');
            if (savedSettings) {
                try {
                    const parsedSettings = JSON.parse(savedSettings);
                    // Ensure all properties are set, even if null in saved data
                    dispatchSettings.type = parsedSettings.type || 'url';
                    dispatchSettings.url = parsedSettings.url || '';
                    dispatchSettings.isYoutube = parsedSettings.isYoutube || false;
                    dispatchSettings.htmlContent = parsedSettings.htmlContent || null;
                } catch (e) {
                    console.error("Failed to parse dispatch settings from localStorage:", e);
                    // Reset to default if parsing fails
                    dispatchSettings = { type: 'url', url: '', isYoutube: false, htmlContent: null };
                }
            }
        }

        /**
         * NEW: Handles HTML file upload within the combined dispatch settings modal.
         * @param {File} file - The HTML file to process.
         */
        function handleDispatchHtmlFile(file) {
            if (!file || !file.type.includes('html')) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                dispatchSettings.htmlContent = event.target.result; // Update global state
                dispatchHtmlStatus.textContent = `已上傳檔案: ${file.name}`;
                showMessage('HTML 檔案已上傳！', 'success');
            };
            reader.readAsText(file);
        }


        // --- New: Recording Functions (Student Side) ---
        const startRecordingBtn = document.getElementById('start-recording-btn');
        const stopRecordingBtn = document.getElementById('stop-recording-btn');
        const playRecordingBtn = document.getElementById('play-recording-btn');
        const resetRecordingBtn = document.getElementById('reset-recording-btn');
        const submitRecordingBtn = document.getElementById('submit-recording-btn');
        const audioPreview = document.getElementById('audio-preview');
        const recordingStatusText = document.getElementById('recording-status-text');
        const recordingStatusIcon = document.getElementById('recording-status-icon');

        /**
         * Starts the audio recording process.
         */
        async function startRecording() {
            try {
                // Request access to microphone
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Try to use audio/wav first for better iOS compatibility.
                // Fallback to audio/webm if wav is not supported.
                let mimeType = 'audio/webm';
                if (MediaRecorder.isTypeSupported('audio/wav')) {
                    mimeType = 'audio/wav';
                } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                    mimeType = 'audio/mp4'; // Another common format
                } else if (MediaRecorder.isTypeSupported('audio/ogg')) {
                    mimeType = 'audio/ogg';
                }

                mediaRecorder = new MediaRecorder(audioStream, { mimeType: mimeType });
                audioChunks = [];

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType }); // Use the actual mimeType recorded
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        audioDataURL = reader.result;
                        audioPreview.src = audioDataURL;
                        audioPreview.classList.remove('hidden');
                        playRecordingBtn.disabled = false;
                        resetRecordingBtn.disabled = false;
                        submitRecordingBtn.disabled = false;
                        recordingStatusText.textContent = '錄音完成，可試聽或送出';
                        recordingStatusIcon.classList.remove('fa-spin', 'text-red-500');
                        recordingStatusIcon.classList.add('text-green-500');
                    };
                    reader.readAsDataURL(audioBlob);

                    // Stop all tracks to release microphone
                    audioStream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();
                startRecordingBtn.disabled = true;
                stopRecordingBtn.disabled = false;
                playRecordingBtn.disabled = true;
                resetRecordingBtn.disabled = true;
                submitRecordingBtn.disabled = true;
                recordingStatusText.textContent = '正在錄音...';
                recordingStatusIcon.classList.remove('text-gray-400');
                recordingStatusIcon.classList.add('fa-spin', 'text-red-500');
                showMessage('開始錄音', 'info');
            } catch (err) {
                console.error('無法取得麥克風權限:', err);
                showMessage('無法取得麥克風權限，請檢查設定。', 'error');
                // Reset buttons if permission fails
                startRecordingBtn.disabled = false;
                stopRecordingBtn.disabled = true;
                playRecordingBtn.disabled = true;
                resetRecordingBtn.disabled = true;
                submitRecordingBtn.disabled = true;
                recordingStatusText.textContent = '錄音失敗';
                recordingStatusIcon.classList.remove('fa-spin', 'text-red-500');
                recordingStatusIcon.classList.add('text-gray-400');
            }
        }

        /**
         * Stops the audio recording.
         */
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                stopRecordingBtn.disabled = true;
            }
        }

        /**
         * Plays the recorded audio.
         */
        function playRecording() {
            if (audioPreview.src) {
                audioPreview.play();
                showMessage('正在播放錄音', 'info');
            } else {
                showMessage('沒有可播放的錄音', 'info');
            }
        }

        /**
         * Resets the recording state, allowing for a new recording.
         */
        function resetRecording() {
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
            }
            audioChunks = [];
            audioBlob = null;
            audioDataURL = null;
            audioPreview.src = '';
            audioPreview.classList.add('hidden');

            startRecordingBtn.disabled = false;
            stopRecordingBtn.disabled = true;
            playRecordingBtn.disabled = true;
            resetRecordingBtn.disabled = true;
            submitRecordingBtn.disabled = true;
            recordingStatusText.textContent = '準備錄音...';
            recordingStatusIcon.classList.remove('fa-spin', 'text-red-500', 'text-green-500');
            recordingStatusIcon.classList.add('text-gray-400');
            showMessage('錄音已重置', 'info');
        }

        // --- End Recording Functions ---

        /**
         * (Teacher) Ends the entire class session, clears all student data and presence for the current classroom code.
         */
        async function endClassSession() {
            // 二次確認機制：防止誤按下課按鈕
            const confirmed = confirm(
                '⚠️ 您確定要下課嗎？\n\n' +
                '下課後將會：\n' +
                '• 清空所有學生回應資料\n' +
                '• 結束當前教室\n' +
                '• 學生將無法繼續作答\n\n' +
                '此操作無法復原，請確認是否要繼續？'
            );
            
            // 如果用戶點擊取消，則不執行下課操作
            if (!confirmed) {
                showMessage('已取消下課操作', 'info');
                return;
            }
            
            markClassEnded(); // Mark that class has been properly ended
            clearAllQuestionBanks(); // Clear question banks from memory
            showMessage('正在結束課程並清空資料...', 'info');

            // 🚀 OPTIMIZED: 使用 ListenerManager 統一清理所有監聽器
            ListenerManager.clearAll();
            
            // 🚀 CRITICAL: 清空所有全局狀態（防止殘留數據）
            interactionModeUnsubscribe = null;
            studentResponsesUnsubscribe = null;
            lotteryUnsubscribe = null;
            classroomPresenceUnsubscribe = null;

            try {
                // Delete the entire classroom subcollection for the current classroomCode
                if (classroomCode) {
                    console.log(`[Teacher] Starting cleanup for classroom: ${classroomCode}`);
                    
                    // 🚀 FIX: 分別捕獲每個刪除操作的錯誤，避免單一失敗導致整個流程中斷
                    try {
                        const classroomRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses');
                        const responsesSnapshot = await getDocs(classroomRef);
                        console.log(`[Teacher] Deleting ${responsesSnapshot.docs.length} student responses...`);
                        for (const docSnap of responsesSnapshot.docs) {
                            await deleteDoc(docSnap.ref);
                        }
                        console.log('[Teacher] ✓ Student responses deleted');
                    } catch (error) {
                        console.error('[Teacher] ✗ Failed to delete student responses:', error);
                        // 繼續執行，不中斷
                    }

                    try {
                        const presenceRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'presence');
                        const presenceSnapshot = await getDocs(presenceRef);
                        console.log(`[Teacher] Deleting ${presenceSnapshot.docs.length} presence records...`);
                        for (const docSnap of presenceSnapshot.docs) {
                            await deleteDoc(docSnap.ref);
                        }
                        console.log('[Teacher] ✓ Presence records deleted');
                    } catch (error) {
                        console.error('[Teacher] ✗ Failed to delete presence records:', error);
                        // 繼續執行，不中斷
                    }

                    try {
                        const settingsDocRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
                        console.log('[Teacher] Deleting control document...');
                        await deleteDoc(settingsDocRef);
                        console.log('[Teacher] ✓ Control document deleted');
                    } catch (error) {
                        console.error('[Teacher] ✗ Failed to delete control document:', error);
                        // 繼續執行，不中斷
                    }
                    
                    console.log(`[Teacher] ✓ Cleanup completed for classroom: ${classroomCode}`);
                }
                
                classroomCode = null; // Clear the classroom code after ending session
                localStorage.removeItem('teacherClassroomCode'); // Clear from local storage

                // 🚀 CRITICAL: 清空所有全局狀態變量
                studentName = null;
                currentRole = null;
                currentInteractionMode = null;
                allStudentResponses = [];
                activeStudentNames = [];
                activeStudentsPresenceMap.clear(); // 🚀 FIX: 清空學生分心狀態 Map
                lastSelectedStudentCard = null;
                lastSelectedModalStudent = null;
                isResponsePaused = false;
                currentMultipleChoiceQuestions = null;
                readingComprehensionData = {text: '', questions: []}; // 🚀 NEW: 清空閱讀測驗資料
                sequencingData = {question: '', correctOrder: []}; // 🚀 NEW: 清空排序題資料
                matchingData = {question: '', pairs: []}; // 🚀 NEW: 清空配對題資料
                quickPollOptions = []; // 🚀 NEW: 清空快速投票選項
                quickPollData = null; // 🚀 NEW: 清空快速投票數據
                quickPollActive = false; // 🚀 NEW: 重置快速投票狀態
                quickPollVotesUnsubscribe = null; // 🚀 NEW: 清空快速投票監聽器

                document.getElementById('student-responses-container').innerHTML = '<p class="text-gray-500 text-center col-span-full">正在等待學生作答...</p>';
                document.getElementById('active-student-count').textContent = '0';
                // 🚀 FIX: 清空在線學生模態框，避免下次開課時看到舊學生名單
                document.getElementById('modal-student-names').innerHTML = '<p class="text-gray-500 text-sm col-span-full">沒有學生在線</p>';
                // REMOVED: document.getElementById('responded-student-count').textContent = '0';
                document.getElementById('teacher-image-status').textContent = '目前沒有背景圖片。可選擇檔案或直接貼上(Ctrl+V)。';
                document.getElementById('teacher-image-preview').src = '';
                document.getElementById('teacher-image-preview-container').classList.add('hidden');

                // Clear URL/HTML dispatch settings and teacher background image when ending interaction
                clearDispatchSettings(); // Use the combined clear function
                teacherUploadedBackgroundImageDataURL = null;
                document.getElementById('teacher-image-status').textContent = '目前沒有背景圖片。可選擇檔案或直接貼上(Ctrl+V)。';
                document.getElementById('teacher-image-preview').src = '';
                document.getElementById('teacher-image-preview-container').classList.add('hidden');
                isResponsePaused = false; // NEW: Reset pause state
                updateTeacherPauseButtonUI(); // NEW: Update pause button UI

                await signOut(auth); // Explicitly sign out the user
                
                // NEW: After signing out, explicitly sign in again to get a fresh authenticated state
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                    console.log("Signed in with custom token.");
                } else {
                    await signInAnonymously(auth);
                }
                console.log("Re-authenticated after ending session.");

                showView('entry'); // Show the entry view
                showMessage('課程已結束，資料已清空。', 'success');

            } catch (error) {
                console.error("結束課程並清空資料失敗:", error);
                showMessage("結束課程失敗，請檢查網路連線或聯繫管理員。", "error");
            }
        }

        // NEW: Pause/Resume Response Logic
        const togglePauseBtn = document.getElementById('toggle-pause-btn');
        const togglePauseBtnText = document.getElementById('toggle-pause-btn-text');

        /**
         * Toggles the pause state for student responses in Firestore.
         */
        async function toggleResponsePause() {
            if (!classroomCode) {
                showMessage('請先開啟一個教室！', 'error');
                return;
            }
            const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
            try {
                isResponsePaused = !isResponsePaused; // Toggle local state
                await setDoc(controlRef, { isPaused: isResponsePaused }, { merge: true });
                showMessage(`學生回覆已${isResponsePaused ? '暫停' : '恢復'}！`, 'info');
                updateTeacherPauseButtonUI();
            } catch (error) {
                console.error("切換暫停回覆狀態失敗:", error);
                showMessage("切換狀態失敗，請檢查網路連線。", "error");
                isResponsePaused = !isResponsePaused; // Revert local state on error
            }
        }

        /**
         * Updates the teacher's pause button UI based on the `isResponsePaused` state.
         */
        function updateTeacherPauseButtonUI() {
            if (isResponsePaused) {
                togglePauseBtn.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                togglePauseBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                togglePauseBtnText.textContent = '恢復回覆';
                togglePauseBtn.querySelector('i').classList.replace('fa-pause', 'fa-play');
            } else {
                togglePauseBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                togglePauseBtn.classList.add('bg-gray-500', 'hover:bg-gray-600');
                togglePauseBtnText.textContent = '暫停回覆';
                togglePauseBtn.querySelector('i').classList.replace('fa-play', 'fa-pause');
            }
        }

        /**
         * NEW: End current interaction and optionally clean up all settings.
         * @param {Object} options - Configuration options
         * @param {boolean} options.fullReset - If true, clears peer review, dispatch settings, etc. Default: true
         * @param {boolean} options.navigateToMenu - If true, navigates to teacher menu view. Default: true
         */
        async function endInteraction({ fullReset = true, navigateToMenu = true } = {}) {
            console.log(`[endInteraction] Called with fullReset=${fullReset}, navigateToMenu=${navigateToMenu}`);
            
            if (fullReset) {
                // Clear peer review data when ending interaction
                try {
                    const peerReviewRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'peerReview');
                    await setDoc(peerReviewRef, { active: false });
                    
                    const votesRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'peerReviewVotes');
                    const votesSnapshot = await getDocs(votesRef);
                    const deletePromises = votesSnapshot.docs.map(doc => deleteDoc(doc.ref));
                    await Promise.all(deletePromises);
                    
                    peerReviewActive = false;
                    document.getElementById('peer-review-stats-container').classList.add('hidden');
                    
                    const startPeerReviewBtn = document.getElementById('start-peer-review-btn');
                    startPeerReviewBtn.innerHTML = '<i class="fas fa-heart mr-2"></i> 開始互評 ❤️';
                    
                    allPeerReviewVotes = {};
                    studentVotedWorks.clear();
                    savedCanvasState = null;
                    
                    if (peerReviewUnsubscribe) {
                        peerReviewUnsubscribe();
                        peerReviewUnsubscribe = null;
                    }
                } catch (error) {
                    console.error('Error clearing peer review data:', error);
                }
            }
            
            // Set mode to waiting
            await setInteractionMode('waiting');
            lastSelectedStudentCard = null;
            
            if (fullReset) {
                // Clear sequencing and matching input fields
                document.getElementById('sequencing-items-textarea').value = '';
                document.getElementById('matching-pairs-textarea').value = '';
                
                // Clear URL/HTML settings and teacher background image
                clearDispatchSettings();
                teacherUploadedBackgroundImageDataURL = null;
                document.getElementById('teacher-image-status').textContent = '目前沒有背景圖片。可選擇檔案或直接貼上(Ctrl+V)。';
                document.getElementById('teacher-image-preview').src = '';
                document.getElementById('teacher-image-preview-container').classList.add('hidden');
                isResponsePaused = false;
                updateTeacherPauseButtonUI();
                customMultipleChoiceQuestions = [];
            }
            
            if (navigateToMenu) {
                showView('teacherMenu');
                manualRefreshCounts();
            }
            
            console.log('[endInteraction] Completed');
        }

        /**
         * NEW: Reset all student answers to allow starting a new question without exiting the interaction mode.
         * Triggers student UI reset by updating the control document's resetTimestamp.
         */
        async function resetAllAnswers() {
            console.log('[resetAllAnswers] 🔄 CALLED - Starting reset process');
            
            if (!classroomCode) {
                console.log('[resetAllAnswers] ❌ No classroom code');
                showMessage('請先開啟一個教室！', 'error');
                return;
            }
            
            console.log('[resetAllAnswers] Classroom code:', classroomCode);
            
            // 🚀 NEW: Hide teacher answer display and clear content
            const teacherAnswerDisplay = document.getElementById('teacher-answer-display');
            const teacherAnswerContent = document.getElementById('teacher-answer-content');
            if (teacherAnswerDisplay) {
                teacherAnswerDisplay.classList.add('hidden');
            }
            if (teacherAnswerContent) {
                teacherAnswerContent.innerHTML = '';
            }
            
            try {
                const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
                const controlDoc = await getDoc(controlRef);
                const currentMode = controlDoc.exists() ? controlDoc.data().active_mode : null;
                console.log('[resetAllAnswers] Current mode:', currentMode);
                
                // 🎯 STEP 1: 清除所有學生答案（所有模式都需要）
                const studentsColRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses');
                const querySnapshot = await getDocs(studentsColRef);
                
                const updatePromises = [];
                querySnapshot.forEach((docSnapshot) => {
                    const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', docSnapshot.id);
                    updatePromises.push(
                        updateDoc(studentRef, {
                            answer: deleteField(),
                            interactionMode: deleteField(),
                            timestamp: deleteField()
                        })
                    );
                });
                
                if (updatePromises.length > 0) {
                    await Promise.all(updatePromises);
                }
                
                // 🎯 STEP 2: 清除答案顯示標誌（所有模式都需要）
                await setDoc(controlRef, { 
                    resetTimestamp: new Date(),
                    showMatchingAnswer: false,
                    showSequencingAnswer: false
                }, { merge: true });
                
                // 🚀 NEW UX FIX: 搶答模式自動重啟 - 先徹底結束再重新開始，避免競態條件
                if (currentMode === 'quick_answer') {
                    console.log('[resetAllAnswers] 🎯 Quick answer mode detected: starting auto-restart sequence');
                    // STEP 1: 輕量級結束互動（不清除背景圖片、派送設定等）
                    console.log('[resetAllAnswers] STEP 1: Calling endInteraction() with lightweight options...');
                    await endInteraction({ fullReset: false, navigateToMenu: false });
                    console.log('[resetAllAnswers] STEP 1: ✓ endInteraction() completed');
                    
                    // STEP 2: 短暫延遲確保狀態完全清理
                    console.log('[resetAllAnswers] STEP 2: Waiting 300ms for cleanup...');
                    await new Promise(resolve => setTimeout(resolve, 300));
                    console.log('[resetAllAnswers] STEP 2: ✓ Wait completed');
                    
                    // STEP 3: 重新開始搶答模式
                    console.log('[resetAllAnswers] STEP 3: Calling setInteractionMode(quick_answer)...');
                    await setInteractionMode('quick_answer');
                    console.log('[resetAllAnswers] STEP 3: ✓ setInteractionMode completed');
                    
                    showMessage(`✓ 已重新開始搶答！`, 'success');
                    console.log('[resetAllAnswers] ✅ Quick answer auto-restart completed successfully');
                    return;
                }
                
                // 其他模式：顯示一般成功訊息
                showMessage(`✓ 已清除所有學生答案，可以開始下一題！`, 'success');
                
            } catch (error) {
                console.error("清除學生答案失敗:", error);
                console.error("錯誤詳情 - message:", error.message, "code:", error.code, "stack:", error.stack);
                showMessage(`清除答案失敗：${error.message || '未知錯誤'}`, "error");
            }
        }


        // --- Event Listeners ---
        
        /**
         * NEW: Processes an image file (from upload or paste), resizes it, and applies it.
         * @param {File} file - The image file to process.
         * @param {boolean} isTeacher - True if the image is for the teacher's background.
         */
        function handleImageFile(file, isTeacher) {
            if (!file || !file.type.startsWith('image/')) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    let { width, height } = img;

                    // Resize image if it's too large
                    if (width > MAX_IMAGE_DIMENSION || height > MAX_IMAGE_DIMENSION) {
                        if (width > height) {
                            height *= MAX_IMAGE_DIMENSION / width;
                            width = MAX_IMAGE_DIMENSION;
                        } else {
                            width *= MAX_IMAGE_DIMENSION / height;
                            height = MAX_IMAGE_DIMENSION;
                        }
                    }
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    tempCtx.drawImage(img, 0, 0, width, height);
                    const dataUrl = tempCanvas.toDataURL('image/jpeg', JPEG_QUALITY);

                    if (isTeacher) {
                        teacherUploadedBackgroundImageDataURL = dataUrl;
                        // For teacher image, we need to pass statusId, previewId, previewContainerId
                        // These are not directly available in handleImageFile without context.
                        // Let's assume these are passed as arguments or accessed globally.
                        // Re-evaluate how setupImageUpload calls this.
                        document.getElementById('teacher-image-status').textContent = '已上傳背景圖片。可選擇檔案或直接貼上(Ctrl+V)。';
                        document.getElementById('teacher-image-preview').src = dataUrl;
                        document.getElementById('teacher-image-preview-container').classList.remove('hidden');
                        showMessage('背景圖片已上傳！', 'success');
                    } else {
                        studentUploadedImageDataURL = dataUrl;
                        showMessage('圖片已上傳！', 'success');
                        loadStudentImage();
                    }
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        /**
         * MODIFIED: Sets up image upload functionality for both file input and pasting.
         */
        const setupImageUpload = (inputId, statusId, previewContainerId, previewId, clearBtnId, isTeacher) => {
            const input = document.getElementById(inputId);
            const clearBtn = document.getElementById(clearBtnId);
            
            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                e.target.value = ''; // Reset input to allow re-uploading the same file
                if (file) {
                    // Pass the IDs to handleImageFile for teacher-specific updates
                    if (isTeacher) {
                        handleImageFileForTeacher(file, statusId, previewContainerId, previewId);
                    } else {
                        handleImageFile(file, isTeacher);
                    }
                }
            });

            clearBtn.addEventListener('click', () => {
                if (isTeacher) {
                    teacherUploadedBackgroundImageDataURL = null;
                    document.getElementById(statusId).textContent = '目前沒有背景圖片。可選擇檔案或直接貼上(Ctrl+V)。';
                    document.getElementById(previewId).src = '';
                    document.getElementById(previewContainerId).classList.add('hidden');
                    showMessage('背景圖片已清除！', 'info');
                } else {
                    studentUploadedImageDataURL = null;
                    studentImageCtx.clearRect(0, 0, studentImageCanvas.width, studentImageCanvas.height);
                    showMessage('圖片已清除！', 'info');
                    drawCombinedCanvas();
                }
            });
        };

        // NEW: Separate function for teacher image handling to pass specific DOM IDs
        function handleImageFileForTeacher(file, statusId, previewContainerId, previewId) {
            if (!file || !file.type.startsWith('image/')) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    let { width, height } = img;

                    // Resize image if it's too large
                    if (width > MAX_IMAGE_DIMENSION || height > MAX_IMAGE_DIMENSION) {
                        if (width > height) {
                            height *= MAX_IMAGE_DIMENSION / width;
                            width = MAX_IMAGE_DIMENSION;
                        } else {
                            width *= MAX_IMAGE_DIMENSION / height;
                            height = MAX_IMAGE_DIMENSION;
                        }
                    }
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    tempCtx.drawImage(img, 0, 0, width, height);
                    const dataUrl = tempCanvas.toDataURL('image/jpeg', JPEG_QUALITY);

                    teacherUploadedBackgroundImageDataURL = dataUrl;
                    document.getElementById(statusId).textContent = '已上傳背景圖片。可選擇檔案或直接貼上(Ctrl+V)。';
                    document.getElementById(previewId).src = dataUrl;
                    document.getElementById(previewContainerId).classList.remove('hidden');
                    showMessage('背景圖片已上傳！', 'success');
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }


        function setupEventListeners() {
            // Entry screen.
            document.getElementById('teacher-entry-btn').addEventListener('click', () => {
                // Check if passwd=no parameter is present in URL
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('passwd') === 'no') {
                    showView('teacherClassroomCode');
                } else {
                    document.getElementById('teacher-password-modal').classList.remove('hidden');
                }
            });
            document.getElementById('student-entry-btn').addEventListener('click', () => {
                currentRole = 'student';
                showView('studentName');
            });

            // NEW: Teacher classroom code input.
            document.getElementById('teacher-classroom-code-back-btn').addEventListener('click', () => showView('entry'));
            document.getElementById('teacher-classroom-code-submit-btn').addEventListener('click', async () => {
                const code = document.getElementById('teacher-classroom-code-input').value.trim();
                if (code) {
                    try {
                        classroomCode = code;
                        currentRole = 'teacher';
                        document.getElementById('teacher-menu-code-value').textContent = classroomCode; // Update classroom code in teacher menu
                        document.getElementById('end-class-monitor-button-text').textContent = `下課 教室代碼: ${classroomCode}`; // Update button text for monitor view
                        localStorage.setItem('teacherClassroomCode', classroomCode); // Persist teacher's classroom code

                        // Set initial classroom state in Firestore, including isPaused: false
                        const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
                        await setDoc(controlRef, { active_mode: 'waiting', teacherId: userId, backgroundImage: null, isPaused: false, multiple_choice_questions: null }, { merge: true }); 
                        isResponsePaused = false; // Initialize local state
                        updateTeacherPauseButtonUI(); // Update button UI
                        currentMultipleChoiceQuestions = null; // Ensure this is cleared on new class

                        listenToClassroomPresence(); // Ensure presence listener is active
                        showView('teacherMenu');
                        document.getElementById('teacher-classroom-code-input').value = ''; // Clear input
                    } catch (error) {
                        console.error('進入教室失敗:', error);
                        showMessage(`進入教室失敗：${error.message}`, 'error');
                    }
                } else {
                    showMessage('請輸入教室代碼！', 'error');
                }
            });
            document.getElementById('teacher-classroom-code-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') document.getElementById('teacher-classroom-code-submit-btn').click();
            });
            
            // Student name and classroom code submission.
            document.getElementById('submit-name-btn').addEventListener('click', async () => {
                const studentClassroomCode = document.getElementById('student-classroom-code-input').value.trim();
                const name = document.getElementById('student-name-input').value.trim();

                if (!studentClassroomCode) {
                    showMessage('請務必輸入教室代碼！', 'error');
                    return;
                }
                if (!name) {
                    showMessage('請務必輸入姓名！', 'error');
                    return;
                }

                classroomCode = studentClassroomCode; // Set global classroom code for student
                
                // Check if the classroom exists and is active
                const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
                try {
                    const docSnap = await getDoc(controlRef);
                    if (docSnap.exists() && docSnap.data().teacherId) { // Check if control document exists and has a teacher ID
                        studentName = name;
                        document.getElementById('user-id-display').textContent = `${userId} (${studentName})`;
                        document.getElementById('student-welcome-msg').textContent = `你好，${studentName}！`;
                        listenToInteractionMode();
                        listenToPeerReviewStatus(); // NEW: Listen for peer review status
                        listenToLottery(); // <-- 在此新增
                        startStudentAttentionMonitoring(); // NEW: 啟動學生注意力監控
                        showView('studentWaiting');
                        // 🚀 FIX: Set student presence with distraction monitoring fields
                        const presenceRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'presence', userId);
                        await setDoc(presenceRef, { 
                            name: studentName, 
                            timestamp: new Date(),
                            isDistracted: false,
                            distractionCount: 0
                        }, { merge: true });
                    } else {
                        showMessage('教室代碼不存在或老師尚未開啟教室！', 'error');
                    }
                } catch (error) {
                    console.error("檢查教室代碼失敗:", error);
                    showMessage("進入教室失敗，請檢查網路連線或教室代碼。", "error");
                }
            });

            // Teacher mode selection.
            // MODIFIED: B button now opens a menu with Choice/Sequencing/Matching options
            document.getElementById('choice-sequencing-matching-menu-btn').addEventListener('click', () => {
                document.getElementById('choice-sequencing-matching-menu-modal').classList.remove('hidden');
            });

            // Close B menu modal
            document.getElementById('choice-sequencing-matching-menu-close-btn').addEventListener('click', () => {
                document.getElementById('choice-sequencing-matching-menu-modal').classList.add('hidden');
            });

            // Open Multiple Choice Settings from B menu
            document.getElementById('open-multiple-choice-settings-btn').addEventListener('click', () => {
                document.getElementById('choice-sequencing-matching-menu-modal').classList.add('hidden');
                // Initialize modal state based on current customMultipleChoiceQuestions
                const mcQuestionTypeNone = document.querySelector('input[name="mcQuestionType"][value="none"]');
                const mcQuestionTypeCustom = document.querySelector('input[name="mcQuestionType"][value="custom"]');
                const customMcQuestionsSection = document.getElementById('custom-mc-questions-section');
                const customMcQuestionsTextarea = document.getElementById('custom-mc-questions-textarea');
                const customMcQuestionsStatus = document.getElementById('custom-mc-questions-status');

                if (customMultipleChoiceQuestions && customMultipleChoiceQuestions.length > 0) {
                    mcQuestionTypeCustom.checked = true;
                    customMcQuestionsSection.classList.remove('hidden');
                    document.getElementById('question-bank-management-section').classList.remove('hidden');
                    customMcQuestionsTextarea.value = customMultipleChoiceQuestions.map(q => {
                        return `${q.question},${q.correctAnswer},${q.options.join(',')}`;
                    }).join('\n');
                } else {
                    mcQuestionTypeNone.checked = true;
                    customMcQuestionsSection.classList.add('hidden');
                    document.getElementById('question-bank-management-section').classList.add('hidden');
                    customMcQuestionsTextarea.value = '';
                }
                customMcQuestionsStatus.classList.add('hidden');
                document.getElementById('multiple-choice-settings-modal').classList.remove('hidden');
            });

            // Open Sequencing Settings from B menu
            document.getElementById('open-sequencing-settings-btn').addEventListener('click', () => {
                document.getElementById('choice-sequencing-matching-menu-modal').classList.add('hidden');
                document.getElementById('sequencing-settings-modal').classList.remove('hidden');
            });

            // Open Matching Settings from B menu
            document.getElementById('open-matching-settings-btn').addEventListener('click', () => {
                document.getElementById('choice-sequencing-matching-menu-modal').classList.add('hidden');
                document.getElementById('matching-settings-modal').classList.remove('hidden');
            });

            // Sequencing/Matching Menu Button - Keep for compatibility if needed elsewhere
            // Sequencing Settings Button (from menu)
            document.getElementById('sequencing-settings-btn')?.addEventListener('click', () => {
                document.getElementById('sequencing-matching-menu-modal').classList.add('hidden');
                document.getElementById('sequencing-settings-modal').classList.remove('hidden');
            });

            // Matching Settings Button (from menu)
            document.getElementById('matching-settings-btn')?.addEventListener('click', () => {
                document.getElementById('sequencing-matching-menu-modal').classList.add('hidden');
                document.getElementById('matching-settings-modal').classList.remove('hidden');
            });

            // 題型切換按鈕
            document.getElementById('switch-to-matching-btn').addEventListener('click', () => {
                document.getElementById('sequencing-settings-modal').classList.add('hidden');
                document.getElementById('matching-settings-modal').classList.remove('hidden');
            });

            document.getElementById('switch-to-sequencing-btn').addEventListener('click', () => {
                document.getElementById('matching-settings-modal').classList.add('hidden');
                document.getElementById('sequencing-settings-modal').classList.remove('hidden');
            });

            // REMOVED: Old multiple-choice-settings-btn listener (now handled by open-multiple-choice-settings-btn from B menu)

            // Other teacher mode selection buttons (unchanged, directly set mode)
            document.querySelectorAll('#teacher-menu-view button[data-mode]').forEach(button => {
                button.addEventListener('click', async () => {
                    const mode = button.dataset.mode;
                    // MODIFIED: Check dispatch settings for url_dispatch
                    if (mode === 'url_dispatch') {
                        if (dispatchSettings.type === 'url' && !dispatchSettings.url) {
                            showMessage('請先設定要派送的網址！', 'error');
                            showUrlDispatchSettingsModal();
                            return;
                        } else if (dispatchSettings.type === 'html' && !dispatchSettings.htmlContent) {
                            showMessage('請先上傳要派送的 HTML 檔案！', 'error');
                            showUrlDispatchSettingsModal();
                            return;
                        }
                    }
                    showView('teacherMonitor');
                    await setInteractionMode(mode); // Set mode and handle student responses listener
                });
            });

            // End interaction button.
            document.getElementById('end-interaction-btn').addEventListener('click', async () => {
                await endInteraction(); // Use the new endInteraction function with default options (full reset)
            });
            
            // Student answer buttons for default multiple choice.
            document.querySelectorAll('#interaction-true-false .answer-btn, #default-mc-options .answer-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    // NEW: Check pause state before submitting
                    if (isResponsePaused) {
                        showMessage('老師已暫停回覆，無法送出答案。', 'error');
                        return;
                    }
                    // 🎯 保存引用（在 await 之前）
                    const answer = e.currentTarget.dataset.answer;
                    const answerText = e.currentTarget.textContent.trim();
                    const clickedButton = e.currentTarget;
                    const parentDiv = e.currentTarget.closest('div');
                    
                    try {
                        await submitAnswer(answer);
                        
                        // 🎯 NEW: 鎖定所有按鈕（包括被點擊的）
                        if (parentDiv) {
                            parentDiv.querySelectorAll('.answer-btn').forEach(b => {
                                b.disabled = true;
                                b.classList.remove('bg-green-500', 'bg-red-500', 'bg-blue-500', 'bg-yellow-500', 'bg-yellow-600', 'bg-green-600', 'bg-red-600');
                                b.classList.remove('hover:bg-green-600', 'hover:bg-red-600', 'hover:bg-blue-600', 'hover:bg-yellow-600', 'hover:bg-green-600', 'hover:bg-red-600');
                                b.classList.add('bg-gray-400');
                                // 🎯 NEW: 為所有按鈕設置提交標記（防止恢復時重新啟用）
                                b.setAttribute('data-submitted', 'true');
                            });
                        }
                        
                        // 🎯 IMPROVED: 在被點擊按鈕上添加確認圖標（保留原始答案文字）
                        const originalText = clickedButton.getAttribute('data-original-text') || answerText;
                        clickedButton.setAttribute('data-original-text', originalText);
                        clickedButton.innerHTML = `
                            <div class="flex flex-col items-center justify-center gap-1">
                                <span class="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-bold">${answer}</span>
                                <span class="text-xs sm:text-sm flex items-center gap-1">
                                    <i class="fas fa-check-circle"></i>
                                    <span>已送出</span>
                                </span>
                            </div>
                        `;
                        
                        // 🎯 NEW: 顯示確認訊息（類似快速投票）
                        showMessage(`✓ 提交成功！您的答案：${answerText}`, 'success');
                    } catch (error) {
                        console.error('[Answer Button] Submit failed:', error);
                        // submitAnswer 已經顯示了錯誤訊息，這裡不需要重複
                    }
                });
            });

            // Text input submission.
            document.getElementById('submit-text-btn').addEventListener('click', async (e) => {
                // NEW: Check pause state before submitting
                if (isResponsePaused) {
                    showMessage('老師已暫停回覆，無法送出答案。', 'error');
                    return;
                }
                const text = document.getElementById('text-input-area').value.trim();
                if (!text) {
                    showMessage('請輸入答案後再送出！', 'error');
                    return;
                }
                
                // 🎯 保存引用（在 await 之前）
                const submitBtn = e.currentTarget;
                const textArea = document.getElementById('text-input-area');
                
                try {
                    await submitAnswer(text);
                    
                    // 🎯 NEW: 鎖定按鈕和文字區域
                    submitBtn.disabled = true;
                    submitBtn.classList.remove('btn-primary');
                    submitBtn.classList.add('btn-gray');
                    submitBtn.textContent = '✓ 已送出答案';
                    
                    if (textArea) {
                        textArea.disabled = true;
                    }
                    
                    // 🎯 NEW: 顯示確認訊息
                    const displayText = text.length > 50 ? text.substring(0, 50) + '...' : text;
                    showMessage(`✓ 提交成功！您的答案：${displayText}`, 'success');
                } catch (error) {
                    console.error('[Text Input] Submit failed:', error);
                    // submitAnswer 已經顯示了錯誤訊息，這裡不需要重複
                }
            });
            
            // Drawing submission.
            document.getElementById('submit-drawing-btn').addEventListener('click', async (e) => {
                // NEW: Check pause state before submitting
                if (isResponsePaused) {
                    showMessage('老師已暫停回覆，無法送出答案。', 'error');
                    return;
                }
                
                // 🎯 保存引用（在 await 之前）
                const submitBtn = e.currentTarget;
                
                try {
                    const dataUrl = canvas.toDataURL('image/jpeg', JPEG_QUALITY);
                    await submitAnswer(dataUrl);
                    
                    // 🎯 NEW: 鎖定按鈕和畫布
                    submitBtn.disabled = true;
                    submitBtn.classList.remove('btn-primary');
                    submitBtn.classList.add('btn-gray');
                    submitBtn.textContent = '✓ 已送出答案';
                    canvas.style.pointerEvents = 'none';
                    
                    // 🎯 NEW: 顯示確認訊息
                    showMessage('✓ 繪圖已送出！', 'success');
                } catch (error) {
                    console.error('[Drawing] Submit failed:', error);
                    // submitAnswer 已經顯示了錯誤訊息，這裡不需要重複
                }
            });

            // Sequencing submission.
            document.getElementById('submit-sequencing-btn').addEventListener('click', async (e) => {
                if (isResponsePaused) {
                    showMessage('老師已暫停回覆，無法送出答案。', 'error');
                    return;
                }
                const container = document.getElementById('sequencing-items-container');
                const items = Array.from(container.children).map(item => item.dataset.text);
                
                if (items.length === 0) {
                    showMessage('請先排序項目後再送出！', 'error');
                    return;
                }
                
                // 🎯 保存引用（在 await 之前）
                const submitBtn = e.currentTarget;
                
                try {
                    await submitAnswer(JSON.stringify(items));
                    
                    // 🎯 NEW: 鎖定按鈕和禁用拖動
                    submitBtn.disabled = true;
                    submitBtn.classList.remove('btn-primary');
                    submitBtn.classList.add('btn-gray');
                    submitBtn.textContent = '✓ 已送出答案';
                    container.style.pointerEvents = 'none';
                    
                    // 🎯 NEW: 顯示確認訊息
                    showMessage('✓ 排序已送出！', 'success');
                } catch (error) {
                    console.error('[Sequencing] Submit failed:', error);
                    // submitAnswer 已經顯示了錯誤訊息，這裡不需要重複
                }
            });

            // Matching submission.
            document.getElementById('submit-matching-btn').addEventListener('click', async (e) => {
                if (isResponsePaused) {
                    showMessage('老師已暫停回覆，無法送出答案。', 'error');
                    return;
                }
                const matches = [];
                document.querySelectorAll('.matching-item.matched').forEach(item => {
                    if (item.dataset.side === 'left' && item.dataset.matchedWith) {
                        matches.push({
                            left: item.dataset.text,
                            right: item.dataset.matchedWith
                        });
                    }
                });

                if (matches.length === 0) {
                    showMessage('請至少完成一個配對！', 'error');
                    return;
                }

                // 🎯 保存引用（在 await 之前）
                const submitBtn = e.currentTarget;

                try {
                    await submitAnswer(JSON.stringify(matches));
                    
                    // 🎯 NEW: 鎖定按鈕和禁用配對項目
                    submitBtn.disabled = true;
                    submitBtn.classList.remove('btn-primary');
                    submitBtn.classList.add('btn-gray');
                    submitBtn.textContent = '✓ 已送出答案';
                    document.getElementById('matching-column-a').style.pointerEvents = 'none';
                    document.getElementById('matching-column-b').style.pointerEvents = 'none';
                    
                    // 🎯 NEW: 顯示確認訊息
                    showMessage(`✓ 配對已送出！完成 ${matches.length} 組配對`, 'success');
                } catch (error) {
                    console.error('[Matching] Submit failed:', error);
                    // submitAnswer 已經顯示了錯誤訊息，這裡不需要重複
                }
            });

            // 🚀 OPTIMIZED: Drawing board events with throttled draw function
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', throttledDraw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);
            canvas.addEventListener('touchstart', startDrawing, { passive: false });
            canvas.addEventListener('touchmove', throttledDraw, { passive: false });
            canvas.addEventListener('touchend', stopDrawing);
            window.addEventListener('resize', () => {
                if (!views.studentInteraction.classList.contains('hidden') && !interactionUIs.drawing.classList.contains('hidden')) {
                    setupCanvas();
                    loadBackgroundImage();
                    loadStudentImage();
                }
                // 🎨 Redraw matching lines on window resize
                if (!views.studentInteraction.classList.contains('hidden') && !interactionUIs.matching.classList.contains('hidden')) {
                    redrawMatchingLines();
                }
            });

            // Drawing tool controls.
            const colorSelect = document.getElementById('color-select');
            const sizeSelect = document.getElementById('size-select');
            const penToolBtn = document.getElementById('pen-tool-btn');
            const eraserBtn = document.getElementById('eraser-btn');
            colorSelect.addEventListener('change', (e) => {
                drawingCtx.strokeStyle = e.target.value; 
                drawingCtx.globalCompositeOperation = 'source-over'; 
                updateColorSwatch(e.target.value); 
                penToolBtn.classList.add('border-blue-500'); 
                eraserBtn.classList.remove('border-blue-500');
            });
            sizeSelect.addEventListener('change', (e) => { drawingCtx.lineWidth = parseInt(e.target.value); });
            penToolBtn.addEventListener('click', () => {
                drawingCtx.globalCompositeOperation = 'source-over'; 
                drawingCtx.strokeStyle = colorSelect.value; 
                drawingCtx.lineWidth = parseInt(sizeSelect.value); 
                penToolBtn.classList.add('border-blue-500'); 
                eraserBtn.classList.remove('border-blue-500'); 
            });
            eraserBtn.addEventListener('click', () => {
                drawingCtx.globalCompositeOperation = 'destination-out';
                drawingCtx.lineWidth = 15;
                penToolBtn.classList.remove('border-blue-500'); 
                eraserBtn.classList.add('border-blue-500'); 
            });
            document.getElementById('clear-canvas-btn').addEventListener('click', clearDrawingCanvas);
            
            // Image upload handlers (teacher and student).
            setupImageUpload('teacher-image-upload-input', 'teacher-image-status', 'teacher-image-preview-container', 'teacher-image-preview', 'clear-teacher-background-btn', true);
            setupImageUpload('student-image-upload-input', null, null, null, 'clear-student-image-btn', false);

            // NEW: Paste event listener for teacher background image
            document.addEventListener('paste', e => {
                // Only allow pasting when the teacher menu is visible
                if (views.teacherMenu.classList.contains('hidden')) {
                    return;
                }
                
                // Don't interfere if the user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }

                const items = (e.clipboardData || window.clipboardData).items;
                for (const item of items) {
                    if (item.kind === 'file' && item.type.startsWith('image/')) {
                        const file = item.getAsFile();
                        if (file) {
                            // Call the specific teacher image handler
                            handleImageFileForTeacher(file, 'teacher-image-status', 'teacher-image-preview-container', 'teacher-image-preview');
                            e.preventDefault(); // Prevent the image from being pasted as a file object
                            return; // Exit after handling the first image
                        }
                    }
                }
            });

            // Modal close buttons.
            document.getElementById('student-status-area').addEventListener('click', showStudentListModal);
            studentListModalCloseBtn.addEventListener('click', hideStudentListModal);
            document.getElementById('show-statistics-btn').addEventListener('click', showStatisticsModal);
            
            // NEW: View Questions Button
            document.getElementById('view-questions-btn').addEventListener('click', showViewQuestionsModal);
            document.getElementById('view-questions-modal-close-btn').addEventListener('click', hideViewQuestionsModal);
            document.getElementById('cancel-questions-view-btn').addEventListener('click', hideViewQuestionsModal);
            document.getElementById('save-correct-answers-btn').addEventListener('click', saveCorrectAnswers);
            
            // NEW: Download Responses Button
            document.getElementById('download-responses-btn').addEventListener('click', downloadStudentResponses);
            
            // NEW: Show Answer Buttons for Matching and Sequencing
            document.getElementById('show-matching-answer-btn').addEventListener('click', async () => {
                try {
                    const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
                    const docSnap = await getDoc(controlRef);
                    const matchingSettings = docSnap.data()?.matchingSettings;
                    
                    await setDoc(controlRef, { showMatchingAnswer: true }, { merge: true });
                    showMessage('答案已顯示給學生！', 'success');
                    
                    // 🚀 NEW: Display answer on teacher side too
                    if (matchingSettings) {
                        displayTeacherMatchingAnswer(matchingSettings);
                    }
                } catch (error) {
                    console.error('Error showing matching answer:', error);
                    showMessage('顯示答案失敗！', 'error');
                }
            });
            
            document.getElementById('show-sequencing-answer-btn').addEventListener('click', async () => {
                try {
                    const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
                    const docSnap = await getDoc(controlRef);
                    const sequencingSettings = docSnap.data()?.sequencingSettings;
                    
                    await setDoc(controlRef, { showSequencingAnswer: true }, { merge: true });
                    showMessage('答案已顯示給學生！', 'success');
                    
                    // 🚀 NEW: Display answer on teacher side too
                    if (sequencingSettings) {
                        displayTeacherSequencingAnswer(sequencingSettings);
                    }
                } catch (error) {
                    console.error('Error showing sequencing answer:', error);
                    showMessage('顯示答案失敗！', 'error');
                }
            });
            
            // NEW: Start Peer Review Button
            document.getElementById('start-peer-review-btn').addEventListener('click', startPeerReview);
            
            // NEW: Exit Peer Review Button (Student)
            document.getElementById('exit-peer-review-btn').addEventListener('click', exitPeerReview);
            chartModalCloseBtn.addEventListener('click', hideStatisticsModal);
            document.getElementById('download-statistics-btn').addEventListener('click', downloadStatistics);
            magnifiedImageModalCloseBtn.addEventListener('click', hideMagnifiedDrawing);
            magnifiedImageModal.addEventListener('click', (e) => { if (e.target === magnifiedImageModal) hideMagnifiedDrawing(); });
            document.getElementById('close-message-btn').addEventListener('click', hideMessage);

            // NEW: Unsubmitted Students Modal Listeners
            document.getElementById('show-unsubmitted-students-btn').addEventListener('click', showUnsubmittedStudentsModal);
            unsubmittedStudentsModalCloseBtn.addEventListener('click', hideUnsubmittedStudentsModal);
            unsubmittedStudentsModal.addEventListener('click', (e) => { if (e.target === unsubmittedStudentsModal) hideUnsubmittedStudentsModal(); });


            // Teacher utility buttons.
            document.getElementById('refresh-student-count-btn').addEventListener('click', manualRefreshCounts);
            // Original lottery button in monitor view
            document.getElementById('draw-lottery-btn').addEventListener('click', () => {
                // 🚀 FIX: 抽籤邏輯改良 - 優先從已作答學生中抽籤，若無則從所有在線學生中抽籤
                let selectedStudentName;
                let isFromResponses = false;
                
                // 嘗試從已作答學生中抽籤
                if (allStudentResponses.length > 0) {
                    const randomIndex = Math.floor(Math.random() * allStudentResponses.length);
                    selectedStudentName = allStudentResponses[randomIndex].name;
                    isFromResponses = true;
                    console.log('[Lottery] Drawing from student responses:', selectedStudentName);
                } else if (activeStudentNames.length > 0) {
                    // 若無作答學生，從所有在線學生中抽籤（適用於搶答模式）
                    const randomIndex = Math.floor(Math.random() * activeStudentNames.length);
                    selectedStudentName = activeStudentNames[randomIndex];
                    console.log('[Lottery] Drawing from online students:', selectedStudentName);
                } else {
                    return showMessage('目前沒有學生在線可供抽籤。', 'info');
                }
                
                // 清除上次高亮
                if (lastSelectedStudentCard) lastSelectedStudentCard.classList.remove('selected-student-border');
                
                // 嘗試在學生卡片中找到並高亮
                if (isFromResponses) {
                    const studentCards = document.querySelectorAll('#student-responses-container .student-response-item');
                    const foundCard = Array.from(studentCards).find(card => card.getAttribute('data-student-name') === selectedStudentName);
                    if (foundCard) {
                        foundCard.classList.add('selected-student-border');
                        lastSelectedStudentCard = foundCard;
                        foundCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
                
                // 顯示抽籤結果並通知學生
                showMessage(`🎲 恭喜！抽中學生：${selectedStudentName}`, 'success');
                announceDrawnStudent(selectedStudentName);
            });
            // NEW: Lottery button inside the student list modal
            document.getElementById('modal-draw-lottery-btn').addEventListener('click', () => {
                if (activeStudentNames.length === 0) {
                    return showMessage('目前沒有學生在線可供抽籤。', 'info');
                }

                // Remove highlight from previously selected student in the modal
                if (lastSelectedModalStudent) {
                    lastSelectedModalStudent.classList.remove('modal-selected-student-border');
                }

                // Randomly select a student from all active online students
                const randomIndex = Math.floor(Math.random() * activeStudentNames.length);
                const selectedStudentName = activeStudentNames[randomIndex];

                // Find the corresponding <p> element in the modal
                const studentNameElements = document.querySelectorAll('#modal-student-names p');
                // 🚀 FIX: 使用 data-student-name 屬性查找，而不是 textContent（避免分心狀態干擾）
                const foundElement = Array.from(studentNameElements).find(p => p.getAttribute('data-student-name') === selectedStudentName);

                if (foundElement) {
                    foundElement.classList.add('modal-selected-student-border');
                    lastSelectedModalStudent = foundElement; // Store the currently selected element
                    foundElement.scrollIntoView({ behavior: 'smooth', block: 'center' }); // 🚀 FIX: 滾動到選中的學生
                    showMessage(`恭喜！抽中學生：${selectedStudentName}`, 'success');
                    announceDrawnStudent(selectedStudentName); // <-- 在此新增
                } else {
                    console.warn('[Modal Lottery] Student element not found:', selectedStudentName);
                    showMessage(`抽中學生：${selectedStudentName} (未在列表中找到)`, 'info');
                }
            });


            document.getElementById('download-media-btn').addEventListener('click', async (e) => { // Changed ID
                const btn = e.currentTarget;
                if (btn.disabled) return;
                
                let mediaResponses = [];
                let filenamePrefix = '';
                let fileExtension = '';

                if (currentInteractionMode === 'drawing') {
                    mediaResponses = allStudentResponses.filter(r => r.answer && r.answer.startsWith('data:image'));
                    filenamePrefix = '學生繪圖答案';
                    fileExtension = 'jpg';
                } else if (currentInteractionMode === 'recording') {
                    mediaResponses = allStudentResponses.filter(r => r.answer && r.answer.startsWith('data:audio'));
                    filenamePrefix = '學生錄音答案';
                    // Determine file extension based on the actual mimeType used for recording
                    const firstAudioResponse = mediaResponses.find(r => r.answer);
                    if (firstAudioResponse) {
                        const mime = firstAudioResponse.answer.split(',')[0].match(/:(.*?);/)?.[1];
                        if (mime) {
                            if (mime.includes('webm')) fileExtension = 'webm';
                            else if (mime.includes('mp4')) fileExtension = 'mp4';
                            else if (mime.includes('ogg')) fileExtension = 'ogg';
                            else if (mime.includes('wav')) fileExtension = 'wav';
                            else fileExtension = 'bin'; // Fallback for unknown
                        } else {
                            fileExtension = 'bin'; // Fallback if mime type not found in data URL
                        }
                    } else {
                        fileExtension = 'webm'; // Default if no audio responses
                    }
                } else {
                    return showMessage('目前模式不支援下載媒體。', 'info');
                }

                if (mediaResponses.length === 0) return showMessage(`目前沒有${filenamePrefix}可供下載。`, 'info');
                
                btn.disabled = true;
                showMessage(`正在打包${filenamePrefix}...`, 'info');
                const zip = new JSZip();
                const dataURLToBlob = (dataurl) => {
                    const [header, body] = dataurl.split(',');
                    const mime = header.match(/:(.*?);/)[1];
                    const bstr = atob(body);
                    let n = bstr.length;
                    const u8arr = new Uint8Array(n);
                    while(n--) u8arr[n] = bstr.charCodeAt(n);
                    return new Blob([u8arr], {type:mime});
                };
                
                mediaResponses.forEach(r => {
                    // Ensure unique filenames for students with same name but different recordings if needed
                    // For now, just use student name.
                    zip.file(`${r.name}.${fileExtension}`, dataURLToBlob(r.answer));
                });

                try {
                    const content = await zip.generateAsync({type:"blob"});
                    const filename = generateFilename(filenamePrefix, 'zip');
                    saveAs(content, filename);
                    showMessage(`已成功打包 ${mediaResponses.length} 個檔案並開始下載。`, 'success');
                } catch (error) {
                    console.error("打包媒體失敗:", error);
                    showMessage("打包媒體失敗，請檢查瀏覽器支援或檔案大小。", "error");
                } finally {
                    btn.disabled = false;
                }
            });
            
            // AI-related buttons and modals.
            document.getElementById('ai-text-summary-btn').addEventListener('click', async () => {
                // 🚀 UX: 檢查 API KEY 是否已設定
                if (!checkAPIKey()) return;
                
                const textResponses = allStudentResponses.filter(r => currentInteractionMode === 'text_input' && r.answer && r.answer.trim()).map(r => r.answer);
                if (textResponses.length === 0) return showMessage('目前沒有文字回答可供 AI 分析。', 'info');
                const aiSummaryModal = document.getElementById('ai-summary-modal');
                const aiLoadingSpinner = document.getElementById('ai-loading-spinner');
                const aiSummaryResultList = document.getElementById('ai-summary-result-list');
                aiSummaryModal.classList.remove('hidden');
                aiLoadingSpinner.classList.remove('hidden');
                aiSummaryResultList.innerHTML = '';
                const prompt = `請分析以下學生回答的文本內容，識別出語義上相似的詞語或短語，歸類為主要詞彙並統計總出現次數。列出最常出現的10個主要詞彙。請以繁體中文回應，排除常見助詞、連接詞、標點符號。使用JSON格式返回結果：[{"word": "主要詞彙1", "count": 10}]。若無有意義詞彙，返回空陣列[]。文本內容：\n${textResponses.join('\n\n')}`;
                try {
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: prompt }] }],
                        generationConfig: { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "OBJECT", properties: { "word": { "type": "STRING" }, "count": { "type": "NUMBER" } }, "propertyOrdering": ["word", "count"] } } }
                    };
                    const apiKey = (aiSettings.aiSource === 'gemini-custom' && aiSettings.geminiApiKey) ? aiSettings.geminiApiKey : "";
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    
                    if (!response.ok) {
                        const errorBody = await response.text();
                        console.error(`[AI 文字分析] API 錯誤 ${response.status}:`, errorBody);
                        if (response.status === 400) {
                            throw new Error('❌ API KEY 無效或格式錯誤，請檢查您的 Google AI Studio API Key 設定！');
                        }
                        throw new Error(`API request failed: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    aiLoadingSpinner.classList.add('hidden');
                    const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    const parsedResults = jsonText ? JSON.parse(jsonText) : [];
                    if (parsedResults.length > 0) {
                        parsedResults.sort((a, b) => b.count - a.count).forEach(item => {
                            const li = document.createElement('li');
                            li.textContent = `${item.word} (${item.count}次)`;
                            aiSummaryResultList.appendChild(li);
                        });
                    } else {
                        aiSummaryResultList.innerHTML = '<li>沒有找到常用詞彙。</li>';
                    }
                } catch (error) {
                    console.error("AI 文字分析失敗:", error);
                    aiLoadingSpinner.classList.add('hidden');
                    const errorMsg = error.message.includes('API KEY') ? error.message : 'AI 分析失敗，請檢查 API Key 或網路連線。';
                    aiSummaryResultList.innerHTML = `<li class="error-message">${errorMsg}</li>`;
                    showMessage(errorMsg, 'error');
                }
            });
            document.getElementById('ai-summary-modal-close-btn').addEventListener('click', () => document.getElementById('ai-summary-modal').classList.add('hidden'));
            document.getElementById('ai-settings-btn').addEventListener('click', showAISettingsModal);
            aiSettingsModalCloseBtn.addEventListener('click', hideAISettingsModal);
            saveAiSettingsBtn.addEventListener('click', saveAISettings);
            aiSourceSelect.addEventListener('change', (e) => geminiApiKeyGroup.classList.toggle('hidden', e.target.value !== 'gemini-custom'));

            // New: URL/HTML Dispatch Settings Modal listeners.
            document.getElementById('url-dispatch-settings-btn').addEventListener('click', showUrlDispatchSettingsModal);
            urlDispatchModalCloseBtn.addEventListener('click', hideUrlDispatchSettingsModal);
            document.getElementById('save-dispatch-settings-btn').addEventListener('click', saveDispatchSettings); // Renamed
            document.getElementById('clear-dispatch-settings-btn').addEventListener('click', clearDispatchSettings); // Renamed

            // Sequencing Settings Modal listeners
            document.getElementById('sequencing-settings-modal-close-btn').addEventListener('click', () => {
                document.getElementById('sequencing-settings-modal').classList.add('hidden');
            });
            document.getElementById('cancel-sequencing-settings-btn').addEventListener('click', () => {
                document.getElementById('sequencing-settings-modal').classList.add('hidden');
            });
            document.getElementById('start-sequencing-interaction-btn').addEventListener('click', async () => {
                const question = '排序題';
                const itemsText = document.getElementById('sequencing-items-textarea').value.trim();

                if (!itemsText) {
                    showMessage('請輸入排序項目！', 'error');
                    return;
                }

                const items = itemsText.split('\n').map(item => item.trim()).filter(item => item);
                if (items.length < 2) {
                    showMessage('至少需要兩個排序項目！', 'error');
                    return;
                }

                sequencingData.question = question;
                sequencingData.correctOrder = items;

                document.getElementById('sequencing-settings-modal').classList.add('hidden');
                showView('teacherMonitor');
                await setInteractionMode('sequencing', {
                    question: question,
                    correctOrder: items
                });
            });

            // Matching Settings Modal listeners
            document.getElementById('matching-settings-modal-close-btn').addEventListener('click', () => {
                document.getElementById('matching-settings-modal').classList.add('hidden');
            });
            document.getElementById('cancel-matching-settings-btn').addEventListener('click', () => {
                document.getElementById('matching-settings-modal').classList.add('hidden');
            });
            document.getElementById('start-matching-interaction-btn').addEventListener('click', async () => {
                const question = '配對題';
                const pairsText = document.getElementById('matching-pairs-textarea').value.trim();

                if (!pairsText) {
                    showMessage('請輸入配對項目！', 'error');
                    return;
                }

                const lines = pairsText.split('\n').map(line => line.trim()).filter(line => line);
                const pairs = [];

                for (const line of lines) {
                    const parts = line.split(/[,\t]/).map(p => p.trim()).filter(p => p);
                    if (parts.length >= 2) {
                        pairs.push({ left: parts[0], right: parts[1] });
                    }
                }

                if (pairs.length < 2) {
                    showMessage('至少需要兩對配對項目！', 'error');
                    return;
                }

                matchingData.question = question;
                matchingData.pairs = pairs;

                document.getElementById('matching-settings-modal').classList.add('hidden');
                showView('teacherMonitor');
                await setInteractionMode('matching', {
                    question: question,
                    pairs: pairs
                });
            });

            // Quick Poll Settings Modal listeners
            document.getElementById('quick-poll-settings-btn').addEventListener('click', showQuickPollSettingsModal);
            document.getElementById('quick-poll-settings-modal-close-btn').addEventListener('click', hideQuickPollSettingsModal);
            document.getElementById('cancel-quick-poll-settings-btn').addEventListener('click', hideQuickPollSettingsModal);
            document.getElementById('start-quick-poll-btn').addEventListener('click', startQuickPoll);

            // Quick Poll Stats Modal listeners
            document.getElementById('quick-poll-stats-modal-close-btn').addEventListener('click', hideQuickPollStatsModal);
            document.getElementById('end-quick-poll-btn').addEventListener('click', endQuickPoll);
            document.getElementById('download-poll-results-btn').addEventListener('click', downloadPollResults);
            document.getElementById('chart-type-bar-btn').addEventListener('click', () => switchChartType('bar'));
            document.getElementById('chart-type-pie-btn').addEventListener('click', () => switchChartType('pie'));

            // Poll type radio button listeners
            document.querySelectorAll('input[name="pollType"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const customSection = document.getElementById('custom-poll-options-section');
                    customSection.classList.toggle('hidden', e.target.value !== 'custom');
                });
            });

            // NEW: Event listeners for dispatch type radio buttons
            dispatchTypeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const selectedType = e.target.value;
                    urlDispatchSection.classList.toggle('hidden', selectedType === 'html');
                    htmlDispatchSection.classList.toggle('hidden', selectedType === 'url');
                });
            });

            // NEW: HTML upload/clear listeners within the dispatch settings modal
            dispatchHtmlUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                e.target.value = ''; // Reset input
                if (file) {
                    handleDispatchHtmlFile(file);
                }
            });
            clearDispatchHtmlBtn.addEventListener('click', () => {
                dispatchSettings.htmlContent = null; // Clear content in global state
                dispatchHtmlUploadInput.value = ''; // Clear file input
                dispatchHtmlStatus.textContent = '目前沒有 HTML 檔案。';
                showMessage('HTML 檔案已清除！', 'info');
            });


            // New: Recording button event listeners
            startRecordingBtn.addEventListener('click', async () => {
                // NEW: Check pause state before starting recording
                if (isResponsePaused) {
                    showMessage('老師已暫停回覆，無法開始錄音。', 'error');
                    return;
                }
                startRecording();
            });
            stopRecordingBtn.addEventListener('click', stopRecording);
            playRecordingBtn.addEventListener('click', playRecording);
            resetRecordingBtn.addEventListener('click', resetRecording);
            submitRecordingBtn.addEventListener('click', async () => {
                // NEW: Check pause state before submitting recording
                if (isResponsePaused) {
                    showMessage('老師已暫停回覆，無法送出錄音。', 'error');
                    return;
                }
                if (!audioDataURL) {
                    showMessage('沒有錄音可送出', 'error');
                    return;
                }
                
                try {
                    await submitAnswer(audioDataURL);
                    
                    // 🎯 NEW: 鎖定所有錄音相關按鈕
                    submitRecordingBtn.disabled = true;
                    submitRecordingBtn.classList.remove('btn-primary');
                    submitRecordingBtn.classList.add('btn-gray');
                    submitRecordingBtn.textContent = '✓ 已送出答案';
                    startRecordingBtn.disabled = true;
                    stopRecordingBtn.disabled = true;
                    playRecordingBtn.disabled = true;
                    resetRecordingBtn.disabled = true;
                    recordingStatusText.textContent = '已送出錄音答案';
                    
                    // 🎯 NEW: 顯示確認訊息
                    showMessage('✓ 錄音已送出！', 'success');
                } catch (error) {
                    console.error('[Recording] Submit failed:', error);
                    // submitAnswer 已經顯示了錯誤訊息，這裡不需要重複
                }
            });

            // NEW: Toggle Pause Button Event Listener
            togglePauseBtn.addEventListener('click', toggleResponsePause);

            // NEW: Reset Answers Button Event Listener
            const resetAnswersBtn = document.getElementById('reset-answers-btn');
            if (resetAnswersBtn) {
                resetAnswersBtn.addEventListener('click', () => {
                    console.log('🔄 Reset button clicked!');
                    resetAllAnswers();
                });
                console.log('✓ Reset answers button event listener attached');
            } else {
                console.error('❌ Reset answers button not found!');
            }

            // End Class Session Buttons.
            document.getElementById('end-class-session-menu-btn').addEventListener('click', endClassSession);
            document.getElementById('end-class-session-monitor-btn').addEventListener('click', endClassSession);

            // NEW: Multiple Choice Settings Modal Listeners
            const multipleChoiceSettingsModal = document.getElementById('multiple-choice-settings-modal');
            const multipleChoiceSettingsModalCloseBtn = document.getElementById('multiple-choice-settings-modal-close-btn');
            const mcQuestionTypeRadios = document.querySelectorAll('input[name="mcQuestionType"]');
            const customMcQuestionsSection = document.getElementById('custom-mc-questions-section');
            const customMcQuestionsTextarea = document.getElementById('custom-mc-questions-textarea');
            const customMcQuestionsStatus = document.getElementById('custom-mc-questions-status');
            const startMcInteractionBtn = document.getElementById('start-mc-interaction-btn');
            const cancelMcSettingsBtn = document.getElementById('cancel-mc-settings-btn');
            
            // AI Question Generation elements
            const aiGenerateMcBtn = document.getElementById('ai-generate-mc-btn');
            const aiMcTopicTextarea = document.getElementById('ai-mc-topic-textarea');
            const aiMcCountInput = document.getElementById('ai-mc-count-input');
            const aiMcLoadingSpinner = document.getElementById('ai-mc-loading-spinner');
            const aiMcBtnText = document.getElementById('ai-mc-btn-text');
            const aiMcBtnIcon = document.getElementById('ai-mc-btn-icon');

            // Question Bank Management elements
            const questionBankFileInput = document.getElementById('question-bank-file-input');
            const loadQuestionBankBtn = document.getElementById('load-question-bank-btn');
            const questionBankNameInput = document.getElementById('question-bank-name-input');
            const saveQuestionBankBtn = document.getElementById('save-question-bank-btn');
            const questionBankList = document.getElementById('question-bank-list');


            multipleChoiceSettingsModalCloseBtn.addEventListener('click', () => multipleChoiceSettingsModal.classList.add('hidden'));
            cancelMcSettingsBtn.addEventListener('click', () => multipleChoiceSettingsModal.classList.add('hidden'));

            // Question Bank Management Event Listeners
            loadQuestionBankBtn.addEventListener('click', loadQuestionBankFromFile);
            saveQuestionBankBtn.addEventListener('click', saveQuestionBankFromTextarea);

            // Teacher Password Modal Event Listeners
            const teacherPasswordModal = document.getElementById('teacher-password-modal');
            const teacherPasswordModalCloseBtn = document.getElementById('teacher-password-modal-close-btn');
            const teacherPasswordInput = document.getElementById('teacher-password-input');
            const teacherPasswordSubmitBtn = document.getElementById('teacher-password-submit-btn');
            const teacherPasswordCancelBtn = document.getElementById('teacher-password-cancel-btn');

            teacherPasswordModalCloseBtn.addEventListener('click', () => {
                teacherPasswordModal.classList.add('hidden');
                teacherPasswordInput.value = '';
            });
            teacherPasswordCancelBtn.addEventListener('click', () => {
                teacherPasswordModal.classList.add('hidden');
                teacherPasswordInput.value = '';
            });
            teacherPasswordSubmitBtn.addEventListener('click', () => {
                const password = teacherPasswordInput.value.trim();
                if (password === 'smessmes') {
                    teacherPasswordModal.classList.add('hidden');
                    teacherPasswordInput.value = '';
                    showView('teacherClassroomCode');
                } else {
                    showMessage('密碼錯誤！', 'error');
                    teacherPasswordInput.value = '';
                    teacherPasswordInput.focus();
                }
            });
            teacherPasswordInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    teacherPasswordSubmitBtn.click();
                }
            });

            mcQuestionTypeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const isCustomMode = e.target.value === 'custom';
                    customMcQuestionsSection.classList.toggle('hidden', !isCustomMode);
                    document.getElementById('question-bank-management-section').classList.toggle('hidden', !isCustomMode);
                    customMcQuestionsStatus.classList.add('hidden'); // Hide status when changing radio
                });
            });

            startMcInteractionBtn.addEventListener('click', async () => {
                const selectedType = document.querySelector('input[name="mcQuestionType"]:checked').value;
                let questionsToDispatch = null;

                if (selectedType === 'custom') {
                    const parsedQuestions = parseCustomQuestions(customMcQuestionsTextarea.value);
                    if (!parsedQuestions) {
                        customMcQuestionsStatus.classList.remove('hidden');
                        return; // Stop if parsing failed
                    }
                    questionsToDispatch = parsedQuestions;
                    customMultipleChoiceQuestions = parsedQuestions; // Update global for teacher UI
                } else {
                    customMultipleChoiceQuestions = []; // Clear global if switching to none
                }
                
                customMcQuestionsStatus.classList.add('hidden'); // Hide status on successful dispatch
                multipleChoiceSettingsModal.classList.add('hidden');
                showView('teacherMonitor');
                await setInteractionMode('multiple_choice', { customQuestions: questionsToDispatch });
            });

            // AI Question Generation Button Listener
            aiGenerateMcBtn.addEventListener('click', async () => {
                // 🚀 UX: 檢查 API KEY 是否已設定
                if (!checkAPIKey()) return;
                
                const topic = aiMcTopicTextarea.value.trim();
                const count = parseInt(aiMcCountInput.value);

                if (!topic) {
                    showMessage('請輸入出題主題或要求！', 'error');
                    return;
                }
                if (!count || count < 1 || count > 10) {
                    showMessage('出題數量必須介於 1 到 10 之間！', 'error');
                    return;
                }
                
                // Show loading state
                aiGenerateMcBtn.disabled = true;
                aiMcBtnText.textContent = 'AI 思考中...';
                aiMcBtnIcon.classList.remove('fa-magic');
                aiMcBtnIcon.classList.add('fa-spinner', 'fa-spin');
                aiMcLoadingSpinner.classList.remove('hidden');

                const prompt = `請根據以下要求，生成 ${count} 題選擇題。
                要求：${topic}
                請嚴格遵守以下格式，每題一行，並用逗號分隔每個欄位：
                題目,正確答案(1-4),選項1,選項2,選項3,選項4
                請勿包含題號、任何多餘的說明文字或程式碼區塊標記。`;

                try {
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: prompt }] }],
                        generationConfig: { temperature: 0.7 } // Adjust temperature for creativity
                    };
                    const apiKey = aiSettings.geminiApiKey;
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

                    if (!response.ok) {
                        const errorBody = await response.text();
                        console.error(`[AI 選擇題生成] API 錯誤 ${response.status}:`, errorBody);
                        if (response.status === 400) {
                            throw new Error('❌ API KEY 無效或格式錯誤，請檢查您的 Google AI Studio API Key 設定！');
                        }
                        throw new Error(`AI API request failed with status ${response.status}`);
                    }

                    const result = await response.json();
                    const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    
                    if (generatedText) {
                        // Append to existing content, adding a newline if needed
                        const existingText = customMcQuestionsTextarea.value.trim();
                        customMcQuestionsTextarea.value = existingText ? `${existingText}\n${generatedText.trim()}` : generatedText.trim();
                        showMessage('AI 題目已成功生成並填入左方！', 'success');
                    } else {
                        throw new Error('AI 未返回有效內容。');
                    }

                } catch (error) {
                    console.error("AI 選擇題生成失敗:", error);
                    const errorMsg = error.message.includes('API KEY') ? error.message : 'AI 題目生成失敗，請檢查 API Key 或網路連線。';
                    showMessage(errorMsg, 'error');
                } finally {
                    // Hide loading state
                    aiGenerateMcBtn.disabled = false;
                    aiMcBtnText.textContent = 'AI 開始出題';
                    aiMcBtnIcon.classList.add('fa-magic');
                    aiMcBtnIcon.classList.remove('fa-spinner', 'fa-spin');
                    aiMcLoadingSpinner.classList.add('hidden');
                }
            });

            // AI Sequencing Question Generation Button Listener
            const aiGenerateSeqBtn = document.getElementById('ai-generate-seq-btn');
            const aiSeqTopicTextarea = document.getElementById('ai-seq-topic-textarea');
            const aiSeqCountInput = document.getElementById('ai-seq-count-input');
            const aiSeqBtnText = document.getElementById('ai-seq-btn-text');
            const aiSeqBtnIcon = document.getElementById('ai-seq-btn-icon');
            const aiSeqLoadingSpinner = document.getElementById('ai-seq-loading-spinner');

            aiGenerateSeqBtn.addEventListener('click', async () => {
                // 🚀 UX: 檢查 API KEY 是否已設定
                if (!checkAPIKey()) return;
                
                const topic = aiSeqTopicTextarea.value.trim();
                const count = parseInt(aiSeqCountInput.value);

                if (!topic) {
                    showMessage('請輸入出題主題或要求！', 'error');
                    return;
                }
                if (!count || count < 3 || count > 10) {
                    showMessage('項目數量必須介於 3 到 10 之間！', 'error');
                    return;
                }

                // Show loading state
                aiGenerateSeqBtn.disabled = true;
                aiSeqBtnText.textContent = 'AI 思考中...';
                aiSeqBtnIcon.classList.remove('fa-magic');
                aiSeqBtnIcon.classList.add('fa-spinner', 'fa-spin');
                aiSeqLoadingSpinner.classList.remove('hidden');

                const prompt = `請根據以下主題，生成 ${count} 個排序項目。
主題：${topic}
請按正確順序列出，每個項目一行，不要有題號或任何標記。
只需提供項目內容，不要包含說明文字或程式碼區塊標記。`;

                try {
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: prompt }] }],
                        generationConfig: { temperature: 0.7 }
                    };
                    const apiKey = aiSettings.geminiApiKey;
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

                    if (!response.ok) {
                        const errorBody = await response.text();
                        console.error(`[AI 排序題生成] API 錯誤 ${response.status}:`, errorBody);
                        if (response.status === 400) {
                            throw new Error('❌ API KEY 無效或格式錯誤，請檢查您的 Google AI Studio API Key 設定！');
                        }
                        throw new Error(`AI API request failed with status ${response.status}`);
                    }

                    const result = await response.json();
                    const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (generatedText) {
                        const sequencingItemsTextarea = document.getElementById('sequencing-items-textarea');
                        sequencingItemsTextarea.value = generatedText.trim();
                        showMessage('AI 排序題已成功生成並填入！', 'success');
                    } else {
                        throw new Error('AI 未返回有效內容。');
                    }

                } catch (error) {
                    console.error("AI 排序題生成失敗:", error);
                    const errorMsg = error.message.includes('API KEY') ? error.message : 'AI 排序題生成失敗，請檢查 API Key 或網路連線。';
                    showMessage(errorMsg, 'error');
                } finally {
                    // Hide loading state
                    aiGenerateSeqBtn.disabled = false;
                    aiSeqBtnText.textContent = 'AI 開始出題';
                    aiSeqBtnIcon.classList.add('fa-magic');
                    aiSeqBtnIcon.classList.remove('fa-spinner', 'fa-spin');
                    aiSeqLoadingSpinner.classList.add('hidden');
                }
            });

            // AI Matching Question Generation Button Listener
            const aiGenerateMatchBtn = document.getElementById('ai-generate-match-btn');
            const aiMatchTopicTextarea = document.getElementById('ai-match-topic-textarea');
            const aiMatchCountInput = document.getElementById('ai-match-count-input');
            const aiMatchBtnText = document.getElementById('ai-match-btn-text');
            const aiMatchBtnIcon = document.getElementById('ai-match-btn-icon');
            const aiMatchLoadingSpinner = document.getElementById('ai-match-loading-spinner');

            aiGenerateMatchBtn.addEventListener('click', async () => {
                // 🚀 UX: 檢查 API KEY 是否已設定
                if (!checkAPIKey()) return;
                
                const topic = aiMatchTopicTextarea.value.trim();
                const count = parseInt(aiMatchCountInput.value);

                if (!topic) {
                    showMessage('請輸入出題主題或要求！', 'error');
                    return;
                }
                if (!count || count < 3 || count > 10) {
                    showMessage('配對數量必須介於 3 到 10 之間！', 'error');
                    return;
                }

                // Show loading state
                aiGenerateMatchBtn.disabled = true;
                aiMatchBtnText.textContent = 'AI 思考中...';
                aiMatchBtnIcon.classList.remove('fa-magic');
                aiMatchBtnIcon.classList.add('fa-spinner', 'fa-spin');
                aiMatchLoadingSpinner.classList.remove('hidden');

                const prompt = `請根據以下主題，生成 ${count} 組配對題。
主題：${topic}
每行格式：左側項目,右側項目
不要有題號、說明文字或程式碼區塊標記。
直接提供配對內容，每行一組。`;

                try {
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: prompt }] }],
                        generationConfig: { temperature: 0.7 }
                    };
                    const apiKey = aiSettings.geminiApiKey;
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

                    if (!response.ok) {
                        const errorBody = await response.text();
                        console.error(`[AI 配對題生成] API 錯誤 ${response.status}:`, errorBody);
                        if (response.status === 400) {
                            throw new Error('❌ API KEY 無效或格式錯誤，請檢查您的 Google AI Studio API Key 設定！');
                        }
                        throw new Error(`AI API request failed with status ${response.status}`);
                    }

                    const result = await response.json();
                    const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (generatedText) {
                        const matchingPairsTextarea = document.getElementById('matching-pairs-textarea');
                        matchingPairsTextarea.value = generatedText.trim();
                        showMessage('AI 配對題已成功生成並填入！', 'success');
                    } else {
                        throw new Error('AI 未返回有效內容。');
                    }

                } catch (error) {
                    console.error("AI 配對題生成失敗:", error);
                    const errorMsg = error.message.includes('API KEY') ? error.message : 'AI 配對題生成失敗，請檢查 API Key 或網路連線。';
                    showMessage(errorMsg, 'error');
                } finally {
                    // Hide loading state
                    aiGenerateMatchBtn.disabled = false;
                    aiMatchBtnText.textContent = 'AI 開始出題';
                    aiMatchBtnIcon.classList.add('fa-magic');
                    aiMatchBtnIcon.classList.remove('fa-spinner', 'fa-spin');
                    aiMatchLoadingSpinner.classList.add('hidden');
                }
            });

            // Sequencing Question Bank Management Listeners
            document.getElementById('load-seq-bank-btn').addEventListener('click', loadSequencingBankFromFile);
            document.getElementById('save-seq-bank-btn').addEventListener('click', saveSequencingBank);

            // Matching Question Bank Management Listeners
            document.getElementById('load-match-bank-btn').addEventListener('click', loadMatchingBankFromFile);
            document.getElementById('save-match-bank-btn').addEventListener('click', saveMatchingBank);

            // Reading Comprehension Listeners
            document.getElementById('reading-comprehension-settings-btn')?.addEventListener('click', showReadingComprehensionModal);
            document.getElementById('reading-comprehension-settings-modal-close-btn')?.addEventListener('click', hideReadingComprehensionModal);
            document.getElementById('cancel-reading-settings-btn')?.addEventListener('click', hideReadingComprehensionModal);
            document.getElementById('start-reading-interaction-btn')?.addEventListener('click', startReadingComprehension);
            document.getElementById('submit-reading-btn')?.addEventListener('click', submitReadingAnswer);
            document.getElementById('ai-generate-reading-btn')?.addEventListener('click', generatePIRLSQuestions);
            document.getElementById('load-reading-files-btn')?.addEventListener('click', loadReadingFiles);
            document.getElementById('save-reading-question-bank-btn')?.addEventListener('click', saveReadingQuestionBank);

            // View Reading Questions Modal Listeners
            document.getElementById('view-reading-questions-btn')?.addEventListener('click', showViewReadingQuestionsModal);
            document.getElementById('view-reading-questions-modal-close-btn')?.addEventListener('click', hideViewReadingQuestionsModal);
            document.getElementById('close-reading-questions-view-btn')?.addEventListener('click', hideViewReadingQuestionsModal);


            // NEW: Student side custom multiple choice submission
            document.getElementById('submit-custom-mc-btn').addEventListener('click', async (e) => {
                // NEW: Check pause state before submitting
                if (isResponsePaused) {
                    showMessage('老師已暫停回覆，無法送出答案。', 'error');
                    return;
                }

                // NEW: 檢查是否已經提交過答案
                const hasSubmitted = await checkIfStudentSubmitted();
                if (hasSubmitted) {
                    showMessage('您已經提交過答案，無法重複提交。', 'error');
                    return;
                }

                const studentAnswers = [];
                const questionContainers = document.querySelectorAll('#custom-mc-questions-container .mc-question-item');
                let allAnswered = true;

                questionContainers.forEach((qContainer, index) => {
                    const selectedOption = qContainer.querySelector(`input[name="question-${index}"]:checked`);
                    if (selectedOption) {
                        studentAnswers.push({ qIndex: index, ans: selectedOption.value });
                    } else {
                        allAnswered = false;
                    }
                });

                if (!allAnswered) {
                    showMessage('請回答所有題目！', 'error');
                    return;
                }

                // 🎯 保存引用（在 await 之前）
                const submitBtn = e.currentTarget;

                try {
                    await submitAnswer(studentAnswers);
                    
                    // 🎯 NEW: 更新UI顯示已提交狀態
                    submitBtn.disabled = true;
                    submitBtn.classList.remove('btn-primary');
                    submitBtn.classList.add('btn-gray');
                    submitBtn.textContent = '✓ 已送出答案';
                    
                    // Disable all radio buttons after submission
                    document.querySelectorAll('#custom-mc-questions-container input[type="radio"]').forEach(radio => {
                        radio.disabled = true;
                    });
                    
                    // 🎯 NEW: 顯示確認訊息
                    showMessage(`✓ 提交成功！已完成 ${studentAnswers.length} 題`, 'success');
                } catch (error) {
                    console.error('[Custom MC] Submit failed:', error);
                    // submitAnswer 已經顯示了錯誤訊息，這裡不需要重複
                }
            });
        }

        /**
         * NEW: Parses custom multiple choice questions from a textarea string.
         * Expected format per line: Question,CorrectAnswer(1-4/A-D),Option1,Option2,Option3,Option4
         * @param {string} rawText - The raw string from the textarea.
         * @returns {Array|null} An array of question objects, or null if parsing fails.
         */
        function parseCustomQuestions(rawText) {
            const lines = rawText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            const questions = [];

            for (const line of lines) {
                // Try splitting by comma first, then by tab if comma yields too few parts
                let parts = line.split(',');
                if (parts.length < 6) {
                    parts = line.split('\t');
                }

                if (parts.length !== 6) {
                    console.error("Invalid line format:", line);
                    return null; // Invalid format
                }

                const questionText = parts[0].trim();
                let correctAnswer = parts[1].trim().toUpperCase();
                const options = parts.slice(2, 6).map(opt => opt.trim());

                // Normalize correct answer to 1, 2, 3, 4
                if (correctAnswer === 'A') correctAnswer = '1';
                else if (correctAnswer === 'B') correctAnswer = '2';
                else if (correctAnswer === 'C') correctAnswer = '3';
                else if (correctAnswer === 'D') correctAnswer = '4';

                if (!['1', '2', '3', '4'].includes(correctAnswer)) {
                    console.error("Invalid correct answer format:", correctAnswer);
                    return null; // Invalid correct answer
                }

                if (questionText === '' || options.some(opt => opt === '')) {
                    console.error("Empty question or option:", line);
                    return null; // Empty question or option
                }

                questions.push({
                    questionText: questionText,
                    correctAnswer: correctAnswer,
                    options: options
                });
            }

            if (questions.length === 0) {
                return null; // No valid questions parsed
            }

            return questions;
        }

        /**
         * NEW: Renders custom multiple choice questions on the student side.
         * @param {Array} questions - An array of question objects.
         */
        async function renderMultipleChoiceQuestions(questions) {
            const defaultMcOptions = document.getElementById('default-mc-options');
            const customMcQuestionsContainer = document.getElementById('custom-mc-questions-container');
            const submitCustomMcBtn = document.getElementById('submit-custom-mc-btn');
            const interactionMultipleChoice = document.getElementById('interaction-multiple-choice');

            if (questions && questions.length > 0) {
                defaultMcOptions.classList.add('hidden');
                customMcQuestionsContainer.classList.remove('hidden');
                submitCustomMcBtn.classList.remove('hidden');
                customMcQuestionsContainer.innerHTML = ''; // Clear previous questions
                interactionMultipleChoice.classList.remove('enlarged-buttons'); // Remove enlarged class for custom questions

                // NEW: 檢查學生是否已經提交過答案
                const hasSubmitted = await checkIfStudentSubmitted();
                
                questions.forEach((q, qIndex) => {
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'mc-question-item bg-white p-4 rounded-lg shadow-md';
                    questionDiv.innerHTML = `
                        <p class="font-bold text-lg mb-3 text-gray-800">Q${qIndex + 1}. ${q.questionText}</p>
                        <div class="space-y-2">
                            ${q.options.map((option, optIndex) => `
                                <label class="flex items-center p-2 border border-gray-200 rounded-md cursor-pointer hover:bg-gray-50 transition-colors">
                                    <input type="radio" name="question-${qIndex}" value="${optIndex + 1}" class="form-radio text-blue-600 h-5 w-5" ${hasSubmitted ? 'disabled' : ''}>
                                    <span class="ml-3 text-gray-700">${option}</span>
                                </label>
                            `).join('')}
                        </div>
                    `;
                    customMcQuestionsContainer.appendChild(questionDiv);
                });

                // NEW: 如果已提交，更新按鈕狀態
                if (hasSubmitted) {
                    submitCustomMcBtn.disabled = true;
                    submitCustomMcBtn.classList.replace('btn-primary', 'btn-gray');
                    submitCustomMcBtn.textContent = '已提交答案 ✓';
                    
                    // 顯示已提交的答案
                    await displaySubmittedAnswers();
                }
            } else {
                defaultMcOptions.classList.remove('hidden');
                customMcQuestionsContainer.classList.add('hidden');
                submitCustomMcBtn.classList.add('hidden');
                interactionMultipleChoice.classList.add('enlarged-buttons'); // Add enlarged class for no custom questions
            }
        }

        // NEW: 檢查學生是否已經提交過答案
        async function checkIfStudentSubmitted() {
            if (!studentName || !classroomCode) return false;
            
            try {
                const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
                const docSnap = await getDoc(studentRef);
                
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    // 檢查是否有陣列格式的答案（自訂選擇題）
                    return Array.isArray(data.answer) && data.answer.length > 0;
                }
                return false;
            } catch (error) {
                console.error('檢查提交狀態失敗:', error);
                return false;
            }
        }

        // NEW: 顯示學生已提交的答案
        async function displaySubmittedAnswers() {
            if (!studentName || !classroomCode) return;
            
            try {
                const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
                const docSnap = await getDoc(studentRef);
                
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (Array.isArray(data.answer)) {
                        // 標記已選擇的答案
                        data.answer.forEach(qAns => {
                            const radio = document.querySelector(`input[name="question-${qAns.qIndex}"][value="${qAns.ans}"]`);
                            if (radio) {
                                radio.checked = true;
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('載入已提交答案失敗:', error);
            }
        }


        // --- Canvas State Management Functions ---
        
        /**
         * Saves the current canvas state when switching to peer review.
         */
        function saveCanvasState() {
            if (canvas && currentInteractionMode === 'drawing') {
                try {
                    savedCanvasState = {
                        mainCanvas: canvas.toDataURL(),
                        drawingCanvas: drawingCanvas.toDataURL(),
                        studentImageCanvas: studentImageCanvas.toDataURL(),
                        canvasWidth: canvas.width,
                        canvasHeight: canvas.height
                    };
                    console.log('Canvas state saved');
                } catch (error) {
                    console.error('Error saving canvas state:', error);
                }
            }
        }
        
        /**
         * Restores the canvas state when returning from peer review.
         */
        function restoreCanvasState() {
            if (savedCanvasState && canvas && currentInteractionMode === 'drawing') {
                try {
                    // Ensure canvas setup is complete
                    if (canvas.width === 0 || canvas.height === 0) {
                        setupCanvas();
                    }
                    
                    // Restore canvas dimensions
                    canvas.width = savedCanvasState.canvasWidth;
                    canvas.height = savedCanvasState.canvasHeight;
                    drawingCanvas.width = savedCanvasState.canvasWidth;
                    drawingCanvas.height = savedCanvasState.canvasHeight;
                    studentImageCanvas.width = savedCanvasState.canvasWidth;
                    studentImageCanvas.height = savedCanvasState.canvasHeight;
                    
                    let imagesLoaded = 0;
                    const totalImages = 2; // drawing and student image
                    
                    function checkAllImagesLoaded() {
                        imagesLoaded++;
                        if (imagesLoaded === totalImages) {
                            // All images loaded, recompose the final canvas
                            redrawCanvas();
                            console.log('Canvas state restored');
                        }
                    }
                    
                    // Restore drawing canvas content
                    if (savedCanvasState.drawingCanvas && savedCanvasState.drawingCanvas !== 'data:,') {
                        const drawingImg = new Image();
                        drawingImg.onload = function() {
                            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                            drawingCtx.drawImage(drawingImg, 0, 0);
                            checkAllImagesLoaded();
                        };
                        drawingImg.onerror = function() {
                            console.warn('Failed to load drawing canvas');
                            checkAllImagesLoaded();
                        };
                        drawingImg.src = savedCanvasState.drawingCanvas;
                    } else {
                        drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                        checkAllImagesLoaded();
                    }
                    
                    // Restore student image canvas content
                    if (savedCanvasState.studentImageCanvas && savedCanvasState.studentImageCanvas !== 'data:,') {
                        const studentImg = new Image();
                        studentImg.onload = function() {
                            studentImageCtx.clearRect(0, 0, studentImageCanvas.width, studentImageCanvas.height);
                            studentImageCtx.drawImage(studentImg, 0, 0);
                            checkAllImagesLoaded();
                        };
                        studentImg.onerror = function() {
                            console.warn('Failed to load student image canvas');
                            checkAllImagesLoaded();
                        };
                        studentImg.src = savedCanvasState.studentImageCanvas;
                    } else {
                        studentImageCtx.clearRect(0, 0, studentImageCanvas.width, studentImageCanvas.height);
                        checkAllImagesLoaded();
                    }
                    
                } catch (error) {
                    console.error('Error restoring canvas state:', error);
                    // Fallback: just redraw what we can
                    redrawCanvas();
                }
            }
        }
        
        /**
         * Redraws the main canvas by compositing all layers.
         */
        function redrawCanvas() {
            if (!canvas || !ctx) return;
            
            // Clear main canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background (teacher's background image)
            if (teacherUploadedBackgroundImageDataURL && backgroundCanvas) {
                try {
                    ctx.drawImage(backgroundCanvas, 0, 0);
                } catch (error) {
                    console.warn('Error drawing background canvas:', error);
                }
            }
            
            // Draw student's uploaded image
            if (studentUploadedImageDataURL && studentImageCanvas) {
                try {
                    ctx.drawImage(studentImageCanvas, 0, 0);
                } catch (error) {
                    console.warn('Error drawing student image canvas:', error);
                }
            }
            
            // Draw student's drawing strokes
            if (drawingCanvas) {
                try {
                    ctx.drawImage(drawingCanvas, 0, 0);
                } catch (error) {
                    console.warn('Error drawing drawing canvas:', error);
                }
            }
        }

        // --- Peer Review Functions ---
        
        /**
         * Toggles the peer review process for the current interaction.
         * Only works for text_input and drawing modes.
         */
        async function startPeerReview() {
            if (!currentInteractionMode || (!['text_input', 'drawing'].includes(currentInteractionMode))) {
                showMessage('互評功能只支援文字題和繪圖題！', 'error');
                return;
            }
            
            const startPeerReviewBtn = document.getElementById('start-peer-review-btn');
            
            if (peerReviewActive) {
                // Stop peer review
                try {
                    const peerReviewRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'peerReview');
                    await setDoc(peerReviewRef, { active: false });
                    
                    peerReviewActive = false;
                    showMessage('互評已停止！學生回到原互動模式。', 'info');
                    
                    // Hide voting statistics container
                    document.getElementById('peer-review-stats-container').classList.add('hidden');
                    
                    // Update button text
                    startPeerReviewBtn.innerHTML = '<i class="fas fa-heart mr-2"></i> 開始互評 ❤️';
                    
                } catch (error) {
                    console.error('Error stopping peer review:', error);
                    showMessage('停止互評時發生錯誤，請稍後再試。', 'error');
                }
            } else {
                // Start peer review
                if (allStudentResponses.length === 0) {
                    showMessage('目前沒有學生作答，無法開始互評！', 'error');
                    return;
                }
                
                try {
                    // Set peer review status in Firebase
                    const peerReviewRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'peerReview');
                    await setDoc(peerReviewRef, {
                        active: true,
                        mode: currentInteractionMode,
                        works: allStudentResponses,
                        timestamp: Date.now()
                    });
                    
                    peerReviewActive = true;
                    showMessage('互評已開始！學生可以開始觀摩投票。', 'success');
                    
                    // Show voting statistics container
                    document.getElementById('peer-review-stats-container').classList.remove('hidden');
                    
                    // Start listening for votes
                    listenToPeerReviewVotes();
                    
                    // Update button text
                    startPeerReviewBtn.innerHTML = '<i class="fas fa-stop mr-2"></i> 停止互評 ⏹️';
                    
                } catch (error) {
                    console.error('Error starting peer review:', error);
                    showMessage('開始互評時發生錯誤，請稍後再試。', 'error');
                }
            }
        }
        
        /**
         * Exits peer review mode for students and returns to original interaction mode.
         */
        function exitPeerReview() {
            if (currentInteractionMode && currentInteractionMode !== 'waiting') {
                // Return to the original interaction mode
                showView('studentInteraction');
                showInteractionUI(currentInteractionMode);
                
                // Restore canvas state if returning to drawing mode
                if (currentInteractionMode === 'drawing') {
                    // Use a small delay to ensure canvas is ready
                    setTimeout(() => {
                        restoreCanvasState();
                    }, 100);
                }
            } else {
                // Return to waiting if no active interaction
                showView('studentWaiting');
            }
        }
        
        /**
         * Listens for peer review status changes and updates student UI accordingly.
         */
        function listenToPeerReviewStatus() {
            if (!classroomCode) return;
            
            const peerReviewRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'peerReview');
            onSnapshot(peerReviewRef, (doc) => {
                if (doc.exists() && doc.data().active) {
                    const data = doc.data();
                    if (currentRole === 'student') {
                        // Save canvas state before switching to peer review (if in drawing mode)
                        if (currentInteractionMode === 'drawing') {
                            saveCanvasState();
                        }
                        
                        // Switch student to peer review view
                        showView('studentPeerReview');
                        displayPeerReviewWorks(data.works, data.mode);
                        
                        // Restore student's voting history from Firebase
                        restoreStudentVotingHistory().then(() => {
                            listenToPeerReviewVotes();
                        });
                    }
                } else {
                    // Peer review ended, return to original interaction mode
                    if (currentRole === 'student' && !views.studentPeerReview.classList.contains('hidden')) {
                        if (currentInteractionMode && currentInteractionMode !== 'waiting') {
                            // Return to the original interaction mode
                            showView('studentInteraction');
                            showInteractionUI(currentInteractionMode);
                            
                            // Restore canvas state if returning to drawing mode
                            if (currentInteractionMode === 'drawing') {
                                // Use a small delay to ensure canvas is ready
                                setTimeout(() => {
                                    restoreCanvasState();
                                }, 100);
                            }
                        } else {
                            // Return to waiting if no active interaction
                            showView('studentWaiting');
                        }
                    }
                }
            });
        }
        
        /**
         * Displays peer review works for students to vote on.
         */
        function displayPeerReviewWorks(works, mode) {
            const worksGrid = document.getElementById('peer-review-works-grid');
            worksGrid.innerHTML = '';
            
            works.forEach((work, index) => {
                // Create a more stable unique identifier using timestamp and student name
                const workId = `${work.name}-${work.timestamp || index}`;
                
                const workDiv = document.createElement('div');
                workDiv.className = 'peer-review-work-item';
                workDiv.dataset.workId = workId;
                
                let contentHtml = '';
                if (mode === 'drawing') {
                    contentHtml = `<img src="${work.answer}" alt="學生作品">`;
                } else {
                    contentHtml = `<p>${work.answer}</p>`;
                }
                
                workDiv.innerHTML = `
                    <div class="work-author">${work.name}</div>
                    <div class="work-content">${contentHtml}</div>
                    <div class="vote-section">
                        <button class="vote-btn" data-work-id="${workId}" data-tooltip="點擊投票/取消投票">
                            <i class="fas fa-heart"></i>
                        </button>
                        <span class="vote-count zero">0</span>
                    </div>
                `;
                
                worksGrid.appendChild(workDiv);
            });
            
            // Add vote button listeners and update vote display
            document.querySelectorAll('.vote-btn').forEach(btn => {
                btn.addEventListener('click', handleVote);
                
                // Check if student has already voted for this work
                const workId = btn.dataset.workId;
                if (studentVotedWorks.has(workId)) {
                    btn.classList.add('voted');
                }
            });
            
            // Update vote counts if available
            if (Object.keys(allPeerReviewVotes).length > 0) {
                updateStudentVoteUI(allPeerReviewVotes);
            }
            
            // Update student's vote count display
            updateVoteCountDisplay();
        }
        
        /**
         * Handles voting on a work (toggle vote/unvote).
         */
        async function handleVote(e) {
            const workId = e.currentTarget.dataset.workId;
            const voteBtn = e.currentTarget;
            const voteCountSpan = voteBtn.nextElementSibling;
            
            try {
                if (studentVotedWorks.has(workId)) {
                    // Remove vote (unvote)
                    const voteRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'peerReviewVotes', `${studentName}-${workId}`);
                    await deleteDoc(voteRef);
                    
                    // Remove from local tracking
                    studentVotedWorks.delete(workId);
                    voteBtn.classList.remove('voted');
                    updateVoteCountDisplay();
                    showMessage('已取消投票！', 'info');
                    
                } else {
                    // Add vote
                    if (studentVotedWorks.size >= MAX_VOTES_PER_STUDENT) {
                        showMessage(`最多只能投票 ${MAX_VOTES_PER_STUDENT} 個作品！請先取消其他投票。`, 'warning');
                        return;
                    }
                    
                    const voteRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'peerReviewVotes', `${studentName}-${workId}`);
                    await setDoc(voteRef, {
                        voterName: studentName,
                        workId: workId,
                        timestamp: Date.now()
                    });
                    
                    // Mark as voted locally
                    studentVotedWorks.add(workId);
                    voteBtn.classList.add('voted');
                    updateVoteCountDisplay();
                    showMessage('投票成功！', 'success');
                }
                
            } catch (error) {
                console.error('Error handling vote:', error);
                showMessage('操作失敗，請稍後再試。', 'error');
            }
        }
        
        /**
         * Listens for peer review votes and updates UI.
         * 🚀 OPTIMIZED: 使用 ListenerManager 管理監聽器
         */
        function listenToPeerReviewVotes() {
            if (!classroomCode) return;
            
            const votesRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'peerReviewVotes');
            
            const unsubscribe = onSnapshot(votesRef, (snapshot) => {
                const votes = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (!votes[data.workId]) {
                        votes[data.workId] = 0;
                    }
                    votes[data.workId]++;
                });
                
                allPeerReviewVotes = votes;
                
                // Update student UI
                if (currentRole === 'student' && !views.studentPeerReview.classList.contains('hidden')) {
                    updateStudentVoteUI(votes);
                    updateVoteCountDisplay();
                }
                
                // Update teacher UI
                if (currentRole === 'teacher' && !document.getElementById('peer-review-stats-container').classList.contains('hidden')) {
                    updateTeacherVoteStats(votes);
                }
            });
            
            // 🚀 OPTIMIZED: 使用 ListenerManager 註冊監聽器
            ListenerManager.register('peerReviewVotes', unsubscribe);
            peerReviewUnsubscribe = unsubscribe; // 保持兼容性
        }
        
        /**
         * Updates the vote counts in student UI.
         */
        function updateStudentVoteUI(votes) {
            document.querySelectorAll('.vote-count').forEach(span => {
                const workId = span.previousElementSibling.dataset.workId;
                const count = votes[workId] || 0;
                span.textContent = count;
                span.classList.toggle('zero', count === 0);
            });
        }
        
        /**
         * Updates the student's current vote count display.
         */
        function updateVoteCountDisplay() {
            const voteCountElement = document.getElementById('current-vote-count');
            if (voteCountElement) {
                voteCountElement.textContent = studentVotedWorks.size;
                
                // Change color based on vote count
                const container = voteCountElement.parentElement;
                container.className = 'inline-block px-4 py-2 rounded-full text-sm font-medium';
                
                if (studentVotedWorks.size === 0) {
                    container.classList.add('bg-gray-100', 'text-gray-600');
                } else if (studentVotedWorks.size < MAX_VOTES_PER_STUDENT) {
                    container.classList.add('bg-blue-100', 'text-blue-800');
                } else {
                    container.classList.add('bg-green-100', 'text-green-800');
                }
            }
        }
        
        /**
         * Restores student's voting history from Firebase.
         */
        async function restoreStudentVotingHistory() {
            if (!classroomCode || !studentName) return;
            
            try {
                const votesRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'peerReviewVotes');
                const votesSnapshot = await getDocs(votesRef);
                
                // Clear existing voting history
                studentVotedWorks.clear();
                
                // Find votes made by this student
                votesSnapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.voterName === studentName) {
                        studentVotedWorks.add(data.workId);
                    }
                });
                
                console.log('Restored student voting history:', Array.from(studentVotedWorks));
                
                // Update vote count display after restoration
                updateVoteCountDisplay();
            } catch (error) {
                console.error('Error restoring student voting history:', error);
            }
        }

        /**
         * Updates the teacher's vote statistics display.
         */
        function updateTeacherVoteStats(votes) {
            const statsGrid = document.getElementById('peer-review-stats-grid');
            statsGrid.innerHTML = '';
            
            // Sort works by vote count (descending)
            const sortedWorks = allStudentResponses.map(work => {
                const workId = `${work.name}-${work.timestamp || allStudentResponses.indexOf(work)}`;
                return {
                    ...work,
                    workId: workId,
                    votes: votes[workId] || 0
                };
            }).sort((a, b) => b.votes - a.votes);
            
            sortedWorks.forEach((work, index) => {
                const statsDiv = document.createElement('div');
                statsDiv.className = 'vote-stats-item';
                
                let contentHtml = '';
                if (currentInteractionMode === 'drawing') {
                    contentHtml = `<img src="${work.answer}" alt="學生作品">`;
                } else {
                    contentHtml = `<p>${work.answer}</p>`;
                }
                
                statsDiv.innerHTML = `
                    <div class="stats-author">${work.name}</div>
                    <div class="stats-content">${contentHtml}</div>
                    <div class="stats-votes">
                        <i class="fas fa-heart vote-icon"></i>
                        <span class="vote-count ${work.votes === 0 ? 'zero' : ''}">${work.votes}</span>
                    </div>
                `;
                
                statsGrid.appendChild(statsDiv);
            });
        }

        // --- Initialization Function ---
        async function initialize() {
            // 🚀 OPTIMIZED: 預載常用 DOM 元素到快取
            DOMCache.preload();
            
            loadAISettings(); 
            loadDispatchSettings(); // Load saved combined dispatch settings

            onAuthStateChanged(auth, async user => {
                if (user) {
                    userId = user.uid;
                    document.getElementById('user-id-display').textContent = userId;
                    console.log("Authenticated User ID:", userId);
                    // setupEventListeners(); // Moved this call outside onAuthStateChanged

                    // Check if teacher has a persisted classroom code
                    const savedTeacherClassroomCode = localStorage.getItem('teacherClassroomCode');
                    if (savedTeacherClassroomCode) {
                        classroomCode = savedTeacherClassroomCode;
                        currentRole = 'teacher';
                        document.getElementById('teacher-menu-code-value').textContent = classroomCode; // Update classroom code in teacher menu
                        document.getElementById('end-class-monitor-button-text').textContent = `下課 教室代碼: ${classroomCode}`; // Update button text for monitor view
                        
                        // NEW: Fetch initial pause state and dispatch settings for teacher
                        const controlRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'settings', 'control');
                        const docSnap = await getDoc(controlRef);
                        if (docSnap.exists()) {
                            isResponsePaused = docSnap.data().isPaused || false;
                            // MODIFIED: Load dispatchSettings from Firestore
                            const fetchedDispatchSettings = docSnap.data().dispatchSettings;
                            if (fetchedDispatchSettings) {
                                dispatchSettings.type = fetchedDispatchSettings.type || 'url';
                                dispatchSettings.url = fetchedDispatchSettings.url || '';
                                dispatchSettings.isYoutube = fetchedDispatchSettings.isYoutube || false;
                                dispatchSettings.htmlContent = fetchedDispatchSettings.htmlContent || null;
                            }
                            // NEW: Load custom multiple choice questions from Firestore
                            currentMultipleChoiceQuestions = docSnap.data().multiple_choice_questions || null;
                            customMultipleChoiceQuestions = currentMultipleChoiceQuestions || []; // Sync for teacher UI
                        } else {
                            isResponsePaused = false; // Default to not paused if control doc doesn't exist
                            // dispatchSettings remains at its default or loaded localStorage value
                            currentMultipleChoiceQuestions = null;
                            customMultipleChoiceQuestions = [];
                        }
                        updateTeacherPauseButtonUI(); // Update button UI based on fetched state

                        listenToClassroomPresence(); // Ensure presence listener is established here and remains active
                        showView('teacherMenu');
                    } else {
                        showView('entry');
                    }
                } else {
                    // 🚀 OPTIMIZED: User is null 是 Firebase 認證流程的正常過渡狀態，不是錯誤
                    // signInAnonymously() 執行後，onAuthStateChanged 會再次觸發並傳入有效的 user
                    console.log("[Auth] Waiting for authentication...");
                    // If user is null (e.g., after signOut), ensure we are on the entry view.
                    showView('entry'); 
                }
            });

            document.getElementById('app-id-display').textContent = baseAppId; // Display the base app ID
            
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                    console.log("Signed in with custom token.");
                } else {
                    await signInAnonymously(auth);
                    console.log("Signed in anonymously.");
                }
            } catch (error) {
                console.error("Firebase Authentication failed:", error);
                document.body.innerHTML = `<div class="text-center p-8 text-red-600"><h1 class="text-2xl font-bold">驗證失敗</h1><p>無法連接至互動服務，請檢查 Firebase 設定或網路連線。</p><p class=\"text-sm mt-2\">${error.message}</p></div>`;
            }
        }

        // Add beforeunload handler to warn user about closing window
        let hasEndedClass = false;
        
        // Track when user clicks the end class button
        function markClassEnded() {
            hasEndedClass = true;
        }
        
        // Set up window close warning
        window.onbeforeunload = function() {
            if (!hasEndedClass) {
                return '請先按下紅色下課鍵，再關閉視窗，本提示請先按取消';
            }
        };

        // --- Quick Answer Functions ---
        let quickAnswerActive = false;
        let quickAnswerWinner = null;
        let quickAnswerWinnerDisplayed = false;

        function startQuickAnswer() {
            console.log('[startQuickAnswer] Function called - starting quick answer round');
            quickAnswerActive = true;
            quickAnswerWinner = null;
            quickAnswerWinnerDisplayed = false;

            // Update status text
            const statusText = document.getElementById('quick-answer-status-text');
            statusText.textContent = '搶答開始！快點擊按鈕！';
            console.log('[startQuickAnswer] Status text updated to:', statusText.textContent);

            const container = document.getElementById('quick-answer-button-container');
            container.innerHTML = '';
            container.classList.remove('pointer-events-none');
            console.log('[startQuickAnswer] Container cleared and pointer events enabled');

            // 🚀 FIX: 使用 requestAnimationFrame 確保容器已經渲染完成再生成按鈕
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    // Double RAF ensures layout is complete
                    console.log('[Quick Answer] Generating random button...');
                    
                    // Create the quick answer button
                    const button = document.createElement('button');
                    button.className = 'quick-answer-btn';
                    button.textContent = '快點我';

                    // Calculate random position (ensure button is fully visible)
                    const containerRect = container.getBoundingClientRect();
                    const buttonSize = 200; // 200px width and height
                    
                    // 🚀 FIX: 驗證容器尺寸，如果無效則使用 viewport 尺寸
                    let containerWidth = containerRect.width;
                    let containerHeight = containerRect.height;
                    
                    if (containerWidth < buttonSize || containerHeight < buttonSize) {
                        console.warn('[Quick Answer] Container size invalid, using viewport dimensions');
                        containerWidth = window.innerWidth;
                        containerHeight = window.innerHeight;
                    }
                    
                    console.log(`[Quick Answer] Container size: ${containerWidth}x${containerHeight}`);
                    
                    const maxLeft = containerWidth - buttonSize;
                    const maxTop = containerHeight - buttonSize;

                    const randomLeft = Math.random() * Math.max(0, maxLeft);
                    const randomTop = Math.random() * Math.max(0, maxTop);

                    button.style.left = randomLeft + 'px';
                    button.style.top = randomTop + 'px';
                    
                    console.log(`[Quick Answer] Button position: left=${randomLeft}px, top=${randomTop}px`);

                    // Add click handler
                    button.addEventListener('click', handleQuickAnswerClick);

                    container.appendChild(button);
                    console.log('[startQuickAnswer] Button added to DOM successfully');
                    console.log('[startQuickAnswer] Current container HTML:', container.innerHTML.substring(0, 100));
                });
            });
        }

        async function handleQuickAnswerClick() {
            if (!quickAnswerActive || quickAnswerWinner) return;

            try {
                // 🔥 FIX: Submit with current modeResetToken using submitAnswer to preserve validations
                const response = `搶答成功：${studentName}`;
                const currentToken = window.lastStudentModeResetToken || 0;
                console.log('[handleQuickAnswerClick] Submitting quick answer with token:', currentToken);
                
                // Use submitAnswer with token in extraFields to preserve pause/validation logic
                await submitAnswer(response, { modeResetToken: currentToken });
                
                console.log('[handleQuickAnswerClick] Quick answer submitted successfully with token:', currentToken);

                // 🎉 Mark this student as the winner
                quickAnswerWinner = studentName;

                // Show success message
                document.getElementById('quick-answer-result').classList.remove('hidden');
                document.getElementById('quick-answer-status-text').textContent = '你搶答成功了！';
                document.getElementById('quick-answer-locked').classList.add('hidden');

                // 🎊 Trigger confetti celebration
                if (typeof confetti !== 'undefined') {
                    const duration = 3000;
                    const animationEnd = Date.now() + duration;
                    const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 10000 };

                    function randomInRange(min, max) {
                        return Math.random() * (max - min) + min;
                    }

                    const interval = setInterval(function() {
                        const timeLeft = animationEnd - Date.now();

                        if (timeLeft <= 0) {
                            return clearInterval(interval);
                        }

                        const particleCount = 50 * (timeLeft / duration);
                        confetti(Object.assign({}, defaults, {
                            particleCount,
                            origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
                        }));
                        confetti(Object.assign({}, defaults, {
                            particleCount,
                            origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
                        }));
                    }, 250);
                }

                // Lock the button
                lockQuickAnswerButton(true);

            } catch (error) {
                console.error('Failed to submit quick answer:', error);
                showMessage('搶答提交失敗！', 'error');
            }
        }

        function lockQuickAnswerButton(isWinner = false) {
            const button = document.querySelector('.quick-answer-btn');
            if (button) {
                button.classList.add('locked');
                button.disabled = true;
                button.removeEventListener('click', handleQuickAnswerClick);
            }

            // 🚀 FIX: Only show "locked" message to students who DIDN'T win
            if (!isWinner) {
                document.getElementById('quick-answer-locked').classList.remove('hidden');
                document.getElementById('quick-answer-result').classList.add('hidden');
            }
        }

        // Listen for quick answer winner updates
        function listenToQuickAnswerUpdates() {
            if (currentRole !== 'student' || currentInteractionMode !== 'quick_answer') return;

            // 🚀 FIX: Capture current token to ignore stale snapshots
            const capturedToken = window.lastStudentModeResetToken || 0;
            console.log(`[listenToQuickAnswerUpdates] Starting listener with token: ${capturedToken}`);

            const responsesRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses');
            const unsubscribe = onSnapshot(responsesRef, (snapshot) => {
                // 🚀 FIX: Ignore snapshots from old rounds
                if (window.lastStudentModeResetToken !== capturedToken) {
                    console.log(`[listenToQuickAnswerUpdates] Ignoring stale snapshot (current token: ${window.lastStudentModeResetToken}, captured: ${capturedToken})`);
                    return;
                }

                // 🔥 NEW FIX: Ignore empty snapshots or reset-state snapshots after mode restart
                // After teacher clicks restart, the snapshot will be empty or contain only cleared responses
                // We should NOT rewrite the UI back to "waiting" state - keep the fresh button visible
                if (snapshot.empty) {
                    console.log(`[listenToQuickAnswerUpdates] Ignoring empty snapshot after restart (token: ${capturedToken})`);
                    return;
                }

                const responses = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    // 🔥 CRITICAL FIX: Only process responses from the CURRENT session
                    // Ignore responses without token or with mismatched token
                    const responseToken = data.modeResetToken || 0;
                    if (data.answer && data.answer.includes('搶答成功') && responseToken === capturedToken) {
                        responses.push(data);
                        console.log(`[listenToQuickAnswerUpdates] Valid response found from ${data.name} with matching token ${responseToken}`);
                    } else if (data.answer && data.answer.includes('搶答成功')) {
                        console.log(`[listenToQuickAnswerUpdates] Ignoring response from ${data.name} with stale token ${responseToken} (expected: ${capturedToken})`);
                    }
                });

                // 🔥 NEW FIX: If no valid quick-answer responses found with matching token, don't reset the UI
                // This prevents the race condition where reset clears responses but listener overwrites the fresh button
                if (responses.length === 0) {
                    console.log(`[listenToQuickAnswerUpdates] No valid quick-answer responses with matching token found, keeping current UI (token: ${capturedToken})`);
                    return;
                }

                // If someone already answered and it's not this student, lock the button
                if (responses.length > 0 && !quickAnswerWinner) {
                    const winner = responses[0];
                    if (winner.name !== studentName) {
                        console.log(`[listenToQuickAnswerUpdates] ${winner.name} won the quick answer, locking button`);
                        quickAnswerWinner = winner.name;
                        lockQuickAnswerButton();
                        document.getElementById('quick-answer-status-text').textContent = `${winner.name} 搶答成功！`;
                    }
                }
            });

            // 🚀 FIX: Save unsubscribe function globally
            quickAnswerUnsubscribe = unsubscribe;
        }

        function showQuickAnswerWinner(winnerName) {
            console.log('showQuickAnswerWinner called with:', winnerName);
            if (quickAnswerWinnerDisplayed) {
                console.log('Winner already displayed, skipping');
                return; // Prevent showing multiple times
            }
            quickAnswerWinnerDisplayed = true;
            console.log('Displaying winner overlay');

            // Create a big overlay notification for the teacher
            const overlay = document.createElement('div');
            overlay.id = 'quick-answer-winner-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                animation: fadeIn 0.5s ease-in-out;
            `;

            overlay.innerHTML = `
                <div style="text-align: center; color: white; font-size: 3rem; font-weight: bold;">
                    <i class="fas fa-trophy" style="color: #ffd700; font-size: 6rem; margin-bottom: 20px;"></i>
                    <h1 style="margin: 20px 0; color: #4ade80;">搶答成功！</h1>
                    <h2 style="margin: 20px 0; color: #60a5fa; font-size: 4rem;">${winnerName}</h2>
                    <p style="font-size: 1.5rem; color: #d1d5db;">點擊任意位置關閉</p>
                </div>
                <style>
                    @keyframes fadeIn {
                        from { opacity: 0; transform: scale(0.8); }
                        to { opacity: 1; transform: scale(1); }
                    }
                </style>
            `;

            // Add click handler to close the overlay
            overlay.addEventListener('click', () => {
                overlay.remove();
                quickAnswerWinnerDisplayed = false; // Reset for next round
            });

            document.body.appendChild(overlay);

            // Auto close after 5 seconds
            setTimeout(() => {
                if (overlay.parentElement) {
                    overlay.remove();
                    quickAnswerWinnerDisplayed = false;
                }
            }, 5000);
        }

        // --- Quick Poll Functions ---

        /**
         * Shows the quick poll settings modal
         */
        function showQuickPollSettingsModal() {
            document.getElementById('quick-poll-settings-modal').classList.remove('hidden');
            // Reset form
            document.querySelector('input[name="pollType"][value="emoji"]').checked = true;
            document.getElementById('custom-poll-options-section').classList.add('hidden');
            document.getElementById('custom-poll-options-input').value = '';
            document.getElementById('quick-poll-anonymous-checkbox').checked = true;
        }

        /**
         * Hides the quick poll settings modal
         */
        function hideQuickPollSettingsModal() {
            document.getElementById('quick-poll-settings-modal').classList.add('hidden');
        }

        /**
         * Gets poll options based on selected type
         */
        function getPollOptions(pollType, customOptions = '') {
            switch(pollType) {
                case 'emoji':
                    return ['😊', '😐', '😕'];
                case 'simple':
                    return ['同意', '不同意', '不確定'];
                case 'rating5':
                    return ['1', '2', '3', '4', '5'];
                case 'rating10':
                    return ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
                case 'custom':
                    return customOptions.split('\n').filter(opt => opt.trim() !== '').map(opt => opt.trim());
                default:
                    return [];
            }
        }

        /**
         * Starts a quick poll
         */
        async function startQuickPoll() {
            const question = '快速投票';
            const pollType = document.querySelector('input[name="pollType"]:checked').value;
            const anonymous = document.getElementById('quick-poll-anonymous-checkbox').checked;
            const customOptions = document.getElementById('custom-poll-options-input').value;

            // Validation
            const options = getPollOptions(pollType, customOptions);
            if (options.length === 0) {
                showMessage('請設定有效的投票選項！', 'error');
                return;
            }

            try {
                // Initialize vote counts
                const voteCounts = {};
                options.forEach(opt => voteCounts[opt] = 0);

                // Save poll configuration to Firebase
                quickPollData = {
                    question,
                    pollType,
                    options,
                    anonymous,
                    voteCounts,
                    active: true,
                    timestamp: Date.now()
                };

                const pollRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'quickPoll', 'config');
                await setDoc(pollRef, quickPollData);

                // Clear previous votes
                const votesRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'quickPollVotes');
                const votesSnapshot = await getDocs(votesRef);
                const deletePromises = votesSnapshot.docs.map(doc => deleteDoc(doc.ref));
                await Promise.all(deletePromises);

                // Set interaction mode to quick_poll
                await setInteractionMode('quick_poll');

                quickPollActive = true;
                hideQuickPollSettingsModal();

                // Show stats modal for teacher
                showQuickPollStatsModal();

                // Start listening to votes
                listenToQuickPollVotes();

                showMessage('快速投票已開始！', 'success');
            } catch (error) {
                console.error('Error starting quick poll:', error);
                showMessage('啟動快速投票時發生錯誤，請稍後再試。', 'error');
            }
        }

        /**
         * Shows the quick poll statistics modal
         */
        function showQuickPollStatsModal() {
            const modal = document.getElementById('quick-poll-stats-modal');
            modal.classList.remove('hidden');

            // Display question
            document.getElementById('quick-poll-stats-question').textContent = quickPollData.question;

            // Display online student count
            document.getElementById('poll-online-students').textContent = activeStudentNames.length;

            // Initialize chart
            currentChartType = 'bar';
            updateChartButtonStyles();
            updateQuickPollChart();
        }

        /**
         * Hides the quick poll statistics modal
         */
        function hideQuickPollStatsModal() {
            document.getElementById('quick-poll-stats-modal').classList.add('hidden');
        }

        /**
         * Ends the current quick poll
         */
        async function endQuickPoll() {
            try {
                // Set poll as inactive
                const pollRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'quickPoll', 'config');
                await setDoc(pollRef, { active: false }, { merge: true });

                // Stop interaction
                await setInteractionMode('waiting');

                quickPollActive = false;
                hideQuickPollStatsModal();

                // Unsubscribe from votes listener
                if (quickPollVotesUnsubscribe) {
                    quickPollVotesUnsubscribe();
                    quickPollVotesUnsubscribe = null;
                }

                showMessage('快速投票已結束！', 'info');
            } catch (error) {
                console.error('Error ending quick poll:', error);
                showMessage('結束投票時發生錯誤，請稍後再試。', 'error');
            }
        }

        /**
         * Listens for vote updates
         * 🚀 OPTIMIZED: 使用 ListenerManager 管理監聽器
         */
        function listenToQuickPollVotes() {
            if (!classroomCode || !quickPollData) return;

            const votesRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'quickPollVotes');

            const unsubscribe = onSnapshot(votesRef, (snapshot) => {
                // Aggregate votes
                const voteCounts = {};
                quickPollData.options.forEach(opt => voteCounts[opt] = 0);

                snapshot.forEach(doc => {
                    const voteData = doc.data();
                    if (voteData.option && voteCounts.hasOwnProperty(voteData.option)) {
                        voteCounts[voteData.option]++;
                    }
                });

                // Update quickPollData
                quickPollData.voteCounts = voteCounts;

                // Update UI if teacher is viewing stats
                if (currentRole === 'teacher' && !document.getElementById('quick-poll-stats-modal').classList.contains('hidden')) {
                    updateQuickPollChart();
                    updateQuickPollTable();
                }
            });
            
            // 🚀 OPTIMIZED: 使用 ListenerManager 註冊監聽器
            ListenerManager.register('quickPollVotes', unsubscribe);
            quickPollVotesUnsubscribe = unsubscribe; // 保持兼容性
        }

        /**
         * Updates the quick poll chart
         */
        function updateQuickPollChart() {
            if (!quickPollData) return;

            const svg = d3.select("#quick-poll-chart-svg");
            svg.selectAll("*").remove(); // Clear previous chart

            const data = quickPollData.options.map(opt => ({
                label: opt,
                value: quickPollData.voteCounts[opt] || 0
            }));

            const totalVotes = data.reduce((sum, d) => sum + d.value, 0);
            document.getElementById('poll-total-votes').textContent = totalVotes;

            if (currentChartType === 'bar') {
                drawQuickPollBarChart(svg, data);
            } else {
                drawQuickPollPieChart(svg, data);
            }
        }

        /**
         * Draws a bar chart for quick poll
         */
        function drawQuickPollBarChart(svg, data) {
            const width = 800;
            const height = 450;
            const margin = {top: 20, right: 20, bottom: 60, left: 60};
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            // X scale
            const x = d3.scaleBand()
                .range([0, chartWidth])
                .padding(0.2)
                .domain(data.map(d => d.label));

            // Y scale
            const maxValue = d3.max(data, d => d.value) || 1;
            const y = d3.scaleLinear()
                .range([chartHeight, 0])
                .domain([0, maxValue]);

            // Color scale
            const color = d3.scaleOrdinal()
                .domain(data.map(d => d.label))
                .range(['#84cc16', '#22c55e', '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', '#3b82f6', '#6366f1', '#8b5cf6', '#a855f7']);

            // X axis
            g.append("g")
                .attr("transform", `translate(0,${chartHeight})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .style("font-size", "14px")
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end");

            // Y axis
            g.append("g")
                .call(d3.axisLeft(y).ticks(5))
                .selectAll("text")
                .style("font-size", "14px");

            // Bars
            g.selectAll(".bar")
                .data(data)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d.label))
                .attr("y", d => y(d.value))
                .attr("width", x.bandwidth())
                .attr("height", d => chartHeight - y(d.value))
                .attr("fill", d => color(d.label))
                .attr("rx", 4);

            // Value labels on top of bars
            g.selectAll(".label")
                .data(data)
                .enter()
                .append("text")
                .attr("class", "label")
                .attr("x", d => x(d.label) + x.bandwidth() / 2)
                .attr("y", d => y(d.value) - 5)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .style("font-weight", "bold")
                .style("fill", "#374151")
                .text(d => d.value);
        }

        /**
         * Draws a pie chart for quick poll
         */
        function drawQuickPollPieChart(svg, data) {
            const width = 800;
            const height = 450;
            const radius = Math.min(width, height) / 2 - 40;

            const g = svg.append("g").attr("transform", `translate(${width / 2},${height / 2})`);

            // Color scale
            const color = d3.scaleOrdinal()
                .domain(data.map(d => d.label))
                .range(['#84cc16', '#22c55e', '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', '#3b82f6', '#6366f1', '#8b5cf6', '#a855f7']);

            const pie = d3.pie().value(d => d.value).sort(null);
            const arc = d3.arc().innerRadius(0).outerRadius(radius);
            const labelArc = d3.arc().innerRadius(radius * 0.6).outerRadius(radius * 0.6);

            const arcs = g.selectAll(".arc")
                .data(pie(data))
                .enter()
                .append("g")
                .attr("class", "arc");

            arcs.append("path")
                .attr("d", arc)
                .attr("fill", d => color(d.data.label))
                .attr("stroke", "white")
                .attr("stroke-width", 2);

            // Labels
            arcs.append("text")
                .attr("transform", d => `translate(${labelArc.centroid(d)})`)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .style("fill", "white")
                .each(function(d) {
                    const text = d3.select(this);
                    text.append("tspan")
                        .attr("x", 0)
                        .attr("dy", "-0.2em")
                        .text(d.data.label);
                    text.append("tspan")
                        .attr("x", 0)
                        .attr("dy", "1.2em")
                        .text(d.data.value);
                });
        }

        /**
         * Updates the quick poll data table
         */
        function updateQuickPollTable() {
            if (!quickPollData) return;

            const tbody = document.getElementById('quick-poll-stats-table-body');
            tbody.innerHTML = '';

            const totalVotes = Object.values(quickPollData.voteCounts).reduce((sum, val) => sum + val, 0);

            quickPollData.options.forEach(opt => {
                const count = quickPollData.voteCounts[opt] || 0;
                const percentage = totalVotes > 0 ? ((count / totalVotes) * 100).toFixed(1) : '0.0';

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="border px-4 py-2">${opt}</td>
                    <td class="border px-4 py-2 text-right font-bold">${count}</td>
                    <td class="border px-4 py-2 text-right">${percentage}%</td>
                `;
                tbody.appendChild(row);
            });
        }

        /**
         * Switches between chart types
         */
        function switchChartType(type) {
            currentChartType = type;
            updateChartButtonStyles();
            updateQuickPollChart();
        }

        /**
         * Updates chart type button styles
         */
        function updateChartButtonStyles() {
            const barBtn = document.getElementById('chart-type-bar-btn');
            const pieBtn = document.getElementById('chart-type-pie-btn');

            if (currentChartType === 'bar') {
                barBtn.classList.remove('btn-gray');
                barBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                pieBtn.classList.add('btn-gray');
                pieBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
            } else {
                pieBtn.classList.remove('btn-gray');
                pieBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                barBtn.classList.add('btn-gray');
                barBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
            }
        }

        /**
         * Downloads poll results as CSV
         */
        async function downloadPollResults() {
            if (!quickPollData) return;

            const totalVotes = Object.values(quickPollData.voteCounts).reduce((sum, val) => sum + val, 0);

            let csv = '\uFEFF'; // BOM for Excel UTF-8 support
            csv += `快速投票結果\n`;
            csv += `問題,${quickPollData.question}\n`;
            csv += `總投票數,${totalVotes}\n`;
            csv += `投票模式,${quickPollData.anonymous ? '匿名' : '記名'}\n`;
            csv += `\n`;

            // Summary table
            csv += `選項統計\n`;
            csv += `選項,票數,百分比\n`;
            quickPollData.options.forEach(opt => {
                const count = quickPollData.voteCounts[opt] || 0;
                const percentage = totalVotes > 0 ? ((count / totalVotes) * 100).toFixed(1) : '0.0';
                csv += `${opt},${count},${percentage}%\n`;
            });

            // Detailed votes if not anonymous
            if (!quickPollData.anonymous) {
                csv += `\n詳細投票記錄\n`;
                csv += `學生姓名,選項,投票時間\n`;

                try {
                    const votesRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'quickPollVotes');
                    const votesSnapshot = await getDocs(votesRef);

                    votesSnapshot.forEach(doc => {
                        const voteData = doc.data();
                        const studentName = voteData.studentName || '未知';
                        const option = voteData.option || '';
                        const timestamp = voteData.timestamp ? new Date(voteData.timestamp).toLocaleString('zh-TW') : '';
                        csv += `${studentName},${option},${timestamp}\n`;
                    });
                } catch (error) {
                    console.error('Error fetching vote details:', error);
                }
            }

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = generateFilename('快速投票結果', 'csv');
            link.click();

            showMessage('投票結果已下載！', 'success');
        }

        /**
         * Downloads statistics (for True/False and Multiple Choice) as CSV
         */
        async function downloadStatistics() {
            if (!currentInteractionMode || allStudentResponses.length === 0) {
                showMessage('沒有統計數據可供下載', 'info');
                return;
            }

            let csv = '\uFEFF'; // BOM for Excel UTF-8 support
            const timestamp = new Date().toLocaleString('zh-TW');

            if (currentInteractionMode === 'true_false') {
                // True/False Statistics
                const filteredResponses = allStudentResponses.filter(r => r.answer === 'O' || r.answer === 'X');
                const totalResponses = filteredResponses.length;
                const oCount = filteredResponses.filter(r => r.answer === 'O').length;
                const xCount = filteredResponses.filter(r => r.answer === 'X').length;

                csv += `是非題作答統計\n`;
                csv += `匯出時間,${timestamp}\n`;
                csv += `總作答人數,${totalResponses}\n`;
                csv += `\n`;

                // Summary table
                csv += `選項統計\n`;
                csv += `選項,人數,百分比\n`;
                csv += `O (正確),${oCount},${totalResponses > 0 ? ((oCount / totalResponses) * 100).toFixed(1) : '0.0'}%\n`;
                csv += `X (錯誤),${xCount},${totalResponses > 0 ? ((xCount / totalResponses) * 100).toFixed(1) : '0.0'}%\n`;
                csv += `\n`;

                // Detailed responses
                csv += `詳細作答記錄\n`;
                csv += `學生姓名,答案,作答時間\n`;
                filteredResponses.forEach(r => {
                    const answerTime = r.timestamp 
                        ? (r.timestamp.toDate ? r.timestamp.toDate().toLocaleString('zh-TW') : new Date(r.timestamp).toLocaleString('zh-TW'))
                        : '未知';
                    csv += `${r.name},${r.answer},${answerTime}\n`;
                });

                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = generateFilename('是非題統計', 'csv');
                link.click();

                showMessage('是非題統計已下載！', 'success');

            } else if (currentInteractionMode === 'multiple_choice') {
                if (currentMultipleChoiceQuestions) {
                    // Custom Multiple Choice Statistics
                    const filteredResponses = allStudentResponses.filter(r => Array.isArray(r.answer));
                    
                    csv += `自訂選擇題作答統計\n`;
                    csv += `匯出時間,${timestamp}\n`;
                    csv += `總作答人數,${filteredResponses.length}\n`;
                    csv += `題目總數,${currentMultipleChoiceQuestions.length}\n`;
                    csv += `\n`;

                    // Question-by-question statistics
                    csv += `各題統計\n`;
                    csv += `題號,題目,正確答案,作答人數,答對人數,答對率\n`;
                    currentMultipleChoiceQuestions.forEach((q, qIndex) => {
                        let correctCount = 0;
                        let answeredCount = 0;

                        filteredResponses.forEach(studentResponse => {
                            const studentQAnswer = studentResponse.answer.find(ans => ans.qIndex === qIndex);
                            if (studentQAnswer) {
                                answeredCount++;
                                if (String(studentQAnswer.ans) === String(q.correctAnswer)) {
                                    correctCount++;
                                }
                            }
                        });

                        const correctRate = answeredCount > 0 ? ((correctCount / answeredCount) * 100).toFixed(1) : '0.0';
                        csv += `${qIndex + 1},"${q.question}",${q.correctAnswer},${answeredCount},${correctCount},${correctRate}%\n`;
                    });

                    csv += `\n`;

                    // Detailed student responses
                    csv += `學生詳細作答記錄\n`;
                    csv += `學生姓名,作答時間`;
                    currentMultipleChoiceQuestions.forEach((q, qIndex) => {
                        csv += `,Q${qIndex + 1}答案,Q${qIndex + 1}結果`;
                    });
                    csv += `\n`;

                    filteredResponses.forEach(studentResponse => {
                        const answerTime = studentResponse.timestamp 
                            ? (studentResponse.timestamp.toDate ? studentResponse.timestamp.toDate().toLocaleString('zh-TW') : new Date(studentResponse.timestamp).toLocaleString('zh-TW'))
                            : '未知';
                        csv += `${studentResponse.name},${answerTime}`;
                        
                        currentMultipleChoiceQuestions.forEach((q, qIndex) => {
                            const studentQAnswer = studentResponse.answer.find(ans => ans.qIndex === qIndex);
                            if (studentQAnswer) {
                                const isCorrect = String(studentQAnswer.ans) === String(q.correctAnswer) ? '✓' : '✗';
                                csv += `,${studentQAnswer.ans},${isCorrect}`;
                            } else {
                                csv += `,未作答,`;
                            }
                        });
                        csv += `\n`;
                    });

                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = generateFilename('自訂選擇題統計', 'csv');
                    link.click();

                    showMessage('自訂選擇題統計已下載！', 'success');

                } else {
                    // Default Multiple Choice Statistics (1-4)
                    const filteredResponses = allStudentResponses.filter(r => r.answer >= '1' && r.answer <= '4');
                    const totalResponses = filteredResponses.length;
                    const counts = { '1': 0, '2': 0, '3': 0, '4': 0 };
                    filteredResponses.forEach(r => { counts[r.answer]++; });

                    csv += `選擇題作答統計\n`;
                    csv += `匯出時間,${timestamp}\n`;
                    csv += `總作答人數,${totalResponses}\n`;
                    csv += `\n`;

                    // Summary table
                    csv += `選項統計\n`;
                    csv += `選項,人數,百分比\n`;
                    ['1', '2', '3', '4'].forEach(opt => {
                        const count = counts[opt];
                        const percentage = totalResponses > 0 ? ((count / totalResponses) * 100).toFixed(1) : '0.0';
                        csv += `選項${opt},${count},${percentage}%\n`;
                    });
                    csv += `\n`;

                    // Detailed responses
                    csv += `詳細作答記錄\n`;
                    csv += `學生姓名,答案,作答時間\n`;
                    filteredResponses.forEach(r => {
                        const answerTime = r.timestamp 
                            ? (r.timestamp.toDate ? r.timestamp.toDate().toLocaleString('zh-TW') : new Date(r.timestamp).toLocaleString('zh-TW'))
                            : '未知';
                        csv += `${r.name},選項${r.answer},${answerTime}\n`;
                    });

                    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = generateFilename('選擇題統計', 'csv');
                    link.click();

                    showMessage('選擇題統計已下載！', 'success');
                }
            } else {
                showMessage('此模式不支援統計下載', 'info');
            }
        }

        /**
         * Student submits a vote
         */
        async function submitQuickPollVote(option) {
            if (!classroomCode || !studentName) return;

            const pollKey = `quickPoll_${classroomCode}_${quickPollData.timestamp}`;

            // Check if already voted (using localStorage)
            if (localStorage.getItem(pollKey)) {
                showMessage('您已經投過票了！', 'info');
                return;
            }

            try {
                // Generate unique vote ID (anonymous or with student name based on settings)
                const voteId = quickPollData.anonymous
                    ? `anonymous_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
                    : `${studentName}_${Date.now()}`;

                const voteRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'quickPollVotes', voteId);
                const voteData = {
                    option,
                    timestamp: Date.now()
                };

                // Add student name if not anonymous
                if (!quickPollData.anonymous) {
                    voteData.studentName = studentName;
                }

                await setDoc(voteRef, voteData);

                // Mark as voted in localStorage
                localStorage.setItem(pollKey, 'true');

                // Hide options, show success message
                document.getElementById('quick-poll-options-container').classList.add('hidden');
                document.getElementById('quick-poll-voted-status').classList.remove('hidden');

                showMessage('投票成功！感謝您的參與', 'success');
            } catch (error) {
                console.error('Error submitting vote:', error);
                showMessage('投票失敗，請稍後再試。', 'error');
            }
        }

        /**
         * Displays quick poll for students
         */
        function displayQuickPollForStudent(pollData) {
            if (!pollData || !pollData.active) return;

            quickPollData = pollData;

            // Use timestamp to create unique key for each poll session
            const pollKey = `quickPoll_${classroomCode}_${pollData.timestamp}`;
            const hasVoted = localStorage.getItem(pollKey);

            // Display question
            document.getElementById('quick-poll-question-display').textContent = pollData.question;

            const optionsContainer = document.getElementById('quick-poll-options-container');
            optionsContainer.innerHTML = '';

            if (hasVoted) {
                // Already voted - show success message
                optionsContainer.classList.add('hidden');
                document.getElementById('quick-poll-voted-status').classList.remove('hidden');
            } else {
                // Not voted yet - show options
                optionsContainer.classList.remove('hidden');
                document.getElementById('quick-poll-voted-status').classList.add('hidden');

                // Create buttons based on poll type
                if (pollData.pollType === 'emoji') {
                    optionsContainer.className = 'flex justify-center gap-6';
                    pollData.options.forEach(opt => {
                        const btn = document.createElement('button');
                        btn.className = 'text-8xl hover:scale-110 transition-transform duration-200 p-4 rounded-lg hover:bg-gray-100';
                        btn.textContent = opt;
                        btn.addEventListener('click', () => submitQuickPollVote(opt));
                        optionsContainer.appendChild(btn);
                    });
                } else if (pollData.pollType === 'rating5' || pollData.pollType === 'rating10') {
                    optionsContainer.className = 'flex justify-center gap-3 flex-wrap';
                    pollData.options.forEach(opt => {
                        const btn = document.createElement('button');
                        btn.className = 'btn bg-lime-500 hover:bg-lime-600 !w-20 !h-20 text-4xl font-bold';
                        btn.textContent = opt;
                        btn.addEventListener('click', () => submitQuickPollVote(opt));
                        optionsContainer.appendChild(btn);
                    });
                } else {
                    optionsContainer.className = 'space-y-3';
                    pollData.options.forEach(opt => {
                        const btn = document.createElement('button');
                        btn.className = 'btn bg-lime-500 hover:bg-lime-600 w-full h-16 text-2xl';
                        btn.textContent = opt;
                        btn.addEventListener('click', () => submitQuickPollVote(opt));
                        optionsContainer.appendChild(btn);
                    });
                }
            }
        }

        /**
         * Listens for quick poll configuration changes (for students)
         */
        function listenToQuickPollConfig() {
            if (!classroomCode) return;

            const pollRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'quickPoll', 'config');
            onSnapshot(pollRef, (doc) => {
                if (doc.exists()) {
                    const pollData = doc.data();
                    if (pollData.active && currentRole === 'student' && currentInteractionMode === 'quick_poll') {
                        displayQuickPollForStudent(pollData);
                    }
                }
            });
        }

        // === Reading Comprehension Functions ===

        /**
         * Show reading comprehension settings modal
         */
        function showReadingComprehensionModal() {
            document.getElementById('reading-comprehension-settings-modal').classList.remove('hidden');
            // Populate with existing data if any
            document.getElementById('reading-text-textarea').value = readingComprehensionData.text || '';
            if (readingComprehensionData.questions && readingComprehensionData.questions.length > 0) {
                document.getElementById('reading-questions-textarea').value = readingComprehensionData.questions.map(q => {
                    return `${q.question},${q.correctAnswer},${q.options.join(',')},${q.level}`;
                }).join('\n');
            } else {
                document.getElementById('reading-questions-textarea').value = '';
            }
        }

        /**
         * Hide reading comprehension settings modal
         */
        function hideReadingComprehensionModal() {
            document.getElementById('reading-comprehension-settings-modal').classList.add('hidden');
        }

        /**
         * Parse reading comprehension questions
         * Supports both comma and tab delimiters
         */
        function parseReadingQuestions(text) {
            const lines = text.trim().split('\n').filter(line => line.trim().length > 0);
            const questions = [];

            for (const line of lines) {
                // Try to detect delimiter: if line contains tab, use tab; otherwise use comma
                const delimiter = line.includes('\t') ? '\t' : ',';
                const parts = line.split(delimiter).map(p => p.trim());

                if (parts.length < 6) {
                    return null; // Invalid format - need at least question, answer, and 4 options
                }

                const question = parts[0];
                let correctAnswer = parts[1];
                const options = [parts[2], parts[3], parts[4], parts[5]];
                // Level is optional, default to 1 if not provided
                const level = parts[6] ? parseInt(parts[6]) : 1;

                // Convert A-D to 1-4
                if (correctAnswer.match(/^[A-Da-d]$/)) {
                    correctAnswer = correctAnswer.toUpperCase().charCodeAt(0) - 64; // A=1, B=2, C=3, D=4
                } else {
                    correctAnswer = parseInt(correctAnswer);
                }

                if (!question || isNaN(correctAnswer) || correctAnswer < 1 || correctAnswer > 4 ||
                    options.length !== 4 || isNaN(level) || level < 1 || level > 4) {
                    return null; // Invalid format
                }

                questions.push({ question, correctAnswer, options, level });
            }

            return questions.length > 0 ? questions : null;
        }

        /**
         * Start reading comprehension interaction
         */
        async function startReadingComprehension() {
            const readingText = document.getElementById('reading-text-textarea').value.trim();
            const questionsText = document.getElementById('reading-questions-textarea').value.trim();

            if (!readingText || !questionsText) {
                showMessage('請輸入閱讀文本和題目！', 'error');
                return;
            }

            const questions = parseReadingQuestions(questionsText);
            if (!questions) {
                document.getElementById('reading-questions-status').classList.remove('hidden');
                return;
            }

            readingComprehensionData = { text: readingText, questions: questions };
            document.getElementById('reading-questions-status').classList.add('hidden');
            hideReadingComprehensionModal();

            // Set mode and dispatch to Firebase
            const mode = 'reading_comprehension';
            await setInteractionMode(mode, { readingData: readingComprehensionData });
            showView('teacherMonitor');
        }

        /**
         * Display reading comprehension for student
         */
        async function displayReadingComprehensionForStudent(readingData) {
            console.log('[displayReadingComprehensionForStudent] Called with data:', readingData);
            const textDisplay = document.getElementById('reading-text-display');
            const questionsContainer = document.getElementById('reading-questions-container');

            if (!textDisplay || !questionsContainer) {
                console.error('[displayReadingComprehensionForStudent] Elements not found!');
                return;
            }

            // 🚀 FIX: 檢測是否為新的閱讀測驗會話
            // 比較完整的題目內容（包括問題、選項、正確答案）以避免誤判
            let isNewSession = false;
            if (!readingComprehensionData) {
                isNewSession = true;
            } else if (readingComprehensionData.questions.length !== readingData.questions.length ||
                      readingComprehensionData.text !== readingData.text) {
                isNewSession = true;
            } else {
                // 深度比較題目內容
                for (let i = 0; i < readingData.questions.length; i++) {
                    const oldQ = readingComprehensionData.questions[i];
                    const newQ = readingData.questions[i];
                    if (oldQ.question !== newQ.question ||
                        oldQ.correctAnswer !== newQ.correctAnswer ||
                        JSON.stringify(oldQ.options) !== JSON.stringify(newQ.options)) {
                        isNewSession = true;
                        break;
                    }
                }
            }
            
            if (isNewSession) {
                console.log('[displayReadingComprehensionForStudent] New session detected, clearing previous answers');
                currentReadingAnswers = [];
                // 重置提交按鈕狀態（新測驗）
                const submitBtn = document.getElementById('submit-reading-btn');
                submitBtn.disabled = false;
                submitBtn.classList.remove('btn-gray');
                submitBtn.classList.add('btn-primary');
                submitBtn.textContent = '送出答案 ✉️';
            }

            // Store reading data for student to use when submitting
            if (currentRole === 'student') {
                readingComprehensionData = readingData;
            }

            textDisplay.textContent = readingData.text;
            questionsContainer.innerHTML = '';
            console.log('[displayReadingComprehensionForStudent] Set text:', readingData.text);

            // Determine which answers to restore and check submission status
            let answersToRestore = [];
            let hasSubmittedToFirebase = false;

            // Priority 1: Use current local answers (not yet submitted)
            if (currentReadingAnswers.length > 0 && !isNewSession) {
                answersToRestore = currentReadingAnswers;
                console.log('[displayReadingComprehensionForStudent] Restoring local answers:', answersToRestore);
            }
            // Priority 2: Check if student has already submitted answers to Firebase
            else if (currentRole === 'student' && studentName && classroomCode) {
                try {
                    const studentRef = doc(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses', studentName);
                    const docSnap = await getDoc(studentRef);
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        // Check if answer is a JSON string or array
                        if (typeof data.answer === 'string') {
                            try {
                                const parsed = JSON.parse(data.answer);
                                if (Array.isArray(parsed) && parsed.length > 0) {
                                    answersToRestore = parsed;
                                    hasSubmittedToFirebase = true;
                                }
                            } catch (e) {
                                answersToRestore = [];
                            }
                        } else if (Array.isArray(data.answer) && data.answer.length > 0) {
                            answersToRestore = data.answer;
                            hasSubmittedToFirebase = true;
                        }
                        console.log('[displayReadingComprehensionForStudent] Restoring submitted answers:', answersToRestore, 'hasSubmitted:', hasSubmittedToFirebase);
                    }
                } catch (error) {
                    console.error('Error fetching previous answers:', error);
                }
            }

            // Initialize currentReadingAnswers if empty
            if (currentReadingAnswers.length === 0) {
                currentReadingAnswers = new Array(readingData.questions.length).fill(0);
            }

            readingData.questions.forEach((q, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'bg-white p-4 rounded-lg border';

                // Get answer for this question (if exists)
                const selectedAnswer = answersToRestore[index] || 0;

                questionDiv.innerHTML = `
                    <p class="font-bold text-lg mb-3">${index + 1}. ${q.question}</p>
                    <div class="space-y-2">
                        ${q.options.map((opt, i) => {
                            const isChecked = selectedAnswer === (i + 1) ? 'checked' : '';
                            return `
                            <label class="flex items-center p-2 hover:bg-gray-50 rounded cursor-pointer">
                                <input type="radio" name="reading_q${index}" value="${i + 1}" class="mr-3" ${isChecked} data-question-index="${index}">
                                <span>${i + 1}. ${opt}</span>
                            </label>
                        `}).join('')}
                    </div>
                `;
                questionsContainer.appendChild(questionDiv);
            });

            // Add event listeners to track answer changes
            const radioInputs = questionsContainer.querySelectorAll('input[type="radio"]');
            radioInputs.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const questionIndex = parseInt(e.target.dataset.questionIndex);
                    const selectedValue = parseInt(e.target.value);
                    currentReadingAnswers[questionIndex] = selectedValue;
                    console.log('[Reading] Answer updated:', questionIndex, '=', selectedValue);
                });
            });
            
            // 🚀 FIX: 如果學生已經提交答案到 Firebase，恢復鎖定狀態
            if (hasSubmittedToFirebase) {
                console.log('[displayReadingComprehensionForStudent] Student has submitted, applying lock');
                const submitBtn = document.getElementById('submit-reading-btn');
                submitBtn.disabled = true;
                submitBtn.classList.remove('btn-primary');
                submitBtn.classList.add('btn-gray');
                submitBtn.textContent = '✓ 已送出答案';
                
                // 禁用所有選項
                const allRadios = questionsContainer.querySelectorAll('input[type="radio"]');
                allRadios.forEach(radio => {
                    radio.disabled = true;
                });
                
                // 為已選擇的答案添加視覺標記
                const allLabels = questionsContainer.querySelectorAll('label');
                allLabels.forEach(label => {
                    const radio = label.querySelector('input[type="radio"]');
                    if (radio && radio.checked) {
                        label.classList.add('bg-green-100', 'border-green-400', 'border-2');
                    } else if (radio) {
                        label.classList.add('opacity-50');
                    }
                });
            }
            
            // 🚀 OPTIMIZATION: 手動觸發排行榜更新（防止題目更新時排行榜不刷新）
            // 這確保了即使沒有新的學生作答，排行榜也會反映最新的題目數據
            if (currentRole === 'student' && classroomCode) {
                const studentsColRef = collection(db, 'artifacts', baseAppId, 'public', 'data', 'classrooms', classroomCode, 'studentResponses');
                getDocs(studentsColRef).then(querySnapshot => {
                    const studentsData = [];
                    querySnapshot.forEach(doc => {
                        studentsData.push(doc.data());
                    });
                    updateReadingLeaderboardDisplay(studentsData);
                }).catch(error => {
                    console.error('[displayReadingComprehensionForStudent] Error fetching students for leaderboard:', error);
                });
            }
        }

        /**
         * Submit reading comprehension answer
         */
        async function submitReadingAnswer() {
            const questionsContainer = document.getElementById('reading-questions-container');
            const submitBtn = document.getElementById('submit-reading-btn');
            
            // 🚀 FIX: 防止重複點擊（檢查按鈕是否已被禁用）
            if (submitBtn.disabled) {
                console.log('[submitReadingAnswer] Button already disabled, ignoring click');
                return;
            }
            
            const answers = [];

            // Collect all answers
            for (let i = 0; i < readingComprehensionData.questions.length; i++) {
                const selected = document.querySelector(`input[name="reading_q${i}"]:checked`);
                if (selected) {
                    answers.push(parseInt(selected.value));
                } else {
                    answers.push(0); // No answer
                }
            }

            // 🚀 FIX: 驗證答案（在禁用按鈕之前）
            if (answers.filter(a => a > 0).length === 0) {
                showMessage('請至少回答一題！', 'error');
                return;
            }

            // 驗證通過後才禁用按鈕，防止提交過程中重複點擊
            submitBtn.disabled = true;
            submitBtn.textContent = '送出中...';
            
            try {
                await submitAnswer(JSON.stringify(answers));
                showMessage('答案已提交！', 'success');
                
                // 🚀 FIX: 提交成功後永久鎖定提交按鈕和所有選項
                submitBtn.classList.remove('btn-primary');
                submitBtn.classList.add('btn-gray');
                submitBtn.textContent = '✓ 已送出答案';
                
                // 禁用所有選項，讓學生無法更改答案
                const allRadios = questionsContainer.querySelectorAll('input[type="radio"]');
                allRadios.forEach(radio => {
                    radio.disabled = true;
                });
                
                // 為已選擇的答案添加視覺標記
                const allLabels = questionsContainer.querySelectorAll('label');
                allLabels.forEach(label => {
                    const radio = label.querySelector('input[type="radio"]');
                    if (radio && radio.checked) {
                        label.classList.add('bg-green-100', 'border-green-400', 'border-2');
                    } else if (radio) {
                        label.classList.add('opacity-50');
                    }
                });
                
                // 不要清空 currentReadingAnswers，以便暫停恢復時保留
                // currentReadingAnswers = []; // REMOVED
            } catch (error) {
                // 如果提交失敗，重新啟用按鈕讓學生可以重試
                console.error('[submitReadingAnswer] Submit failed:', error);
                showMessage('提交失敗，請重試！', 'error');
                submitBtn.disabled = false;
                submitBtn.textContent = '送出答案 ✉️';
            }
        }

        /**
         * AI generate PIRLS reading questions
         */
        async function generatePIRLSQuestions() {
            // 🚀 UX: 檢查 API KEY 是否已設定
            if (!checkAPIKey()) return;
            
            const aiTopicTextarea = document.getElementById('ai-reading-topic-textarea');
            const readingTextTextarea = document.getElementById('reading-text-textarea');
            const questionsTextarea = document.getElementById('reading-questions-textarea');
            const aiBtn = document.getElementById('ai-generate-reading-btn');
            const aiIcon = document.getElementById('ai-reading-btn-icon');
            const aiText = document.getElementById('ai-reading-btn-text');
            const aiSpinner = document.getElementById('ai-reading-loading-spinner');

            const topic = aiTopicTextarea.value.trim();

            if (!topic) {
                showMessage('請輸入出題要求！', 'error');
                return;
            }

            // 自動清除舊內容，提供更好的 UX 體驗
            readingTextTextarea.value = '';
            questionsTextarea.value = '';
            
            // 清除後，existingText 永遠為空，每次都生成新文本和題目
            const existingText = '';

            // Show loading
            aiBtn.disabled = true;
            aiText.textContent = '生成中...';
            aiIcon.classList.remove('fa-magic');
            aiIcon.classList.add('fa-spinner', 'fa-spin');
            aiSpinner.classList.remove('hidden');

            try {
                const prompt = existingText
                    ? `根據以下文本，依照 PIRLS 閱讀理解的 4 個層次生成 10 題選擇題：
層次1（直接提取資訊）：3題
層次2（直接推論）：3題
層次3（詮釋整合資訊）：2題
層次4（比較評估內容）：2題

文本：
${existingText}

要求：${topic}

請按照以下格式輸出，每行一題：
題目,正確答案(1-4),選項1,選項2,選項3,選項4,層次(1-4)

範例：
主角的名字是什麼?,2,小明,小華,小美,小強,1`
                    : `請根據以下主題生成一篇適合的閱讀文本，並依照 PIRLS 閱讀理解的 4 個層次生成 10 題選擇題：
層次1（直接提取資訊）：3題
層次2（直接推論）：3題
層次3（詮釋整合資訊）：2題
層次4（比較評估內容）：2題

主題：${topic}

請先輸出文本，然後輸出「---題目---」，再按照以下格式輸出題目，每行一題：
題目,正確答案(1-4),選項1,選項2,選項3,選項4,層次(1-4)`;

                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.7 }
                };

                const apiKey = aiSettings.geminiApiKey;
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    console.error(`[AI 閱讀測驗生成] API 錯誤 ${response.status}:`, errorBody);
                    if (response.status === 400) {
                        throw new Error('❌ API KEY 無效或格式錯誤，請檢查您的 Google AI Studio API Key 設定！');
                    }
                    throw new Error(`AI API request failed with status ${response.status}`);
                }

                const result = await response.json();
                const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

                if (generatedText) {
                    if (!existingText) {
                        // Parse text and questions
                        const parts = generatedText.split('---題目---');
                        if (parts.length === 2) {
                            readingTextTextarea.value = parts[0].trim();
                            questionsTextarea.value = parts[1].trim();
                        } else {
                            questionsTextarea.value = generatedText;
                        }
                    } else {
                        questionsTextarea.value = generatedText;
                    }
                    showMessage('AI 閱讀測驗已成功生成！', 'success');
                } else {
                    throw new Error('AI 未返回有效內容。');
                }

            } catch (error) {
                console.error("AI 閱讀測驗生成失敗:", error);
                const errorMsg = error.message.includes('API KEY') ? error.message : 'AI 生成失敗，請檢查 API Key 或網路連線。';
                showMessage(errorMsg, 'error');
            } finally {
                aiBtn.disabled = false;
                aiText.textContent = 'AI 開始出題';
                aiIcon.classList.add('fa-magic');
                aiIcon.classList.remove('fa-spinner', 'fa-spin');
                aiSpinner.classList.add('hidden');
            }
        }

        /**
         * Show reading comprehension questions modal for teacher
         */
        function showViewReadingQuestionsModal() {
            if (!readingComprehensionData || !readingComprehensionData.questions || readingComprehensionData.questions.length === 0) {
                showMessage('目前沒有閱讀測驗題目可以查看。', 'info');
                return;
            }

            const modal = document.getElementById('view-reading-questions-modal');
            const textDisplay = document.getElementById('view-reading-text-display');
            const questionsDisplay = document.getElementById('view-reading-questions-display');

            // Display text
            textDisplay.textContent = readingComprehensionData.text || '(無文本)';

            // Display questions
            questionsDisplay.innerHTML = '';
            readingComprehensionData.questions.forEach((q, index) => {
                const levelIcon = ['📖', '💭', '🔗', '⚖️'][q.level - 1];
                const levelText = ['直接提取', '直接推論', '詮釋整合', '比較評估'][q.level - 1];

                const questionDiv = document.createElement('div');
                questionDiv.className = 'bg-white p-4 rounded-lg border';
                questionDiv.innerHTML = `
                    <div class="flex items-center gap-2 mb-2">
                        <span class="font-bold text-lg">第 ${index + 1} 題</span>
                        <span class="text-sm bg-blue-100 text-blue-700 px-2 py-1 rounded">${levelIcon} 層次${q.level}: ${levelText}</span>
                    </div>
                    <p class="font-medium text-gray-800 mb-3">${q.question}</p>
                    <div class="space-y-1 ml-4">
                        ${q.options.map((opt, i) => `
                            <div class="flex items-center gap-2">
                                <span class="font-bold ${i + 1 === q.correctAnswer ? 'text-green-600' : 'text-gray-600'}">${i + 1}.</span>
                                <span class="${i + 1 === q.correctAnswer ? 'text-green-600 font-bold' : 'text-gray-700'}">${opt}</span>
                                ${i + 1 === q.correctAnswer ? '<i class="fas fa-check-circle text-green-600 ml-2"></i>' : ''}
                            </div>
                        `).join('')}
                    </div>
                    <div class="mt-2 text-sm text-gray-600">
                        <span class="font-bold">正確答案：</span><span class="text-green-600 font-bold">${q.correctAnswer}</span>
                    </div>
                `;
                questionsDisplay.appendChild(questionDiv);
            });

            modal.classList.remove('hidden');
        }

        /**
         * Hide reading comprehension questions modal
         */
        function hideViewReadingQuestionsModal() {
            document.getElementById('view-reading-questions-modal').classList.add('hidden');
        }

        // === Reading Comprehension Question Bank Functions ===

        /**
         * Load text and questions from separate files
         */
        async function loadReadingFiles() {
            const textFileInput = document.getElementById('reading-text-file-input');
            const questionsFileInput = document.getElementById('reading-questions-file-input');
            const textTextarea = document.getElementById('reading-text-textarea');
            const questionsTextarea = document.getElementById('reading-questions-textarea');

            const textFile = textFileInput.files[0];
            const questionsFile = questionsFileInput.files[0];

            if (!textFile && !questionsFile) {
                showMessage('請至少選擇一個檔案！', 'error');
                return;
            }

            try {
                if (textFile) {
                    const textContent = await textFile.text();
                    textTextarea.value = textContent.trim();
                }

                if (questionsFile) {
                    const questionsContent = await questionsFile.text();
                    questionsTextarea.value = questionsContent.trim();
                }

                showMessage('檔案載入成功！', 'success');

                // Clear file inputs
                textFileInput.value = '';
                questionsFileInput.value = '';
            } catch (error) {
                console.error('讀取檔案失敗:', error);
                showMessage('讀取檔案失敗！', 'error');
            }
        }

        /**
         * Save reading question bank to localStorage
         */
        function saveReadingQuestionBank() {
            const nameInput = document.getElementById('reading-question-bank-name-input');
            const bankName = nameInput.value.trim();
            const textContent = document.getElementById('reading-text-textarea').value.trim();
            const questionsContent = document.getElementById('reading-questions-textarea').value.trim();

            if (!bankName) {
                showMessage('請輸入題庫名稱！', 'error');
                return;
            }

            if (!textContent || !questionsContent) {
                showMessage('請先輸入文本和題目！', 'error');
                return;
            }

            // Check if questions are valid
            const questions = parseReadingQuestions(questionsContent);
            if (!questions) {
                showMessage('題目格式錯誤，請檢查！', 'error');
                return;
            }

            const bank = {
                name: bankName,
                text: textContent,
                questions: questionsContent,
                timestamp: new Date().toISOString()
            };

            // Check if bank name already exists
            const existingIndex = readingQuestionBanks.findIndex(b => b.name === bankName);
            if (existingIndex >= 0) {
                if (!confirm(`題庫「${bankName}」已存在，是否覆蓋？`)) {
                    return;
                }
                readingQuestionBanks[existingIndex] = bank;
            } else {
                readingQuestionBanks.push(bank);
            }

            localStorage.setItem('readingQuestionBanks', JSON.stringify(readingQuestionBanks));
            updateReadingBankList();
            showMessage(`題庫「${bankName}」已儲存！`, 'success');
            nameInput.value = '';
        }

        /**
         * Update reading question bank list display
         */
        function updateReadingBankList() {
            const listContainer = document.getElementById('reading-question-bank-list');

            if (readingQuestionBanks.length === 0) {
                listContainer.innerHTML = '<div class="text-gray-500 text-sm italic text-center">目前沒有儲存的題庫</div>';
                return;
            }

            listContainer.innerHTML = readingQuestionBanks.map((bank, index) => `
                <div class="flex items-center justify-between p-2 bg-white border rounded hover:bg-gray-50">
                    <button onclick="loadReadingBankToTextarea(${index})" class="text-left flex-1 text-sm text-blue-600 hover:underline">
                        ${bank.name}
                    </button>
                    <button onclick="deleteReadingBank(${index})" class="text-red-500 hover:text-red-700 ml-2">
                        <i class="fas fa-trash text-xs"></i>
                    </button>
                </div>
            `).join('');
        }

        /**
         * Load reading bank to textarea
         */
        function loadReadingBankToTextarea(index) {
            if (index >= 0 && index < readingQuestionBanks.length) {
                const bank = readingQuestionBanks[index];
                document.getElementById('reading-text-textarea').value = bank.text;
                document.getElementById('reading-questions-textarea').value = bank.questions;
                showMessage(`題庫「${bank.name}」已載入`, 'success');
            }
        }

        /**
         * Delete reading bank
         */
        function deleteReadingBank(index) {
            if (index >= 0 && index < readingQuestionBanks.length) {
                const bankName = readingQuestionBanks[index].name;
                if (confirm(`確定要刪除題庫「${bankName}」嗎？`)) {
                    readingQuestionBanks.splice(index, 1);
                    localStorage.setItem('readingQuestionBanks', JSON.stringify(readingQuestionBanks));
                    updateReadingBankList();
                    showMessage(`題庫「${bankName}」已刪除`, 'success');
                }
            }
        }

        // Make functions globally accessible
        window.loadReadingBankToTextarea = loadReadingBankToTextarea;
        window.deleteReadingBank = deleteReadingBank;

        // Load reading question banks from localStorage on init
        const savedReadingBanks = localStorage.getItem('readingQuestionBanks');
        if (savedReadingBanks) {
            try {
                readingQuestionBanks = JSON.parse(savedReadingBanks);
                updateReadingBankList();
            } catch (e) {
                console.error('Failed to parse reading question banks:', e);
            }
        }

        // --- Start Application ---
        initialize();
        setupEventListeners(); // Call setupEventListeners only once here.

    </script>
</body>
</html>